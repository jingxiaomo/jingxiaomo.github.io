<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="kumira">
  <meta name="keywords" content="">
  <title>Java学习笔记（二）面向对象编程 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Komorebi</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/1%E5%8D%9A%E5%AE%A2/b.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-14 17:49">
      June 14, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      125
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-post-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-post-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/1JAVA%E5%AD%A6%E4%B9%A0/%E6%88%AA%E5%B1%8F2020-05-29%20%E4%B8%8B%E5%8D%883.42.19.png" srcset="/img/loading.gif" alt=""></p>
<p>方法区最先有数据，方法区中存放代码片段，存放class字节码。</p>
<p>堆内存：后面讲。</p>
<p>栈内存：方法调用的时候，该方法需要的内存空间在栈中分配。</p>
<p>方法只有在调用的时候才会在栈中分配空间，并且调用时是压栈。方法执行结束之后，该方法所需要的空间就会释放，此时发生弹栈动作。</p>
<h3 id="方法执行时内存变化"><a href="#方法执行时内存变化" class="headerlink" title="方法执行时内存变化"></a>方法执行时内存变化</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
    System.out.println(<span class="hljs-string">"main begin"</span>);
  	<span class="hljs-keyword">int</span> x=<span class="hljs-number">100</span>;
  	m1(x);
  	System.out.println(<span class="hljs-string">"main over"</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;
  	System.out.println(<span class="hljs-string">"m1 begin"</span>);
  	m2(i);
  	System.out.println(<span class="hljs-string">"m1 over"</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;
  	System.out.println(<span class="hljs-string">"m2 begin"</span>);
  	m3(i);
  	System.out.println(<span class="hljs-string">"m2 over"</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;
  	System.out.println(<span class="hljs-string">"m3 begin"</span>);
  	System.out.println(i);
  	System.out.println(<span class="hljs-string">"m3 over"</span>);
&#125;</code></pre>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/1JAVA%E5%AD%A6%E4%B9%A0/%E6%88%AA%E5%B1%8F2020-05-29%20%E4%B8%8B%E5%8D%884.09.40.png" srcset="/img/loading.gif" alt=""></p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/1JAVA%E5%AD%A6%E4%B9%A0/%E6%88%AA%E5%B1%8F2020-05-29%20%E4%B8%8B%E5%8D%884.13.46.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="方法重载（overload）"><a href="#方法重载（overload）" class="headerlink" title="方法重载（overload）"></a>方法重载（overload）</h2><p>什么时候代码会发生方法重载？</p>
<p>条件1：在同一个类当中；</p>
<p>条件2：方法名相同；</p>
<p>条件3：参数列表不同（参数的个数不同、参数的类型不同、参数的顺序不同）。</p>
<p>只要同时满足以上3个条件，那么我们可以认定方法和方法之间发生了重载机制。</p>
<h1 id="认识面向对象"><a href="#认识面向对象" class="headerlink" title="认识面向对象"></a>认识面向对象</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>对于C语言来说，是完全面向过程的；</p>
<p>对于C++语言来说，是一半面向过程，一半面向对象；</p>
<p>对于JAVA语言来说，是完全面向对象的。</p>
<h2 id="OOA、OOD、OOP"><a href="#OOA、OOD、OOP" class="headerlink" title="OOA、OOD、OOP"></a>OOA、OOD、OOP</h2><p>当我们采用面向对象的方式贯穿整个系统的话，涉及到三个术语：</p>
<p>OOA：面向对象分析；</p>
<p>OOD：面向对象设计；</p>
<p>OOP：面向对象编程。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类—【实例化】—&gt;对象（实例）</p>
<p>对象—【抽象】—&gt;类</p>
<h1 id="对象的创建和使用"><a href="#对象的创建和使用" class="headerlink" title="对象的创建和使用"></a>对象的创建和使用</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>Java中所有的“类”都属于引用数据类型。</p>
<h3 id="创建对象对应的JVM内存结构"><a href="#创建对象对应的JVM内存结构" class="headerlink" title="创建对象对应的JVM内存结构"></a>创建对象对应的JVM内存结构</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;
  	<span class="hljs-keyword">int</span> no;
  	string name;
  	<span class="hljs-keyword">int</span> age;
  	<span class="hljs-keyword">boolean</span> sex;
  	String addr;
&#125;

<span class="hljs-keyword">public</span> Class StudentTest&#123;
  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
      	<span class="hljs-comment">//s1这个局部变量叫做引用，指向创建的对象</span>
      	Student s1=<span class="hljs-keyword">new</span> Student();
    &#125;
&#125;</code></pre>
<blockquote>
<p>对象和引用的区别</p>
<p>对象是通过new出来的，在堆内存中存储；</p>
<p>引用是：但凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象的。</p>
</blockquote>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/1JAVA%E5%AD%A6%E4%B9%A0/%E6%88%AA%E5%B1%8F2020-06-01%20%E4%B8%8B%E5%8D%883.32.47.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span></span>&#123;
    A o1=<span class="hljs-keyword">new</span> A();
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
        D d=<span class="hljs-keyword">new</span> D();
      	C c=<span class="hljs-keyword">new</span> C();
      	B b=<span class="hljs-keyword">new</span> B();
      	A a=<span class="hljs-keyword">new</span> A();
      	T t=<span class="hljs-keyword">new</span> T();
      
      	<span class="hljs-comment">//这里代码不写会出现NullPointerException（空指针异常）</span>
      	<span class="hljs-comment">//因为如果不写的话，t.o1的new A()之后o1是null的</span>
      	c.o4=d;
      	b.o3=c;
      	a.o2=b;
      	t.o1=a;
      
      	System.out.println(t.o1.o2.o3.o4.i);
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;
  	B o2;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;
  	C o3;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;
  	D o4;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span></span>&#123;
  	<span class="hljs-keyword">int</span> i;
&#125;</code></pre>
<p>Java中的垃圾回收器GC主要针对回收的是堆内存当中的垃圾数据。当没有任何引用指向该对象的时候数据会被垃圾回收器回收。</p>
<p>空指针异常导致的最本质的原因是？空引用访问“实例相关的数据”，会出现空指针异常。</p>
<h2 id="方法调用时参数传递"><a href="#方法调用时参数传递" class="headerlink" title="方法调用时参数传递"></a>方法调用时参数传递</h2><p>Java中关于方法调用时参数传递实际上只有一个规则：</p>
<p>不管你是基本数据类型，还是<u>引用数据类型</u>，实际上在传递的时候都是将变量中保存的那个“值”复制一份，传过去。</p>
<pre><code class="hljs java">Person p1=<span class="hljs-number">0x1234</span>;
Person p2=p1;	<span class="hljs-comment">//把p1中保存的0x1234复制一份传给p2。</span></code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
        Person p=<span class="hljs-keyword">new</span> Person();
        p.age=<span class="hljs-number">10</span>;
      	add(p);
      	System.out.println(<span class="hljs-string">"main---&gt;"</span>+p.age);	<span class="hljs-comment">//11</span>
    &#125;
  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Person p)</span></span>&#123;
      p.age++;
      System.out.println(<span class="hljs-string">"add---&gt;"</span>+p.age);	<span class="hljs-comment">//11</span>
    &#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;
  	<span class="hljs-keyword">int</span> age;
&#125;</code></pre>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>当一个类没有提供任何构造方法，系统会默认提供一个无参数的构造方法，这个构造方法被称为缺省构造器。</p>
<p>当一个类中手动地提供了构造方法，那么系统将不再提供无参数构造方法。</p>
<p>构造器的修饰符一定是public。</p>
<p>构造器方法不需要指定返回值类型，也不能写void。</p>
<h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><p>封装、继承、多态（递进）。</p>
<p>有了封装，才有继承；有了继承，才说多态。</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="封装有什么用"><a href="#封装有什么用" class="headerlink" title="封装有什么用"></a>封装有什么用</h2><p>假设封装之后，对于代码的调用人员来说，不需要关心代码的复杂实现，只需要通过一个简单的入口就可以访问了。</p>
<p>另外，类体中安全级别较高的数据封装起来，外部人员不能随意访问，来保证数据的安全性。</p>
<h2 id="怎么进行封装"><a href="#怎么进行封装" class="headerlink" title="怎么进行封装"></a>怎么进行封装</h2><p>第一步：属性私有化；</p>
<p>第二步：对外提供简单的操作入口（一个属性对外提供set和get方法，外部程序只能通过set方法修改，只能通过get方法访问，可以在set方法中设立关卡来保证数据的安全性）。</p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>没有static的方法被称为实例方法。</p>
<h2 id="set方法和get方法的封装"><a href="#set方法和get方法的封装" class="headerlink" title="set方法和get方法的封装"></a>set方法和get方法的封装</h2><p>JAVA开发规范中有要求，set方法和get方法要满足以下格式。</p>
<p>get方法的要求：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> 返回值类型 get+属性名首字母大写(无参)&#123;
  	<span class="hljs-keyword">return</span> xxx;
&#125;</code></pre>
<p>set方法的要求：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> set+属性名首字母大写(有<span class="hljs-number">1</span>个参数)&#123;
  	xxx=参数;
&#125;</code></pre>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>所有static关键字修饰的都是类相关的，类级别的。</p>
<p>所有static修饰的，都是采用“类名.”的方式访问。</p>
<blockquote>
<p>变量的分类：</p>
<p>变量根据声明的位置进行划分：</p>
<p>在方法体当中声明的变量叫做：局部变量；</p>
<p>在方法体外声明的变量叫做：成员变量。</p>
<p>成员变量又可以分为：</p>
<p>实例变量；静态变量。</p>
</blockquote>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>该变量对于每个对象来说是相同的，即改变量与对象的不同无关，才定义为静态变量。</p>
<p>静态变量在类加载时初始化，不需要new对象，静态变量的空间就开出来了。</p>
<p>静态变量存储在方法区。</p>
<p>构造方法里不用写静态变量的初始化。</p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/1JAVA%E5%AD%A6%E4%B9%A0/%E6%88%AA%E5%B1%8F2020-06-06%20%E4%B8%8B%E5%8D%889.41.39.png" srcset="/img/loading.gif" alt=""></p>
<p>静态的（静态变量、静态方法）建议使用“类名.”来访问，但使用“引用.”也行。</p>
<p>空指针访问静态不会空指针。</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>方法一般都是描述了一个行为，如果说该行为必须由对象去触发，那么该方法定义为实例方法。</p>
<p>当这个方法体中，直接访问了实例变量，那么这个方法一定是实例方法。</p>
<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><h3 id="什么是静态代码块？语法是什么？"><a href="#什么是静态代码块？语法是什么？" class="headerlink" title="什么是静态代码块？语法是什么？"></a>什么是静态代码块？语法是什么？</h3><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;
  	java语句;
  	java语句;
&#125;</code></pre>
<h3 id="静态代码块在什么时候执行呢？"><a href="#静态代码块在什么时候执行呢？" class="headerlink" title="静态代码块在什么时候执行呢？"></a>静态代码块在什么时候执行呢？</h3><p>类加载时执行，并且只执行一次。</p>
<p>静态代码块在类加载时执行，并且在main方法执行之前执行。</p>
<p>静态代码块一般是按照自上而下的顺序执行。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticTest</span></span>&#123;
  	<span class="hljs-comment">//静态代码块</span>
  	<span class="hljs-keyword">static</span>&#123;
        System.out.println(<span class="hljs-string">"A"</span>);
    &#125;
  
  	<span class="hljs-comment">//一个类当中可以编写多个静态代码块</span>
  	<span class="hljs-keyword">static</span>&#123;
      	System.out.println(<span class="hljs-string">"B"</span>);
    &#125;
  
  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
      	
    &#125;
  	
  	<span class="hljs-keyword">static</span>&#123;
      	System.out.println(<span class="hljs-string">"C"</span>);
    &#125;
&#125;</code></pre>
<h3 id="静态代码块的作用"><a href="#静态代码块的作用" class="headerlink" title="静态代码块的作用"></a>静态代码块的作用</h3><p>静态代码块这种语法机制实际上是SUN公司给java程序员的一个特殊的时刻/时机。这个时机叫做类加载时机。</p>
<blockquote>
<p>具体的业务：</p>
<p>项目经理说了：大家注意了，所有我们编写的程序中，只要是类加载了，请记录一下类加载的日志信息（在哪年哪月哪日几时几分几秒，哪个类加载到JVM中了）。</p>
<p>这些记录日志的代码写到静态代码块中。</p>
</blockquote>
<h2 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h2><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MALE = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FEMALE = <span class="hljs-number">2</span>;
&#125;</code></pre>
<p>实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-comment">// 编译器会自动加上public statc final:</span>
    <span class="hljs-keyword">int</span> MALE = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> FEMALE = <span class="hljs-number">2</span>;
&#125;</code></pre>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>JAVA使用extends关键字实现继承。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;...&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;...&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;...&#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;...&#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-comment">// 不要重复name和age字段/方法,</span>
    <span class="hljs-comment">// 只需要定义新增score字段/方法:</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> score;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123; … &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> score)</span> </span>&#123; … &#125;
&#125;</code></pre>
<p>在OOP的术语中，我们把Person称为超类、父类、基类，把<code>Student</code>称为子类、扩展类。</p>
<h2 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h2><p>注意到我们在定义<code>Person</code>的时候，没有写<code>extends</code>。在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。所以，任何类，除了<code>Object</code>，都会继承自某个类。下图是<code>Person</code>、<code>Student</code>的继承树：</p>
<pre><code class="hljs ascii">┌───────────┐
│  Object   │
└───────────┘
      ▲
      │
┌───────────┐
│  Person   │
└───────────┘
      ▲
      │
┌───────────┐
│  Student  │
└───────────┘</code></pre>
<p>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p>
<h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p><code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。</p>
<p>例如：</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, "</span> + <span class="hljs-keyword">super</span>.name;
    &#125;
&#125;</code></pre>
<p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p>
<p>但是，在某些时候，就必须使用<code>super</code>。我们来看一个例子：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Student s = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Xiao Ming"</span>, <span class="hljs-number">12</span>, <span class="hljs-number">89</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">protected</span> String name;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> score;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> score)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.score = score;
    &#125;
&#125;</code></pre>
<p>运行上面的代码，会得到一个编译错误，大意是在<code>Student</code>的构造方法中，无法调用<code>Person</code>的构造方法。</p>
<p>这是因为在Java中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>。</p>
<p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p>
<p>因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p>
<p>子类<em>不会继承</em>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p>
<h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Student();</code></pre>
<p>这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。</p>
<p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p>
<pre><code class="hljs java">Student s = <span class="hljs-keyword">new</span> Student();
Person p = s; <span class="hljs-comment">// upcasting, ok</span>
Object o1 = p; <span class="hljs-comment">// upcasting, ok</span>
Object o2 = s; <span class="hljs-comment">// upcasting, ok</span></code></pre>
<p>可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p>
<h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><pre><code class="hljs java">Person p1 = <span class="hljs-keyword">new</span> Student(); <span class="hljs-comment">// upcasting, ok</span>
Person p2 = <span class="hljs-keyword">new</span> Person();
Student s1 = (Student) p1; <span class="hljs-comment">// ok</span>
Student s2 = (Student) p2; <span class="hljs-comment">// runtime error! ClassCastException!</span></code></pre>
<p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p>
<pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Person();
System.out.println(p <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true</span>
System.out.println(p <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// false</span>

Student s = <span class="hljs-keyword">new</span> Student();
System.out.println(s <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true</span>
System.out.println(s <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// true</span>

Student n = <span class="hljs-keyword">null</span>;
System.out.println(n <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// false</span></code></pre>
<p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。</p>
<p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：</p>
<pre><code class="hljs java">Object obj = <span class="hljs-string">"hello"</span>;
<span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String) &#123;
    String s = (String) obj;
    System.out.println(s.toUpperCase());
&#125;</code></pre>
<p>可以改写如下：</p>
<pre><code class="hljs java">Object obj = <span class="hljs-string">"hello"</span>;
<span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String s) &#123;
    System.out.println(s.toUpperCase());
&#125;</code></pre>
<p>使用<code>instanceof variable</code>这种判断并转型为指定类型变量的语法时，必须打开编译器开关<code>--source 14</code>和<code>--enable-preview</code>。</p>
<h1 id="多态（Polymorphic）"><a href="#多态（Polymorphic）" class="headerlink" title="多态（Polymorphic）"></a>多态（Polymorphic）</h1><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p>
<p>Override和Overload不同的是，如果方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</p>
<blockquote>
<p>方法签名由方法名称和一个参数列表(方法的参数的顺序和类型)组成。 </p>
</blockquote>
<p>方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p>
<p>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。但是<code>@Override</code>不是必需的。</p>
<p>现在，我们考虑一种情况，如果子类覆写了父类的方法：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;
        Person p = <span class="hljs-keyword">new</span> Student();
        p.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">//输出Student.run</span>
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Person.run"</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-title">extends</span> <span class="hljs-title">Person</span> &#123;</span>
    @Override
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Student.run"</span>);
    &#125;
&#125;</code></pre>
<p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p>
<p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</p>
<p>假设我们编写这样一个方法：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runTwice</span><span class="hljs-params">(Person p)</span> </span>&#123;
    p.run();
    p.run();
&#125;</code></pre>
<p>它传入的参数类型是<code>Person</code>，我们是无法知道传入的参数实际类型究竟是<code>Person</code>，还是<code>Student</code>，还是<code>Person</code>的其他子类，因此，也无法确定调用的是不是<code>Person</code>类定义的<code>run()</code>方法。</p>
<p>所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span>
        Income[] incomes = <span class="hljs-keyword">new</span> Income[] &#123;
            <span class="hljs-keyword">new</span> Income(<span class="hljs-number">3000</span>),
            <span class="hljs-keyword">new</span> Salary(<span class="hljs-number">7500</span>),
            <span class="hljs-keyword">new</span> StateCouncilSpecialAllowance(<span class="hljs-number">15000</span>)
        &#125;;
        System.out.println(totalTax(incomes));
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">totalTax</span><span class="hljs-params">(Income... incomes)</span> </span>&#123;
        <span class="hljs-keyword">double</span> total = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (Income income: incomes) &#123;
            total = total + income.getTax();
        &#125;
        <span class="hljs-keyword">return</span> total;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Income</span> </span>&#123;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> income;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Income</span><span class="hljs-params">(<span class="hljs-keyword">double</span> income)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.income = income;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getTax</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> income * <span class="hljs-number">0.1</span>; <span class="hljs-comment">// 税率10%</span>
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Income</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Salary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> income)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(income);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getTax</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (income &lt;= <span class="hljs-number">5000</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> (income - <span class="hljs-number">5000</span>) * <span class="hljs-number">0.2</span>;
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateCouncilSpecialAllowance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Income</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StateCouncilSpecialAllowance</span><span class="hljs-params">(<span class="hljs-keyword">double</span> income)</span> </span>&#123;
        <span class="hljs-keyword">super</span>(income);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getTax</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
&#125;</code></pre>
<p>观察<code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</p>
<h2 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h2><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">protected</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, "</span> + name;
    &#125;
&#125;

Student extends Person &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 调用父类的hello()方法:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.hello() + <span class="hljs-string">"!"</span>;
    &#125;
&#125;</code></pre>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>。</p>
<p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承。</p>
<p>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。可以在构造方法中初始化final字段。</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>
<p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p>
<p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p>
<pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>
<h2 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h2><p>无法实例化的抽象类有什么用？</p>
<p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p>
<p>例如，<code>Person</code>类定义了抽象方法<code>run()</code>，那么，在实现子类<code>Student</code>的时候，就必须覆写<code>run()</code>方法：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Person p = <span class="hljs-keyword">new</span> Student();
        p.run();
    &#125;
&#125;

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"Student.run"</span>);
    &#125;
&#125;</code></pre>
<h2 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h2><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p>
<pre><code class="hljs java">Person s = <span class="hljs-keyword">new</span> Student();
Person t = <span class="hljs-keyword">new</span> Teacher();</code></pre>
<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p>
<pre><code class="hljs java"><span class="hljs-comment">// 不关心Person变量的具体子类型:</span>
s.run();
t.run();</code></pre>
<p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p>
<p>面向抽象编程的本质就是：</p>
<ul>
<li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li>
<li>不需要子类就可以实现业务逻辑（正常编译）；</li>
<li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p>
<pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>
<p>就可以把该抽象类改写为接口：<code>interface</code>。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>
<p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p>
<p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">" run"</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
    &#125;
&#125;</code></pre>
<p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span>, <span class="hljs-title">Hello</span> </span>&#123; <span class="hljs-comment">// 实现了两个interface</span>
    ...
&#125;</code></pre>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p>
<p>抽象类和接口的对比如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">abstract class</th>
<th style="text-align:left">interface</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">继承</td>
<td style="text-align:left">只能extends一个class</td>
<td style="text-align:left">可以implements多个interface</td>
</tr>
<tr>
<td style="text-align:left">字段</td>
<td style="text-align:left">可以定义实例字段</td>
<td style="text-align:left">不能定义实例字段</td>
</tr>
<tr>
<td style="text-align:left">抽象方法</td>
<td style="text-align:left">可以定义抽象方法</td>
<td style="text-align:left">可以定义抽象方法</td>
</tr>
<tr>
<td style="text-align:left">非抽象方法</td>
<td style="text-align:left">可以定义非抽象方法</td>
<td style="text-align:left">可以定义default方法</td>
</tr>
</tbody>
</table>
</div>
<h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Hello</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>;
&#125;

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hello</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;
&#125;</code></pre>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p>合理设计<code>interface</code>和<code>abstract class</code>的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p>
<pre><code class="hljs ascii">┌───────────────┐
│   Iterable    │
└───────────────┘
        ▲                ┌───────────────────┐
        │                │      Object       │
┌───────────────┐        └───────────────────┘
│  Collection   │                  ▲
└───────────────┘                  │
        ▲     ▲          ┌───────────────────┐
        │     └──────────│AbstractCollection │
┌───────────────┐        └───────────────────┘
│     List      │                  ▲
└───────────────┘                  │
              ▲          ┌───────────────────┐
              └──────────│   AbstractList    │
                         └───────────────────┘
                                ▲     ▲
                                │     │
                                │     │
                     ┌────────────┐ ┌────────────┐
                     │ ArrayList  │ │ LinkedList │
                     └────────────┘ └────────────┘</code></pre>
<p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：</p>
<pre><code class="hljs java">List list = <span class="hljs-keyword">new</span> ArrayList(); <span class="hljs-comment">// 用List接口引用具体子类的实例</span>
Collection coll = list; <span class="hljs-comment">// 向上转型为Collection接口</span>
Iterable it = coll; <span class="hljs-comment">// 向上转型为Iterable接口</span></code></pre>
<h2 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h2><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Person p = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Xiao Ming"</span>);
        p.run();
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(getName() + <span class="hljs-string">" run"</span>);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.name = name;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
    &#125;
&#125;</code></pre>
<p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>在Java中，我们使用<code>package</code>来解决名字冲突。</p>
<p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p>
<p>例如：</p>
<p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p>
<p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p>
<p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p>
<p>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</p>
<p>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</p>
<p>小明的<code>Person.java</code>文件：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> ming; <span class="hljs-comment">// 申明包名ming</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
&#125;</code></pre>
<p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</p>
<p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p>
<blockquote>
<p>要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p>
</blockquote>
<p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p>
<pre><code class="hljs ascii">package_sample
└─ src
    ├─ hong
    │  └─ Person.java
    │  ming
    │  └─ Person.java
    └─ mr
       └─ jun
          └─ Arrays.java</code></pre>
<p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下，那么，编译的文件结构就是：</p>
<pre><code class="hljs ascii">package_sample
└─ bin
   ├─ hong
   │  └─ Person.class
   │  ming
   │  └─ Person.class
   └─ mr
      └─ jun
         └─ Arrays.class</code></pre>
<p>编译的命令相对比较复杂，我们需要在<code>src</code>目录下执行<code>javac</code>命令：</p>
<pre><code class="hljs shell">javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java</code></pre>
<h2 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h2><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> hello;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-comment">// 包作用域:</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"Hello!"</span>);
    &#125;
&#125;</code></pre>
<p><code>Main</code>类也定义在<code>hello</code>包下面：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> hello;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Person p = <span class="hljs-keyword">new</span> Person();
        p.hello(); <span class="hljs-comment">// 可以调用，因为Main和Person在同一个包</span>
    &#125;
&#125;</code></pre>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。例如，小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法：</p>
<p>第一种，直接写出完整类名，例如：</p>
<pre><code class="hljs java"><span class="hljs-comment">// Person.java</span>
<span class="hljs-keyword">package</span> ming;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        mr.jun.Arrays arrays = <span class="hljs-keyword">new</span> mr.jun.Arrays();
    &#125;
&#125;</code></pre>
<p>第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p>
<pre><code class="hljs java"><span class="hljs-comment">// Person.java</span>
<span class="hljs-keyword">package</span> ming;

<span class="hljs-comment">// 导入完整类名:</span>
<span class="hljs-keyword">import</span> mr.jun.Arrays;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
        Arrays arrays = <span class="hljs-keyword">new</span> Arrays();
    &#125;
&#125;</code></pre>
<p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）。</p>
<p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p>
<p>第三种<code>import static</code>的语法，它可以导入一个类的静态字段和静态方法：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> main;

<span class="hljs-comment">// 导入System类的所有静态字段和静态方法:</span>
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 相当于调用System.out.println(…)</span>
        out.println(<span class="hljs-string">"Hello, world!"</span>);
    &#125;
&#125;</code></pre>
<p><code>import static</code>很少使用。</p>
<p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>
<li>如果是简单类名，按下面的顺序依次查找：<ul>
<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>
<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>
<li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li>
</ul>
</li>
</ul>
<p>所以编写class的时候，编译器会自动帮我们做两个import动作：</p>
<ul>
<li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li>
<li>默认自动<code>import java.lang.*</code>。</li>
</ul>
<blockquote>
<p> 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</p>
</blockquote>
<p>如果有两个<code>class</code>名称相同，例如，<code>mr.jun.Arrays</code>和<code>java.util.Arrays</code>，那么只能<code>import</code>其中一个，另一个必须写完整类名。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
<ul>
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.liaoxuefeng.sample</li>
</ul>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;
    &#125;
&#125;</code></pre>
<p>上面的<code>Hello</code>是<code>public</code>，因此，可以被其他包的类访问：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> xyz;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// Main可以访问Hello</span>
        Hello h = <span class="hljs-keyword">new</span> Hello();
    &#125;
&#125;</code></pre>
<h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>推荐把<code>private</code>方法放到后面，因为<code>public</code>方法定义了类对外提供的功能，阅读代码的时候，应该先关注<code>public</code>方法：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.hi();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;
    &#125;
&#125;</code></pre>
<p>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Inner i = <span class="hljs-keyword">new</span> Inner();
        i.hi();
    &#125;

    <span class="hljs-comment">// private方法:</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;
        System.out.println(<span class="hljs-string">"private hello!"</span>);
    &#125;

    <span class="hljs-comment">// 静态内部类:</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;
            Main.hello();	<span class="hljs-comment">//输出private hello!</span>
        &#125;
    &#125;
&#125;</code></pre>
<p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类。</p>
<h2 id="protected-1"><a href="#protected-1" class="headerlink" title="protected"></a>protected</h2><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的<em>字段和方法</em>可以被子类访问，以及子类的子类：</p>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。</p>
<h2 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h2><p>用<code>final</code>修饰<code>class</code>可以阻止被继承：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;

<span class="hljs-comment">// 无法被继承:</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>&#123;
        <span class="hljs-keyword">long</span> i = t;
    &#125;
&#125;</code></pre>
<p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;
    <span class="hljs-comment">// 无法被覆写:</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;
    &#125;
&#125;</code></pre>
<p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">this</span>.n = <span class="hljs-number">1</span>; <span class="hljs-comment">// error!</span>
    &#125;
&#125;</code></pre>
<p>用<code>final</code>修饰局部变量可以阻止被重新赋值：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> t)</span> </span>&#123;
        t = <span class="hljs-number">1</span>; <span class="hljs-comment">// error!</span>
    &#125;
&#125;</code></pre>
<h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p>
<p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p>
<p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p>
<h1 id="classpath和jar"><a href="#classpath和jar" class="headerlink" title="classpath和jar"></a>classpath和jar</h1><h2 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h2><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p>
<p>因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件。</p>
<p>所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来，可能长这样：</p>
<pre><code class="hljs shell">C:\work\project1\bin;C:\shared;"D:\My Documents\project1\bin"</code></pre>
<p>在Linux系统上，用<code>:</code>分隔，可能长这样：</p>
<pre><code class="hljs shell">/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</code></pre>
<p>现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p>
<ul>
<li>&lt;当前目录&gt;\abc\xyz\Hello.class</li>
<li>C:\work\project1\bin\abc\xyz\Hello.class</li>
<li>C:\shared\abc\xyz\Hello.class</li>
</ul>
<p>注意到<code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p>
<p><code>classpath</code>的设定方法有两种：</p>
<p>在系统环境变量中设置<code>classpath</code>环境变量，不推荐；</p>
<p>在启动JVM时设置<code>classpath</code>变量，推荐。</p>
<p>我们强烈<em>不推荐</em>在系统环境变量中设置<code>classpath</code>，那样会污染整个系统环境。在启动JVM时设置<code>classpath</code>才是推荐的做法。实际上就是给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数：</p>
<pre><code class="hljs shell">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</code></pre>
<p>或者使用<code>-cp</code>的简写：</p>
<pre><code class="hljs shell">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</code></pre>
<p>没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即当前目录：</p>
<pre><code class="hljs shell">java abc.xyz.Hello</code></pre>
<p>上述命令告诉JVM只在当前目录搜索<code>Hello.class</code>。</p>
<p>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包。</p>
<p>通常，我们在自己编写的<code>class</code>中，会引用Java核心库的<code>class</code>，例如，<code>String</code>、<code>ArrayList</code>等。这些<code>class</code>应该上哪去找？</p>
<p>有很多“如何设置classpath”的文章会告诉你把JVM自带的<code>rt.jar</code>放入<code>classpath</code>，但事实上，根本不需要告诉JVM如何去Java核心库查找<code>class</code>，JVM怎么可能笨到连自己的核心库在哪都不知道？</p>
<blockquote>
<p>不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！</p>
</blockquote>
<p>更好的做法是，不要设置<code>classpath</code>！默认的当前目录<code>.</code>对于绝大多数情况都够用了。</p>
<h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><p>jar包可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件。</p>
<p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath中：</p>
<pre><code class="hljs shell">java -cp ./hello.jar abc.xyz.Hello</code></pre>
<p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p>
<h3 id="创建jar包"><a href="#创建jar包" class="headerlink" title="创建jar包"></a>创建jar包</h3><p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</p>
<p>假设编译输出的目录结构是这样：</p>
<pre><code class="hljs ascii">package_sample
└─ bin
   ├─ hong
   │  └─ Person.class
   │  ming
   │  └─ Person.class
   └─ mr
      └─ jun
         └─ Arrays.class</code></pre>
<p>这里需要特别注意的是，jar包里的第一层目录，不能是<code>bin</code>，而应该是<code>hong</code>、<code>ming</code>、<code>mr</code>。</p>
<p>如果jar包里的第一层目录是bin，JVM仍然无法从jar包中查找正确的<code>class</code>，原因是<code>hong.Person</code>必须按<code>hong/Person.class</code>存放，而不是<code>bin/hong/Person.class</code>。</p>
<p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p>
<pre><code class="hljs shell">java -jar hello.jar</code></pre>
<p>jar包还可以包含其它jar包，这个时候，就需要在<code>MANIFEST.MF</code>文件里配置<code>classpath</code>了。</p>
<p>在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200" target="_blank" rel="noopener">Maven</a>，可以非常方便地创建jar包。</p>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>从Java 9开始，JDK又引入了模块（Module）。</p>
<p>我们知道，<code>.class</code>文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆<code>.class</code>文件，很不便于管理，所以，<code>jar</code>文件就是<code>class</code>文件的容器。</p>
<p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M。</p>
<p>如果是自己开发的程序，除了一个自己的<code>app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p>
<pre><code class="hljs bash">java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</code></pre>
<blockquote>
<p>JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。</p>
</blockquote>
<p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p>
<p>为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p>
<ul>
<li>java.base.jmod</li>
<li>java.compiler.jmod</li>
<li>java.datatransfer.jmod</li>
<li>java.desktop.jmod</li>
<li>…</li>
</ul>
<p>这些<code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。所有的模块都直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code>Object</code>直接或间接继承而来。</p>
<p>把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p>
<h2 id="编写模块"><a href="#编写模块" class="headerlink" title="编写模块"></a>编写模块</h2><p>首先，创建模块和原有的创建Java项目是完全一样的，以<code>oop-module</code>工程为例，它的目录结构如下：</p>
<pre><code class="hljs ascii">oop-module
├── bin
├── build.sh
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java</code></pre>
<p>其中，<code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p>
<pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.world &#123;
	<span class="hljs-keyword">requires</span> java.base; <span class="hljs-comment">// 可不写，任何模块都会自动引入java.base</span>
	<span class="hljs-keyword">requires</span> java.xml;
&#125;</code></pre>
<p>其中，<code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块。</p>
<p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，<code>Main.java</code>代码如下：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itranswarp.sample;

<span class="hljs-comment">// 必须引入java.xml模块后才能使用其中的类:</span>
<span class="hljs-keyword">import</span> javax.xml.XMLConstants;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		Greeting g = <span class="hljs-keyword">new</span> Greeting();
		System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));
	&#125;
&#125;</code></pre>
<p>如果把<code>requires java.xml;</code>从<code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。</p>
<p>下面，我们用JDK提供的命令行工具来编译并创建模块。</p>
<p>首先，我们把工作目录切换到<code>oop-module</code>，在当前目录下编译所有的<code>.java</code>文件，并存放到<code>bin</code>目录下，命令如下：</p>
<pre><code class="hljs bash">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</code></pre>
<p>如果编译成功，现在项目结构如下：</p>
<pre><code class="hljs ascii">oop-module
├── bin
│   ├── com
│   │   └── itranswarp
│   │       └── sample
│   │           ├── Greeting.class
│   │           └── Main.class
│   └── module-info.class
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java</code></pre>
<p>下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p>
<pre><code class="hljs bash">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</code></pre>
<p>现在我们就在当前目录下得到了<code>hello.jar</code>这个jar包，它和普通jar包并无区别，可以直接使用命令<code>java -jar hello.jar</code>来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p>
<pre><code class="hljs bash">$ jmod create --class-path hello.jar hello.jmod</code></pre>
<p>于是，在当前目录下我们又得到了<code>hello.jmod</code>这个模块文件。</p>
<h2 id="运行模块"><a href="#运行模块" class="headerlink" title="运行模块"></a>运行模块</h2><p>要运行一个jar，我们使用<code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要指定模块名。</p>
<pre><code class="hljs bash">$ java --module-path hello.jar --module hello.world</code></pre>
<p>那我们辛辛苦苦创建的<code>hello.jmod</code>有什么用？答案是我们可以用它来打包JRE。</p>
<h2 id="打包JRE"><a href="#打包JRE" class="headerlink" title="打包JRE"></a>打包JRE</h2><p>前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的<code>rt.jar</code>拆成了几十个<code>.jmod</code>模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。</p>
<p>过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p>
<p>现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了<code>jlink</code>命令来干这件事。命令如下：</p>
<pre><code class="hljs bash">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</code></pre>
<p>我们在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录。</p>
<p>现在，在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p>
<pre><code class="hljs bash">$ jre/bin/java --module hello.world</code></pre>
<p>要分发我们自己的Java应用程序，只需要把这个<code>jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p>
<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</p>
<p>确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p>
<p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：</p>
<pre><code class="hljs java"><span class="hljs-keyword">module</span> java.xml &#123;
    <span class="hljs-keyword">exports</span> java.xml;
    <span class="hljs-keyword">exports</span> javax.xml.catalog;
    <span class="hljs-keyword">exports</span> javax.xml.datatype;
    ...
&#125;</code></pre>
<p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p>
<pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.world &#123;
    <span class="hljs-keyword">exports</span> com.itranswarp.sample;
  
    <span class="hljs-keyword">requires</span> java.base;
	<span class="hljs-keyword">requires</span> java.xml;
&#125;</code></pre>
<p>因此，模块进一步隔离了代码的访问权限。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/06/14/Java%E6%A0%B8%E5%BF%83%E7%B1%BB/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java学习笔记（三）Java核心类</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/06/14/Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">
                        <span class="hidden-mobile">Java学习笔记（一）Java快速入门</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Java学习笔记（二）面向对象编程&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  













  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?a5dc56eafecca743bd237bbc54f64e67";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
