<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java学习笔记（四）异常处理</title>
    <link href="/2020/06/14/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2020/06/14/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Java的异常"><a href="#Java的异常" class="headerlink" title="Java的异常"></a>Java的异常</h1><p>一个健壮的程序必须处理各种各样的错误。</p><p>所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。</p><p>调用方如何获知调用失败的信息？有两种方法：</p><p>方法一：约定返回错误码。</p><p>例如，处理一个文件，如果返回<code>0</code>，表示成功，返回其他整数，表示约定的错误码：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> code = processFile(<span class="hljs-string">"C:\\test.txt"</span>);<span class="hljs-keyword">if</span> (code == <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// ok:</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// error:</span>    <span class="hljs-keyword">switch</span> (code) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:        <span class="hljs-comment">// file not found:</span>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:        <span class="hljs-comment">// no read permission:</span>    <span class="hljs-keyword">default</span>:        <span class="hljs-comment">// unknown error:</span>    &#125;&#125;</code></pre><p>因为使用<code>int</code>类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</p><p>方法二：在语言层面上提供一个异常处理机制。</p><p>Java内置了一套异常处理机制，总是使用异常来表示错误。</p><p>异常是一种<code>class</code>，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    String s = processFile(“C:\\test.txt”);    <span class="hljs-comment">// ok:</span>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;    <span class="hljs-comment">// file not found:</span>&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;    <span class="hljs-comment">// no read permission:</span>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;    <span class="hljs-comment">// io error:</span>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    <span class="hljs-comment">// other error:</span>&#125;</code></pre><p>因为Java的异常是<code>class</code>，它的继承关系如下：</p><pre><code class="hljs ascii">                     ┌───────────┐                     │  Object   │                     └───────────┘                           ▲                           │                     ┌───────────┐                     │ Throwable │                     └───────────┘                           ▲                 ┌─────────┴─────────┐                 │                   │           ┌───────────┐       ┌───────────┐           │   Error   │       │ Exception │           └───────────┘       └───────────┘                 ▲                   ▲         ┌───────┘              ┌────┴──────────┐         │                      │               │┌─────────────────┐    ┌─────────────────┐┌───────────┐│OutOfMemoryError │... │RuntimeException ││IOException│...└─────────────────┘    └─────────────────┘└───────────┘                                ▲                    ┌───────────┴─────────────┐                    │                         │         ┌─────────────────────┐ ┌─────────────────────────┐         │NullPointerException │ │IllegalArgumentException │...         └─────────────────────┘ └─────────────────────────┘</code></pre><p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p><ul><li><code>OutOfMemoryError</code>：内存耗尽</li><li><code>NoClassDefFoundError</code>：无法加载某个Class</li><li><code>StackOverflowError</code>：栈溢出</li></ul><p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p><p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p><ul><li><code>NumberFormatException</code>：数值类型的格式错误</li><li><code>FileNotFoundException</code>：未找到文件</li><li><code>SocketException</code>：读取网络失败</li></ul><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p><ul><li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li><li><code>IndexOutOfBoundsException</code>：数组索引越界</li></ul><p><code>Exception</code>又分为两大类：</p><ol><li><code>RuntimeException</code>以及它的子类；</li><li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li></ol><p>Java规定：</p><ul><li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li><li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li></ul><h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><p>捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try {...}</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">byte</span>[] bs = toGBK(<span class="hljs-string">"中文"</span>);        System.out.println(Arrays.toString(bs));    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] toGBK(String s) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 用指定编码转换String为byte[]:</span>            <span class="hljs-keyword">return</span> s.getBytes(<span class="hljs-string">"GBK"</span>);        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;            <span class="hljs-comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span>            System.out.println(e); <span class="hljs-comment">// 打印异常信息</span>            <span class="hljs-keyword">return</span> s.getBytes(); <span class="hljs-comment">// 尝试使用用默认编码</span>        &#125;    &#125;&#125;</code></pre><p>如果我们不捕获<code>UnsupportedEncodingException</code>，会出现编译失败的问题：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">byte</span>[] bs = toGBK(<span class="hljs-string">"中文"</span>);        System.out.println(Arrays.toString(bs));    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] toGBK(String s) &#123;        <span class="hljs-keyword">return</span> s.getBytes(<span class="hljs-string">"GBK"</span>);    &#125;&#125;</code></pre><p>编译器会报错，错误信息类似：unreported exception UnsupportedEncodingException; must be caught or declared to be thrown，并且准确地指出需要捕获的语句是<code>return s.getBytes(&quot;GBK&quot;);</code>。意思是说，像<code>UnsupportedEncodingException</code>这样的Checked Exception，必须被捕获。</p><p>这是因为<code>String.getBytes(String)</code>方法定义是：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getBytes(String charsetName) <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;    ...&#125;</code></pre><p>在方法定义的时候，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p><p>在<code>toGBK()</code>方法中，因为调用了<code>String.getBytes(String)</code>方法，就必须捕获<code>UnsupportedEncodingException</code>。我们也可以不捕获它，而是在方法定义处用throws表示<code>toGBK()</code>方法可能会抛出<code>UnsupportedEncodingException</code>，就可以让<code>toGBK()</code>方法通过编译器检查：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">byte</span>[] bs = toGBK(<span class="hljs-string">"中文"</span>);        System.out.println(Arrays.toString(bs));    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] toGBK(String s) <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;        <span class="hljs-keyword">return</span> s.getBytes(<span class="hljs-string">"GBK"</span>);    &#125;&#125;</code></pre><p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用<code>return s.getBytes(&quot;GBK&quot;);</code>的问题，而是<code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在<code>main()</code>方法中，调用<code>toGBK()</code>，没有捕获它声明的可能抛出的<code>UnsupportedEncodingException</code>。</p><p>修复方法是在<code>main()</code>方法中捕获异常并处理：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">byte</span>[] bs = toGBK(<span class="hljs-string">"中文"</span>);            System.out.println(Arrays.toString(bs));        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;            System.out.println(e);        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] toGBK(String s) <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;        <span class="hljs-comment">// 用指定编码转换String为byte[]:</span>        <span class="hljs-keyword">return</span> s.getBytes(<span class="hljs-string">"GBK"</span>);    &#125;&#125;</code></pre><p>可见，只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在<code>main()</code>方法中捕获，不会出现漏写<code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获<code>Exception</code>的机会。</p><p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>：</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<span class="hljs-keyword">import</span> java.util.Arrays;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) throws Exception &#123;        byte[] bs = toGBK(<span class="hljs-string">"中文"</span>);        System.out.println(Arrays.toString(bs));    &#125;    <span class="hljs-keyword">static</span> byte[] toGBK(<span class="hljs-built_in">String</span> s) throws UnsupportedEncodingException &#123;        <span class="hljs-comment">// 用指定编码转换String为byte[]:</span>        <span class="hljs-keyword">return</span> s.getBytes(<span class="hljs-string">"GBK"</span>);    &#125;&#125;</code></pre><p>因为<code>main()</code>方法声明了可能抛出<code>Exception</code>，也就声明了可能抛出所有的<code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p><p>还有一些童鞋喜欢在<code>toGBK()</code>内部“消化”异常：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] toGBK(String s) &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> s.getBytes(<span class="hljs-string">"GBK"</span>);    &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;        <span class="hljs-comment">// 什么也不干</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</code></pre><p>这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] toGBK(String s) &#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> s.getBytes(<span class="hljs-string">"GBK"</span>);    &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;        <span class="hljs-comment">// 先记下来再说:</span>        e.printStackTrace();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</code></pre><p>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p><h1 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h1><h2 id="多catch语句"><a href="#多catch语句" class="headerlink" title="多catch语句"></a>多catch语句</h2><p>可以使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后<em>不再</em>继续匹配。</p><p>简单地说就是：多个<code>catch</code>语句只有一个能被执行。例如：</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记（三）Java核心类</title>
    <link href="/2020/06/14/Java%E6%A0%B8%E5%BF%83%E7%B1%BB/"/>
    <url>/2020/06/14/Java%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串与编码"><a href="#字符串与编码" class="headerlink" title="字符串与编码"></a>字符串与编码</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>在Java中，<code>String</code>是一个引用类型，它本身也是一个<code>class</code>。</p><pre><code class="hljs java">String s1 = <span class="hljs-string">"Hello!"</span>;</code></pre><p>实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p><pre><code class="hljs java">String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] &#123;<span class="hljs-string">'H'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'!'</span>&#125;);</code></pre><p>Java字符串的一个重要特点就是字符串<em>不可变</em>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String s = <span class="hljs-string">"Hello"</span>;        System.out.println(s);<span class="hljs-comment">//输出Hello</span>        s = s.toUpperCase();        System.out.println(s);<span class="hljs-comment">//输出HELLO</span>    &#125;&#125;</code></pre><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用<code>equals()</code>方法而不能用<code>==</code>。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String s1 = <span class="hljs-string">"hello"</span>;        String s2 = <span class="hljs-string">"hello"</span>;        System.out.println(s1 == s2);<span class="hljs-comment">//输出true</span>        System.out.println(s1.equals(s2));<span class="hljs-comment">//输出true</span>    &#125;&#125;</code></pre><p>从表面上看，两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然<code>s1</code>和<code>s2</code>的引用就是相同的。</p><p>所以，这种<code>==</code>比较返回<code>true</code>纯属巧合。换一种写法，<code>==</code>比较就会失败：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String s1 = <span class="hljs-string">"hello"</span>;        String s2 = <span class="hljs-string">"HELLO"</span>.toLowerCase();        System.out.println(s1 == s2);<span class="hljs-comment">//输出false</span>        System.out.println(s1.equals(s2));<span class="hljs-comment">//输出true</span>    &#125;&#125;</code></pre><p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p><p><code>String</code>类还提供了多种方法来搜索子串、提取子串。常用的方法有：</p><pre><code class="hljs java"><span class="hljs-comment">// 是否包含子串:</span><span class="hljs-string">"Hello"</span>.contains(<span class="hljs-string">"ll"</span>); <span class="hljs-comment">// true</span></code></pre><p>注意到<code>contains()</code>方法的参数是<code>CharSequence</code>而不是<code>String</code>，因为<code>CharSequence</code>是<code>String</code>的父类。</p><p>搜索子串的更多的例子：</p><pre><code class="hljs java"><span class="hljs-string">"Hello"</span>.indexOf(<span class="hljs-string">"l"</span>); <span class="hljs-comment">// 2</span><span class="hljs-string">"Hello"</span>.lastIndexOf(<span class="hljs-string">"l"</span>); <span class="hljs-comment">// 3</span><span class="hljs-string">"Hello"</span>.startsWith(<span class="hljs-string">"He"</span>); <span class="hljs-comment">// true</span><span class="hljs-string">"Hello"</span>.endsWith(<span class="hljs-string">"lo"</span>); <span class="hljs-comment">// true</span></code></pre><p>提取子串的例子：</p><pre><code class="hljs java"><span class="hljs-string">"Hello"</span>.substring(<span class="hljs-number">2</span>); <span class="hljs-comment">// "llo"</span><span class="hljs-string">"Hello"</span>.substring(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <span class="hljs-string">"ll"</span></code></pre><h3 id="去除首尾空白字符"><a href="#去除首尾空白字符" class="headerlink" title="去除首尾空白字符"></a>去除首尾空白字符</h3><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>：</p><pre><code class="hljs java"><span class="hljs-string">"  \tHello\r\n "</span>.trim(); <span class="hljs-comment">// "Hello"</span></code></pre><blockquote><p><code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p></blockquote><p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除：</p><pre><code class="hljs java"><span class="hljs-string">"\u3000Hello\u3000"</span>.strip(); <span class="hljs-comment">// "Hello"</span><span class="hljs-string">" Hello "</span>.stripLeading(); <span class="hljs-comment">// "Hello "</span><span class="hljs-string">" Hello "</span>.stripTrailing(); <span class="hljs-comment">// " Hello"</span></code></pre><p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串：</p><pre><code class="hljs java"><span class="hljs-string">""</span>.isEmpty(); <span class="hljs-comment">// true，因为字符串长度为0</span><span class="hljs-string">"  "</span>.isEmpty(); <span class="hljs-comment">// false，因为字符串长度不为0</span><span class="hljs-string">"  \n"</span>.isBlank(); <span class="hljs-comment">// true，因为只包含空白字符</span><span class="hljs-string">" Hello "</span>.isBlank(); <span class="hljs-comment">// false，因为包含非空白字符</span></code></pre><h3 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h3><p>要在字符串中替换子串，有两种方法。</p><p>一种是根据字符或字符串替换：</p><pre><code class="hljs java">String s = <span class="hljs-string">"hello"</span>;s.replace(<span class="hljs-string">'l'</span>, <span class="hljs-string">'w'</span>); <span class="hljs-comment">// "hewwo"，所有字符'l'被替换为'w'</span>s.replace(<span class="hljs-string">"ll"</span>, <span class="hljs-string">"~~"</span>); <span class="hljs-comment">// "he~~o"，所有子串"ll"被替换为"~~"</span></code></pre><p>另一种是通过正则表达式替换：</p><pre><code class="hljs java">String s = <span class="hljs-string">"A,,B;C ,D"</span>;s.replaceAll(<span class="hljs-string">"[\\,\\;\\s]+"</span>, <span class="hljs-string">","</span>); <span class="hljs-comment">// "A,B,C,D"</span></code></pre><p>上面的代码通过正则表达式，把匹配的子串统一替换为<code>&quot;,&quot;</code>。</p><h2 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h2><p>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</p><pre><code class="hljs java">String s = <span class="hljs-string">"A,B,C,D"</span>;String[] ss = s.split(<span class="hljs-string">"\\,"</span>); <span class="hljs-comment">// &#123;"A", "B", "C", "D"&#125;</span></code></pre><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</p><pre><code class="hljs java">String[] arr = &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>&#125;;String s = String.join(<span class="hljs-string">"***"</span>, arr); <span class="hljs-comment">// "A***B***C"</span></code></pre><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>字符串提供了<code>formatted()</code>方法和<code>format()</code><em>静态方法</em>，可以传入其他参数，替换占位符，然后生成新的字符串：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String s = <span class="hljs-string">"Hi %s, your score is %d!"</span>;        System.out.println(s.formatted(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">80</span>));<span class="hljs-comment">//输出Hi Alice, your score is 80!</span>        System.out.println(String.format(<span class="hljs-string">"Hi %s, your score is %.2f!"</span>, <span class="hljs-string">"Bob"</span>, <span class="hljs-number">59.5</span>));<span class="hljs-comment">//输出Hi Bob, your score is 59.59!</span>    &#125;&#125;</code></pre><p>如果你不确定用啥占位符，那就始终用<code>%s</code>，因为<code>%s</code>可以显示任何数据类型。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法：</p><pre><code class="hljs java">String.valueOf(<span class="hljs-number">123</span>); <span class="hljs-comment">// "123"</span>String.valueOf(<span class="hljs-number">45.67</span>); <span class="hljs-comment">// "45.67"</span>String.valueOf(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// "true"</span>String.valueOf(<span class="hljs-keyword">new</span> Object()); <span class="hljs-comment">// 类似java.lang.Object@636be97c</span></code></pre><p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> n1 = Integer.parseInt(<span class="hljs-string">"123"</span>); <span class="hljs-comment">// 123</span><span class="hljs-keyword">int</span> n2 = Integer.parseInt(<span class="hljs-string">"ff"</span>, <span class="hljs-number">16</span>); <span class="hljs-comment">// 按十六进制转换，255</span></code></pre><p>把字符串转换为<code>boolean</code>类型：</p><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> b1 = Boolean.parseBoolean(<span class="hljs-string">"true"</span>); <span class="hljs-comment">// true</span><span class="hljs-keyword">boolean</span> b2 = Boolean.parseBoolean(<span class="hljs-string">"FALSE"</span>); <span class="hljs-comment">// false</span></code></pre><p>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</p><pre><code class="hljs java">Integer.getInteger(<span class="hljs-string">"java.version"</span>); <span class="hljs-comment">// 版本号，11</span></code></pre><h2 id="转换为char"><a href="#转换为char" class="headerlink" title="转换为char[]"></a>转换为char[]</h2><p>String<code>和</code>char[]`类型可以互相转换，方法是：</p><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] cs = <span class="hljs-string">"Hello"</span>.toCharArray(); <span class="hljs-comment">// String -&gt; char[]</span>String s = <span class="hljs-keyword">new</span> String(cs); <span class="hljs-comment">// char[] -&gt; String</span></code></pre><p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变。</p><p>从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] scores = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">88</span>, <span class="hljs-number">77</span>, <span class="hljs-number">51</span>, <span class="hljs-number">66</span> &#125;;        Score s = <span class="hljs-keyword">new</span> Score(scores);        s.printScores();        scores[<span class="hljs-number">2</span>] = <span class="hljs-number">99</span>;        s.printScores();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] scores;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Score</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] scores)</span> </span>&#123;        <span class="hljs-keyword">this</span>.scores = scores;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printScores</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Arrays.toString(scores));    &#125;&#125;</code></pre><p>观察两次输出，由于<code>Score</code>内部直接引用了外部传入的<code>int[]</code>数组，这会造成外部代码对<code>int[]</code>数组的修改，影响到<code>Score</code>类的字段。如果外部代码不可信，这就会造成安全隐患。</p><p>所以在构造函数里面需要复制一份scores再给this.scores赋值。</p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从<code>0</code>到<code>127</code>，最高位始终为<code>0</code>，称为<code>ASCII</code>编码。例如，字符<code>&#39;A&#39;</code>的编码是<code>0x41</code>，字符<code>&#39;1&#39;</code>的编码是<code>0x31</code>。</p><p>如果要把汉字也纳入计算机编码，很显然一个字节是不够的。<code>GB2312</code>标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为<code>1</code>，以便和<code>ASCII</code>编码区分开。例如，汉字<code>&#39;中&#39;</code>的<code>GB2312</code>编码是<code>0xd6d0</code>。</p><p>类似的，日文有<code>Shift_JIS</code>编码，韩文有<code>EUC-KR</code>编码，这些编码因为标准不统一，同时使用，就会产生冲突。</p><p>为了统一全球所有语言的编码，全球统一码联盟发布了<code>Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p><p>那我们经常使用的<code>UTF-8</code>又是什么编码呢？因为英文字符的<code>Unicode</code>编码高字节总是<code>00</code>，包含大量英文的文本会浪费空间，所以，出现了<code>UTF-8</code>编码，它是一种变长编码，用来把固定长度的<code>Unicode</code>编码变成1～4字节的变长编码。通过<code>UTF-8</code>编码，英文字符<code>&#39;A&#39;</code>的<code>UTF-8</code>编码变为<code>0x41</code>，正好和<code>ASCII</code>码一致，而中文<code>&#39;中&#39;</code>的<code>UTF-8</code>编码为3字节<code>0xe4b8ad</code>。</p><p><code>UTF-8</code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为<code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p><p>在Java中，<code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] b1 = <span class="hljs-string">"Hello"</span>.getBytes(); <span class="hljs-comment">// 按系统默认编码转换，不推荐</span><span class="hljs-keyword">byte</span>[] b2 = <span class="hljs-string">"Hello"</span>.getBytes(<span class="hljs-string">"UTF-8"</span>); <span class="hljs-comment">// 按UTF-8编码转换</span><span class="hljs-keyword">byte</span>[] b2 = <span class="hljs-string">"Hello"</span>.getBytes(<span class="hljs-string">"GBK"</span>); <span class="hljs-comment">// 按GBK编码转换</span><span class="hljs-keyword">byte</span>[] b3 = <span class="hljs-string">"Hello"</span>.getBytes(StandardCharsets.UTF_8); <span class="hljs-comment">// 按UTF-8编码转换</span></code></pre><blockquote><p>转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组。</p></blockquote><p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p><pre><code class="hljs java"><span class="hljs-keyword">byte</span>[] b = ...String s1 = <span class="hljs-keyword">new</span> String(b, <span class="hljs-string">"GBK"</span>); <span class="hljs-comment">// 按GBK转换</span>String s2 = <span class="hljs-keyword">new</span> String(b, StandardCharsets.UTF_8); <span class="hljs-comment">// 按UTF-8转换</span></code></pre><p>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><p>对于不同版本的JDK，<code>String</code>类在内存中有不同的优化方式。具体来说，早期JDK版本的<code>String</code>总是以<code>char[]</code>存储，它的定义如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] value;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count;&#125;</code></pre><p>而较新的JDK版本的<code>String</code>则以<code>byte[]</code>存储：如果<code>String</code>仅包含ASCII字符，则每个<code>byte</code>存储一个字符，否则，每两个<code>byte</code>存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的<code>String</code>通常仅包含ASCII字符：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] value;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> coder; <span class="hljs-comment">// 0 = LATIN1, 1 = UTF16</span></code></pre><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>Java编译器对<code>String</code>做了特殊处理，使得我们可以直接用<code>+</code>拼接字符串。</p><p>考察下面的循环代码：</p><pre><code class="hljs java">String s = <span class="hljs-string">""</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;    s = s + <span class="hljs-string">","</span> + i;&#125;</code></pre><p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p><pre><code class="hljs java">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">1024</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;    sb.append(<span class="hljs-string">','</span>);    sb.append(i);&#125;String s = sb.toString();</code></pre><p><code>StringBuilder</code>还可以进行链式操作：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">var</span> sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">1024</span>);        sb.append(<span class="hljs-string">"Mr "</span>)          .append(<span class="hljs-string">"Bob"</span>)          .append(<span class="hljs-string">"!"</span>)          .insert(<span class="hljs-number">0</span>, <span class="hljs-string">"Hello, "</span>);        System.out.println(sb.toString());<span class="hljs-comment">//输出Hello, Mr Bob!</span>    &#125;&#125;</code></pre><p>如果我们查看<code>StringBuilder</code>的源码，可以发现，进行链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法。</p><blockquote><p>对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p></blockquote><p>你可能还听说过<code>StringBuffer</code>，这是Java早期的一个<code>StringBuilder</code>的线程安全版本，它通过同步来保证多个线程操作<code>StringBuffer</code>也是安全的，但是同步会带来执行速度的下降。</p><p><code>StringBuilder</code>和<code>StringBuffer</code>接口完全相同，现在完全没有必要使用<code>StringBuffer</code>。</p><h1 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h1><p>很多时候，我们拼接的字符串像这样：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String[] names = &#123;<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Grace"</span>&#125;;        <span class="hljs-keyword">var</span> sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(<span class="hljs-string">"Hello "</span>);        <span class="hljs-keyword">for</span> (String name : names) &#123;            sb.append(name).append(<span class="hljs-string">", "</span>);        &#125;        <span class="hljs-comment">// 注意去掉最后的", ":</span>        sb.delete(sb.length() - <span class="hljs-number">2</span>, sb.length());        sb.append(<span class="hljs-string">"!"</span>);        System.out.println(sb.toString());    &#125;&#125;</code></pre><p>类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个<code>StringJoiner</code>来干这个事：</p><pre><code class="hljs java">ppublic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String[] names = &#123;<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Grace"</span>&#125;;        <span class="hljs-keyword">var</span> sj = <span class="hljs-keyword">new</span> StringJoiner(<span class="hljs-string">", "</span>, <span class="hljs-string">"Hello "</span>, <span class="hljs-string">"!"</span>);        <span class="hljs-keyword">for</span> (String name : names) &#123;            sj.add(name);        &#125;        System.out.println(sj.toString());<span class="hljs-comment">//输出Hello Bob, Alice, Grace!</span>    &#125;&#125;</code></pre><p>那么<code>StringJoiner</code>内部是如何拼接字符串的呢？如果查看源码，可以发现，<code>StringJoiner</code>内部实际上就是使用了<code>StringBuilder</code>，所以拼接效率和<code>StringBuilder</code>几乎是一模一样的。</p><h2 id="String-join"><a href="#String-join" class="headerlink" title="String.join()"></a>String.join()</h2><p><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p><pre><code class="hljs java">String[] names = &#123;<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Grace"</span>&#125;;<span class="hljs-keyword">var</span> s = String.join(<span class="hljs-string">", "</span>, names);</code></pre><h1 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h1><p>Java的数据类型分两种：</p><ul><li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></li><li>引用类型：所有<code>class</code>和<code>interface</code>类型</li></ul><p>引用类型可以赋值为<code>null</code>，表示空，但基本类型不能赋值为<code>null</code>。</p><p>那么，如何把一个基本类型视为对象（引用类型）？</p><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><div class="table-container"><table><thead><tr><th style="text-align:left">基本类型</th><th style="text-align:left">对应的引用类型</th></tr></thead><tbody><tr><td style="text-align:left">boolean</td><td style="text-align:left">java.lang.Boolean</td></tr><tr><td style="text-align:left">byte</td><td style="text-align:left">java.lang.Byte</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">java.lang.Short</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">java.lang.Integer</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">java.lang.Long</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">java.lang.Float</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">java.lang.Double</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">java.lang.Character</td></tr></tbody></table></div><p>我们可以直接使用，并不需要自己去定义：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>;        <span class="hljs-comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span>        Integer n1 = <span class="hljs-keyword">new</span> Integer(i);        <span class="hljs-comment">// 通过静态方法valueOf(int)创建Integer实例:</span>        Integer n2 = Integer.valueOf(i);        <span class="hljs-comment">// 通过静态方法valueOf(String)创建Integer实例:</span>        Integer n3 = Integer.valueOf(<span class="hljs-string">"100"</span>);        System.out.println(n3.intValue());    &#125;&#125;</code></pre><h2 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h2><p>Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p><pre><code class="hljs java">Integer n = <span class="hljs-number">100</span>; <span class="hljs-comment">// 编译器自动使用Integer.valueOf(int)</span><span class="hljs-keyword">int</span> x = n; <span class="hljs-comment">// 编译器自动使用Integer.intValue()</span></code></pre><p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</p><p>装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code>。</p><h2 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h2><p>所有的包装类型都是不变类。我们查看<code>Integer</code>的源码可知，它的核心代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Integer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;&#125;</code></pre><p>因此，一旦创建了<code>Integer</code>对象，该对象就是不变的。</p><p>对两个<code>Integer</code>实例进行比较要特别注意：绝对不能用<code>==</code>比较，因为<code>Integer</code>是引用类型，必须使用<code>equals()</code>比较。</p><p>因为<code>Integer.valueOf()</code>可能始终返回同一个<code>Integer</code>实例，因此，在我们自己创建<code>Integer</code>的时候，以下两种方法：</p><ul><li>方法1：<code>Integer n = new Integer(100);</code></li><li>方法2：<code>Integer n = Integer.valueOf(100);</code></li></ul><p>方法2更好，因为方法1总是创建新的<code>Integer</code>实例，方法2把内部优化留给<code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为静态工厂方法。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p><blockquote><p> 创建新对象时，优先选用静态工厂方法而不是new操作符。</p></blockquote><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> x1 = Integer.parseInt(<span class="hljs-string">"100"</span>); <span class="hljs-comment">// 100</span><span class="hljs-keyword">int</span> x2 = Integer.parseInt(<span class="hljs-string">"100"</span>, <span class="hljs-number">16</span>); <span class="hljs-comment">// 256,因为按16进制解析</span></code></pre><p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(Integer.toString(<span class="hljs-number">100</span>)); <span class="hljs-comment">// "100",表示为10进制</span>        System.out.println(Integer.toString(<span class="hljs-number">100</span>, <span class="hljs-number">36</span>)); <span class="hljs-comment">// "2s",表示为36进制</span>        System.out.println(Integer.toHexString(<span class="hljs-number">100</span>)); <span class="hljs-comment">// "64",表示为16进制</span>        System.out.println(Integer.toOctalString(<span class="hljs-number">100</span>)); <span class="hljs-comment">// "144",表示为8进制</span>        System.out.println(Integer.toBinaryString(<span class="hljs-number">100</span>)); <span class="hljs-comment">// "1100100",表示为2进制</span>    &#125;&#125;</code></pre><p>Java的包装类型还定义了一些有用的静态变量</p><pre><code class="hljs java"><span class="hljs-comment">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span>Boolean t = Boolean.TRUE;Boolean f = Boolean.FALSE;<span class="hljs-comment">// int可表示的最大/最小值:</span><span class="hljs-keyword">int</span> max = Integer.MAX_VALUE; <span class="hljs-comment">// 2147483647</span><span class="hljs-keyword">int</span> min = Integer.MIN_VALUE; <span class="hljs-comment">// -2147483648</span><span class="hljs-comment">// long类型占用的bit和byte数量:</span><span class="hljs-keyword">int</span> sizeOfLong = Long.SIZE; <span class="hljs-comment">// 64 (bits)</span><span class="hljs-keyword">int</span> bytesOfLong = Long.BYTES; <span class="hljs-comment">// 8 (bytes)</span></code></pre><p>最后，所有的整数和浮点数的包装类型都继承自<code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p><pre><code class="hljs java"><span class="hljs-comment">// 向上转型为Number:</span>Number num = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">999</span>);<span class="hljs-comment">// 获取byte, int, long, float, double:</span><span class="hljs-keyword">byte</span> b = num.byteValue();<span class="hljs-keyword">int</span> n = num.intValue();<span class="hljs-keyword">long</span> ln = num.longValue();<span class="hljs-keyword">float</span> f = num.floatValue();<span class="hljs-keyword">double</span> d = num.doubleValue();</code></pre><h2 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h2><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。<code>byte</code>、<code>short</code>、<code>int</code>和<code>long</code>都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p><p>例如，byte是有符号整型，范围是$-128～+127$，但如果把<code>byte</code>看作无符号整型，它的范围就是<code>0</code>~<code>255</code>。我们把一个负的<code>byte</code>按无符号整型转换为<code>int</code>：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">byte</span> x = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">byte</span> y = <span class="hljs-number">127</span>;        System.out.println(Byte.toUnsignedInt(x)); <span class="hljs-comment">// 255</span>        System.out.println(Byte.toUnsignedInt(y)); <span class="hljs-comment">// 127</span>    &#125;&#125;</code></pre><h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p><ul><li>若干<code>private</code>实例字段；</li><li>通过<code>public</code>方法来读写实例字段。</li></ul><p>如果读写方法符合以下这种命名规范：</p><pre><code class="hljs java"><span class="hljs-comment">// 读方法:</span><span class="hljs-function"><span class="hljs-keyword">public</span> Type <span class="hljs-title">getXyz</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-comment">// 写方法:</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setXyz</span><span class="hljs-params">(Type value)</span></span></code></pre><p>那么这种<code>class</code>被称为<code>JavaBean</code>。</p><p>上面的字段是<code>xyz</code>，那么读写方法名分别以<code>get</code>和<code>set</code>开头，并且后接大写字母开头的字段名<code>Xyz</code>，因此两个读写方法名分别是<code>getXyz()</code>和<code>setXyz()</code>。</p><p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>。</p><p>我们通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。</p><p>只有<code>getter</code>的属性称为只读属性（read-only）。类似的，只有<code>setter</code>的属性称为只写属性（write-only）。</p><p>属性只需要定义<code>getter</code>和<code>setter</code>方法，不一定需要对应的字段。例如，<code>child</code>只读属性定义如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123; <span class="hljs-keyword">this</span>.name = name; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123; <span class="hljs-keyword">this</span>.age = age; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isChild</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age &lt;= <span class="hljs-number">6</span>;    &#125;&#125;</code></pre><p>可以看出，<code>getter</code>和<code>setter</code>也是一种数据封装的方法。</p><h2 id="JavaBean的作用"><a href="#JavaBean的作用" class="headerlink" title="JavaBean的作用"></a>JavaBean的作用</h2><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p><p>通过IDE，可以快速生成<code>getter</code>和<code>setter</code>。例如，在Eclipse中，先输入以下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;&#125;</code></pre><p>然后，点击右键，在弹出的菜单中选择“Source”，“Generate Getters and Setters”，在弹出的对话框中选中需要生成<code>getter</code>和<code>setter</code>方法的字段，点击确定即可由IDE自动完成所有方法代码。</p><h2 id="枚举JavaBean属性"><a href="#枚举JavaBean属性" class="headerlink" title="枚举JavaBean属性"></a>枚举JavaBean属性</h2><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code>：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BeanInfo info = Introspector.getBeanInfo(Person<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;            System.out.println(pd.getName());            System.out.println(<span class="hljs-string">"  "</span> + pd.getReadMethod());            System.out.println(<span class="hljs-string">"  "</span> + pd.getWriteMethod());        &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs reasonml">age   public <span class="hljs-built_in">int</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>get<span class="hljs-constructor">Age()</span>   public void <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>set<span class="hljs-constructor">Age(<span class="hljs-params">int</span>)</span> <span class="hljs-keyword">class</span>   public final native java.lang.Class java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">Class()</span>   null name   public java.lang.String <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>get<span class="hljs-constructor">Name()</span>   public void <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>set<span class="hljs-constructor">Name(<span class="hljs-params">java</span>.<span class="hljs-params">lang</span>.String)</span></code></pre><h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Weekday day = Weekday.SUN;        <span class="hljs-keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;            System.out.println(<span class="hljs-string">"Work at home!"</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">"Work at office!"</span>);        &#125;    &#125;&#125;<span class="hljs-keyword">enum</span> Weekday &#123;    SUN, MON, TUE, WED, THU, FRI, SAT;&#125;</code></pre><p>注意到定义枚举类是通过关键字<code>enum</code>实现的，我们只需依次列出枚举的常量名。</p><h2 id="enum的比较"><a href="#enum的比较" class="headerlink" title="enum的比较"></a>enum的比较</h2><p>使用<code>enum</code>定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用<code>equals()</code>方法，如果使用<code>==</code>比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用<code>equals()</code>方法，但<code>enum</code>类型可以例外。</p><p>这是因为<code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较。</p><h2 id="enum类型"><a href="#enum类型" class="headerlink" title="enum类型"></a>enum类型</h2><p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>有什么区别？</p><p>答案是没有任何区别。<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p><ul><li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li></ul><p>例如，我们定义的<code>Color</code>枚举类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Color &#123;    RED, GREEN, BLUE;&#125;</code></pre><p>编译器编译出的<code>class</code>大概就像这样：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span> </span>&#123; <span class="hljs-comment">// 继承自Enum，标记为final class</span>    <span class="hljs-comment">// 每个实例均为全局唯一:</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Color RED = <span class="hljs-keyword">new</span> Color();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Color GREEN = <span class="hljs-keyword">new</span> Color();    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Color BLUE = <span class="hljs-keyword">new</span> Color();    <span class="hljs-comment">// private构造方法，确保外部无法调用new操作符:</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Color</span><span class="hljs-params">()</span> </span>&#123;&#125;&#125;</code></pre><p>因为<code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例，因此，这些实例有一些方法：</p><p>name()</p><p>返回常量名，例如：</p><pre><code class="hljs java">String s = Weekday.SUN.name(); <span class="hljs-comment">// "SUN"</span></code></pre><p>ordinal()</p><p>返回定义的常量的顺序，从0开始计数，例如：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = Weekday.MON.ordinal(); <span class="hljs-comment">// 1</span></code></pre><p>有些童鞋会想，<code>Weekday</code>的枚举常量如果要和<code>int</code>转换，使用<code>ordinal()</code>不是非常方便？比如这样写：</p><pre><code class="hljs java">String task = Weekday.MON.ordinal() + <span class="hljs-string">"/ppt"</span>;saveToFile(task);</code></pre><p>但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠<code>ordinal()</code>的返回值。因为<code>enum</code>本身是<code>class</code>，所以我们可以定义<code>private</code>的构造方法，并且，给每个枚举常量添加字段：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Weekday day = Weekday.SUN;        <span class="hljs-keyword">if</span> (day.dayValue == <span class="hljs-number">6</span> || day.dayValue == <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">"Work at home!"</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(<span class="hljs-string">"Work at office!"</span>);        &#125;    &#125;&#125;<span class="hljs-keyword">enum</span> Weekday &#123;    MON(<span class="hljs-number">1</span>), TUE(<span class="hljs-number">2</span>), WED(<span class="hljs-number">3</span>), THU(<span class="hljs-number">4</span>), FRI(<span class="hljs-number">5</span>), SAT(<span class="hljs-number">6</span>), SUN(<span class="hljs-number">0</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dayValue;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Weekday</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dayValue)</span> </span>&#123;        <span class="hljs-keyword">this</span>.dayValue = dayValue;    &#125;&#125;</code></pre><blockquote><p> 注意：枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！</p></blockquote><p>默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而<code>name()</code>则不行。</p><blockquote><p> 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！</p></blockquote><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>最后，枚举类可以应用在<code>switch</code>语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比<code>int</code>、<code>String</code>类型更适合用在<code>switch</code>语句中：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Weekday day = Weekday.SUN;        <span class="hljs-keyword">switch</span>(day) &#123;        <span class="hljs-keyword">case</span> MON:        <span class="hljs-keyword">case</span> TUE:        <span class="hljs-keyword">case</span> WED:        <span class="hljs-keyword">case</span> THU:        <span class="hljs-keyword">case</span> FRI:            System.out.println(<span class="hljs-string">"Today is "</span> + day + <span class="hljs-string">". Work at office!"</span>);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> SAT:        <span class="hljs-keyword">case</span> SUN:            System.out.println(<span class="hljs-string">"Today is "</span> + day + <span class="hljs-string">". Work at home!"</span>);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"cannot process "</span> + day);        &#125;    &#125;&#125;<span class="hljs-keyword">enum</span> Weekday &#123;    MON, TUE, WED, THU, FRI, SAT, SUN;&#125;</code></pre><p>加上<code>default</code>语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。</p><h1 id="记录类"><a href="#记录类" class="headerlink" title="记录类"></a>记录类</h1><h2 id="不变类-1"><a href="#不变类-1" class="headerlink" title="不变类"></a>不变类</h2><p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p><ol><li>定义class时使用<code>final</code>，无法派生子类；</li><li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li></ol><p>假设我们希望定义一个<code>Point</code>类，有<code>x</code>、<code>y</code>两个变量，同时它是一个不变类，可以这么写：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> y;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">x</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">y</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.y;    &#125;&#125;</code></pre><p>为了保证不变类的比较，还需要正确覆写<code>equals()</code>和<code>hashCode()</code>方法，这样才能在集合类中正常使用。</p><h2 id="record"><a href="#record" class="headerlink" title="record"></a>record</h2><p>从Java 14开始，引入了新的<code>Record</code>类。我们定义<code>Record</code>类时，使用关键字<code>record</code>。把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Point p = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);        System.out.println(p.x());<span class="hljs-comment">//输出123</span>        System.out.println(p.y());<span class="hljs-comment">//输出456</span>        System.out.println(p);<span class="hljs-comment">//输出Point[x=123, y=456]</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;&#125;</code></pre><p>把上述定义改写为class，相当于以下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> y;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">x</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">y</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.y;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"Point[x=%s, y=%s]"</span>, x, y);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;        ...    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;        ...    &#125;&#125;</code></pre><p>除了用<code>final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>方法。</p><p>换句话说，使用<code>record</code>关键字，可以一行写出一个不变类。</p><p>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">public</span> Point &#123;        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        &#125;    &#125;&#125;</code></pre><p>注意到方法<code>public Point {...}</code>被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-comment">// 这是我们编写的Compact Constructor:</span>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        &#125;        <span class="hljs-comment">// 这是编译器继续生成的赋值代码:</span>        <span class="hljs-keyword">this</span>.x = x;        <span class="hljs-keyword">this</span>.y = y;    &#125;    ...&#125;</code></pre><p>作为<code>record</code>的<code>Point</code>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p><pre><code class="hljs javascript">public record Point(int x, int y) &#123;    public <span class="hljs-keyword">static</span> Point <span class="hljs-keyword">of</span>() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    &#125;    public <span class="hljs-keyword">static</span> Point <span class="hljs-keyword">of</span>(int x, int y) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Point(x, y);    &#125;&#125;</code></pre><p>这样我们可以写出更简洁的代码：</p><pre><code class="hljs java"><span class="hljs-keyword">var</span> z = Point.of();<span class="hljs-keyword">var</span> p = Point.of(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);</code></pre><h1 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h1><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p><p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p><pre><code class="hljs java">BigInteger bi = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"1234567890"</span>);System.out.println(bi.pow(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 2867971860299718107233761438093672048294900000</span></code></pre><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><pre><code class="hljs java">BigInteger i1 = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"1234567890"</span>);BigInteger i2 = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"12345678901234567890"</span>);BigInteger sum = i1.add(i2); <span class="hljs-comment">// 12345678902469135780</span></code></pre><p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p><p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p><pre><code class="hljs java">BigInteger i = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"123456789000"</span>);System.out.println(i.longValue()); <span class="hljs-comment">// 123456789000</span>System.out.println(i.multiply(i).longValueExact()); <span class="hljs-comment">// java.lang.ArithmeticException: BigInteger out of long range</span></code></pre><p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p><p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p><h1 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h1><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><pre><code class="hljs java">BigDecimal bd = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"123.4567"</span>);System.out.println(bd.multiply(bd)); <span class="hljs-comment">// 15241.55677489</span></code></pre><p><code>BigDecimal</code>用<code>scale()</code>表示小数位数。</p><p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</p><pre><code class="hljs java">BigDecimal d1 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"123.4500"</span>);BigDecimal d2 = d1.stripTrailingZeros();System.out.println(d1.scale()); <span class="hljs-comment">// 4</span>System.out.println(d2.scale()); <span class="hljs-comment">// 2,因为去掉了00</span>BigDecimal d3 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"1234500"</span>);BigDecimal d4 = d3.stripTrailingZeros();System.out.println(d3.scale()); <span class="hljs-comment">// 0</span>System.out.println(d4.scale()); <span class="hljs-comment">// -2</span></code></pre><p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<span class="hljs-keyword">import</span> java.math.RoundingMode;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        BigDecimal d1 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"123.456789"</span>);        BigDecimal d2 = d1.setScale(<span class="hljs-number">4</span>, RoundingMode.HALF_UP); <span class="hljs-comment">// 四舍五入，123.4568</span>        BigDecimal d3 = d1.setScale(<span class="hljs-number">4</span>, RoundingMode.DOWN); <span class="hljs-comment">// 直接截断，123.4567</span>        System.out.println(d2);        System.out.println(d3);    &#125;&#125;</code></pre><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><pre><code class="hljs java">BigDecimal d1 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"123.456"</span>);BigDecimal d2 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"23.456789"</span>);BigDecimal d3 = d1.divide(d2, <span class="hljs-number">10</span>, RoundingMode.HALF_UP); <span class="hljs-comment">// 保留10位小数并四舍五入</span>BigDecimal d4 = d1.divide(d2); <span class="hljs-comment">// 报错：ArithmeticException，因为除不尽</span></code></pre><p>还可以对<code>BigDecimal</code>做除法的同时求余数：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        BigDecimal n = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"12.345"</span>);        BigDecimal m = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"0.12"</span>);        BigDecimal[] dr = n.divideAndRemainder(m);        System.out.println(dr[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 102</span>        System.out.println(dr[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 0.105</span>    &#125;&#125;</code></pre><p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。</p><h2 id="比较BigDecimal"><a href="#比较BigDecimal" class="headerlink" title="比较BigDecimal"></a>比较BigDecimal</h2><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p><pre><code class="hljs java">BigDecimal d1 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"123.456"</span>);BigDecimal d2 = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"123.45600"</span>);System.out.println(d1.equals(d2)); <span class="hljs-comment">// false,因为scale不同</span>System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="hljs-comment">// true,因为d2去除尾部0后scale变为2</span>System.out.println(d1.compareTo(d2)); <span class="hljs-comment">// 0</span></code></pre><p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigDecimal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">BigDecimal</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigInteger intVal;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> scale;&#125;</code></pre><p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p><h1 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h1><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p><p>求绝对值：</p><pre><code class="hljs java">Math.abs(-<span class="hljs-number">100</span>); <span class="hljs-comment">// 100</span>Math.abs(-<span class="hljs-number">7.8</span>); <span class="hljs-comment">// 7.8</span></code></pre><p>取最大或最小值：</p><pre><code class="hljs java">Math.max(<span class="hljs-number">100</span>, <span class="hljs-number">99</span>); <span class="hljs-comment">// 100</span>Math.min(<span class="hljs-number">1.2</span>, <span class="hljs-number">2.3</span>); <span class="hljs-comment">// 1.2</span></code></pre><p>计算xy次方：</p><pre><code class="hljs java">Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 2的10次方=1024</span></code></pre><p>计算√x：</p><pre><code class="hljs java">Math.sqrt(<span class="hljs-number">2</span>); <span class="hljs-comment">// 1.414...</span></code></pre><p>计算$e^x$次方：</p><pre><code class="hljs java">Math.exp(<span class="hljs-number">2</span>); <span class="hljs-comment">// 7.389...</span></code></pre><p>计算以e为底的对数：</p><pre><code class="hljs java">Math.log(<span class="hljs-number">4</span>); <span class="hljs-comment">// 1.386...</span></code></pre><p>计算以10为底的对数：</p><pre><code class="hljs java">Math.log10(<span class="hljs-number">100</span>); <span class="hljs-comment">// 2</span></code></pre><p>三角函数：</p><pre><code class="hljs java">Math.sin(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 0.00159...</span>Math.cos(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// -0.9999...</span>Math.tan(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// -0.0015...</span>Math.asin(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 1.57079...</span>Math.acos(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 0.0</span></code></pre><p>Math还提供了几个数学常量：</p><pre><code class="hljs java"><span class="hljs-keyword">double</span> pi = Math.PI; <span class="hljs-comment">// 3.14159...</span><span class="hljs-keyword">double</span> e = Math.E; <span class="hljs-comment">// 2.7182818...</span>Math.sin(Math.PI / <span class="hljs-number">6</span>); <span class="hljs-comment">// sin(π/6) = 0.5</span></code></pre><p>生成一个随机数x，x的范围是<code>[0,1)</code>：</p><pre><code class="hljs java">Math.random(); <span class="hljs-comment">// 0.53907... 每次都不一样</span></code></pre><p>如果我们要生成一个区间在<code>[MIN, MAX)</code>的随机数，可以借助<code>Math.random()</code>实现，计算如下：</p><pre><code class="hljs java"><span class="hljs-comment">// 区间在[MIN, MAX)的随机数</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">double</span> x = Math.random(); <span class="hljs-comment">// x的范围是[0,1)</span>        <span class="hljs-keyword">double</span> min = <span class="hljs-number">10</span>;        <span class="hljs-keyword">double</span> max = <span class="hljs-number">50</span>;        <span class="hljs-keyword">double</span> y = x * (max - min) + min; <span class="hljs-comment">// y的范围是[10,50)</span>        <span class="hljs-keyword">long</span> n = (<span class="hljs-keyword">long</span>) y; <span class="hljs-comment">// n的范围是[10,50)的整数</span>        System.out.println(y);        System.out.println(n);    &#125;&#125;</code></pre><p>Java标准库还提供了一个<code>StrictMath</code>，它提供了和<code>Math</code>几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，<code>StrictMath</code>保证所有平台计算结果都是完全相同的，而<code>Math</code>会尽量针对平台优化计算速度，所以，绝大多数情况下，使用<code>Math</code>就足够了。</p><h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p><p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p><pre><code class="hljs java">Random r = <span class="hljs-keyword">new</span> Random();r.nextInt(); <span class="hljs-comment">// 2071575453,每次都不一样</span>r.nextInt(<span class="hljs-number">10</span>); <span class="hljs-comment">// 5,生成一个[0,10)之间的int</span>r.nextLong(); <span class="hljs-comment">// 8811649292570369305,每次都不一样</span>r.nextFloat(); <span class="hljs-comment">// 0.54335...生成一个[0,1)之间的float</span>r.nextDouble(); <span class="hljs-comment">// 0.3716...生成一个[0,1)之间的double</span></code></pre><p>有童鞋问，每次运行程序，生成的随机数都是不同的，没看出<em>伪随机数</em>的特性来。</p><p>这是因为我们创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</p><p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Random r = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">12345</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(r.nextInt(<span class="hljs-number">100</span>));        &#125;        <span class="hljs-comment">// 51, 80, 41, 28, 55...</span>    &#125;&#125;</code></pre><p>前面我们使用的<code>Math.random()</code>实际上内部调用了<code>Random</code>类，所以它也是伪随机数，只是我们无法指定种子。</p><h2 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h2><p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p><pre><code class="hljs java">SecureRandom sr = <span class="hljs-keyword">new</span> SecureRandom();System.out.println(sr.nextInt(<span class="hljs-number">100</span>));</code></pre><p><code>SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法。JDK的<code>SecureRandom</code>实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.security.SecureRandom;<span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SecureRandom sr = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            sr = SecureRandom.getInstanceStrong(); <span class="hljs-comment">// 获取高强度安全随机数生成器</span>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;            sr = <span class="hljs-keyword">new</span> SecureRandom(); <span class="hljs-comment">// 获取普通的安全随机数生成器</span>        &#125;        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">16</span>];        sr.nextBytes(buffer); <span class="hljs-comment">// 用安全随机数填充buffer</span>        System.out.println(Arrays.toString(buffer));    &#125;&#125;</code></pre><p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p><p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用<code>SecureRandom</code>来产生安全的随机数。</p><blockquote><p>需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记（二）面向对象编程</title>
    <link href="/2020/06/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/06/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/1JAVA%E5%AD%A6%E4%B9%A0/%E6%88%AA%E5%B1%8F2020-05-29%20%E4%B8%8B%E5%8D%883.42.19.png" srcset="/img/loading.gif" alt=""></p><p>方法区最先有数据，方法区中存放代码片段，存放class字节码。</p><p>堆内存：后面讲。</p><p>栈内存：方法调用的时候，该方法需要的内存空间在栈中分配。</p><p>方法只有在调用的时候才会在栈中分配空间，并且调用时是压栈。方法执行结束之后，该方法所需要的空间就会释放，此时发生弹栈动作。</p><h3 id="方法执行时内存变化"><a href="#方法执行时内存变化" class="headerlink" title="方法执行时内存变化"></a>方法执行时内存变化</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    System.out.println(<span class="hljs-string">"main begin"</span>);  <span class="hljs-keyword">int</span> x=<span class="hljs-number">100</span>;  m1(x);  System.out.println(<span class="hljs-string">"main over"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;  System.out.println(<span class="hljs-string">"m1 begin"</span>);  m2(i);  System.out.println(<span class="hljs-string">"m1 over"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;  System.out.println(<span class="hljs-string">"m2 begin"</span>);  m3(i);  System.out.println(<span class="hljs-string">"m2 over"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;  System.out.println(<span class="hljs-string">"m3 begin"</span>);  System.out.println(i);  System.out.println(<span class="hljs-string">"m3 over"</span>);&#125;</code></pre><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/1JAVA%E5%AD%A6%E4%B9%A0/%E6%88%AA%E5%B1%8F2020-05-29%20%E4%B8%8B%E5%8D%884.09.40.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/1JAVA%E5%AD%A6%E4%B9%A0/%E6%88%AA%E5%B1%8F2020-05-29%20%E4%B8%8B%E5%8D%884.13.46.png" srcset="/img/loading.gif" alt=""></p><h2 id="方法重载（overload）"><a href="#方法重载（overload）" class="headerlink" title="方法重载（overload）"></a>方法重载（overload）</h2><p>什么时候代码会发生方法重载？</p><p>条件1：在同一个类当中；</p><p>条件2：方法名相同；</p><p>条件3：参数列表不同（参数的个数不同、参数的类型不同、参数的顺序不同）。</p><p>只要同时满足以上3个条件，那么我们可以认定方法和方法之间发生了重载机制。</p><h1 id="认识面向对象"><a href="#认识面向对象" class="headerlink" title="认识面向对象"></a>认识面向对象</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>对于C语言来说，是完全面向过程的；</p><p>对于C++语言来说，是一半面向过程，一半面向对象；</p><p>对于JAVA语言来说，是完全面向对象的。</p><h2 id="OOA、OOD、OOP"><a href="#OOA、OOD、OOP" class="headerlink" title="OOA、OOD、OOP"></a>OOA、OOD、OOP</h2><p>当我们采用面向对象的方式贯穿整个系统的话，涉及到三个术语：</p><p>OOA：面向对象分析；</p><p>OOD：面向对象设计；</p><p>OOP：面向对象编程。</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类—【实例化】—&gt;对象（实例）</p><p>对象—【抽象】—&gt;类</p><h1 id="对象的创建和使用"><a href="#对象的创建和使用" class="headerlink" title="对象的创建和使用"></a>对象的创建和使用</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>Java中所有的“类”都属于引用数据类型。</p><h3 id="创建对象对应的JVM内存结构"><a href="#创建对象对应的JVM内存结构" class="headerlink" title="创建对象对应的JVM内存结构"></a>创建对象对应的JVM内存结构</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;  <span class="hljs-keyword">int</span> no;  string name;  <span class="hljs-keyword">int</span> age;  <span class="hljs-keyword">boolean</span> sex;  String addr;&#125;<span class="hljs-keyword">public</span> Class StudentTest&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;      <span class="hljs-comment">//s1这个局部变量叫做引用，指向创建的对象</span>      Student s1=<span class="hljs-keyword">new</span> Student();    &#125;&#125;</code></pre><blockquote><p>对象和引用的区别</p><p>对象是通过new出来的，在堆内存中存储；</p><p>引用是：但凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象的。</p></blockquote><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/1JAVA%E5%AD%A6%E4%B9%A0/%E6%88%AA%E5%B1%8F2020-06-01%20%E4%B8%8B%E5%8D%883.32.47.png" srcset="/img/loading.gif" alt=""></p><h2 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span></span>&#123;    A o1=<span class="hljs-keyword">new</span> A();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        D d=<span class="hljs-keyword">new</span> D();      C c=<span class="hljs-keyword">new</span> C();      B b=<span class="hljs-keyword">new</span> B();      A a=<span class="hljs-keyword">new</span> A();      T t=<span class="hljs-keyword">new</span> T();            <span class="hljs-comment">//这里代码不写会出现NullPointerException（空指针异常）</span>      <span class="hljs-comment">//因为如果不写的话，t.o1的new A()之后o1是null的</span>      c.o4=d;      b.o3=c;      a.o2=b;      t.o1=a;            System.out.println(t.o1.o2.o3.o4.i);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;  B o2;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;  C o3;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;  D o4;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span></span>&#123;  <span class="hljs-keyword">int</span> i;&#125;</code></pre><p>Java中的垃圾回收器GC主要针对回收的是堆内存当中的垃圾数据。当没有任何引用指向该对象的时候数据会被垃圾回收器回收。</p><p>空指针异常导致的最本质的原因是？空引用访问“实例相关的数据”，会出现空指针异常。</p><h2 id="方法调用时参数传递"><a href="#方法调用时参数传递" class="headerlink" title="方法调用时参数传递"></a>方法调用时参数传递</h2><p>Java中关于方法调用时参数传递实际上只有一个规则：</p><p>不管你是基本数据类型，还是<u>引用数据类型</u>，实际上在传递的时候都是将变量中保存的那个“值”复制一份，传过去。</p><pre><code class="hljs java">Person p1=<span class="hljs-number">0x1234</span>;Person p2=p1;<span class="hljs-comment">//把p1中保存的0x1234复制一份传给p2。</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Person p=<span class="hljs-keyword">new</span> Person();        p.age=<span class="hljs-number">10</span>;      add(p);      System.out.println(<span class="hljs-string">"main---&gt;"</span>+p.age);<span class="hljs-comment">//11</span>    &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Person p)</span></span>&#123;      p.age++;      System.out.println(<span class="hljs-string">"add---&gt;"</span>+p.age);<span class="hljs-comment">//11</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;  <span class="hljs-keyword">int</span> age;&#125;</code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>当一个类没有提供任何构造方法，系统会默认提供一个无参数的构造方法，这个构造方法被称为缺省构造器。</p><p>当一个类中手动地提供了构造方法，那么系统将不再提供无参数构造方法。</p><p>构造器的修饰符一定是public。</p><p>构造器方法不需要指定返回值类型，也不能写void。</p><h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><p>封装、继承、多态（递进）。</p><p>有了封装，才有继承；有了继承，才说多态。</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="封装有什么用"><a href="#封装有什么用" class="headerlink" title="封装有什么用"></a>封装有什么用</h2><p>假设封装之后，对于代码的调用人员来说，不需要关心代码的复杂实现，只需要通过一个简单的入口就可以访问了。</p><p>另外，类体中安全级别较高的数据封装起来，外部人员不能随意访问，来保证数据的安全性。</p><h2 id="怎么进行封装"><a href="#怎么进行封装" class="headerlink" title="怎么进行封装"></a>怎么进行封装</h2><p>第一步：属性私有化；</p><p>第二步：对外提供简单的操作入口（一个属性对外提供set和get方法，外部程序只能通过set方法修改，只能通过get方法访问，可以在set方法中设立关卡来保证数据的安全性）。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>没有static的方法被称为实例方法。</p><h2 id="set方法和get方法的封装"><a href="#set方法和get方法的封装" class="headerlink" title="set方法和get方法的封装"></a>set方法和get方法的封装</h2><p>JAVA开发规范中有要求，set方法和get方法要满足以下格式。</p><p>get方法的要求：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> 返回值类型 get+属性名首字母大写(无参)&#123;  <span class="hljs-keyword">return</span> xxx;&#125;</code></pre><p>set方法的要求：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> set+属性名首字母大写(有<span class="hljs-number">1</span>个参数)&#123;  xxx=参数;&#125;</code></pre><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>所有static关键字修饰的都是类相关的，类级别的。</p><p>所有static修饰的，都是采用“类名.”的方式访问。</p><blockquote><p>变量的分类：</p><p>变量根据声明的位置进行划分：</p><p>在方法体当中声明的变量叫做：局部变量；</p><p>在方法体外声明的变量叫做：成员变量。</p><p>成员变量又可以分为：</p><p>实例变量；静态变量。</p></blockquote><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>该变量对于每个对象来说是相同的，即改变量与对象的不同无关，才定义为静态变量。</p><p>静态变量在类加载时初始化，不需要new对象，静态变量的空间就开出来了。</p><p>静态变量存储在方法区。</p><p>构造方法里不用写静态变量的初始化。</p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/1JAVA%E5%AD%A6%E4%B9%A0/%E6%88%AA%E5%B1%8F2020-06-06%20%E4%B8%8B%E5%8D%889.41.39.png" srcset="/img/loading.gif" alt=""></p><p>静态的（静态变量、静态方法）建议使用“类名.”来访问，但使用“引用.”也行。</p><p>空指针访问静态不会空指针。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>方法一般都是描述了一个行为，如果说该行为必须由对象去触发，那么该方法定义为实例方法。</p><p>当这个方法体中，直接访问了实例变量，那么这个方法一定是实例方法。</p><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><h3 id="什么是静态代码块？语法是什么？"><a href="#什么是静态代码块？语法是什么？" class="headerlink" title="什么是静态代码块？语法是什么？"></a>什么是静态代码块？语法是什么？</h3><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;  java语句;  java语句;&#125;</code></pre><h3 id="静态代码块在什么时候执行呢？"><a href="#静态代码块在什么时候执行呢？" class="headerlink" title="静态代码块在什么时候执行呢？"></a>静态代码块在什么时候执行呢？</h3><p>类加载时执行，并且只执行一次。</p><p>静态代码块在类加载时执行，并且在main方法执行之前执行。</p><p>静态代码块一般是按照自上而下的顺序执行。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticTest</span></span>&#123;  <span class="hljs-comment">//静态代码块</span>  <span class="hljs-keyword">static</span>&#123;        System.out.println(<span class="hljs-string">"A"</span>);    &#125;    <span class="hljs-comment">//一个类当中可以编写多个静态代码块</span>  <span class="hljs-keyword">static</span>&#123;      System.out.println(<span class="hljs-string">"B"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;          &#125;    <span class="hljs-keyword">static</span>&#123;      System.out.println(<span class="hljs-string">"C"</span>);    &#125;&#125;</code></pre><h3 id="静态代码块的作用"><a href="#静态代码块的作用" class="headerlink" title="静态代码块的作用"></a>静态代码块的作用</h3><p>静态代码块这种语法机制实际上是SUN公司给java程序员的一个特殊的时刻/时机。这个时机叫做类加载时机。</p><blockquote><p>具体的业务：</p><p>项目经理说了：大家注意了，所有我们编写的程序中，只要是类加载了，请记录一下类加载的日志信息（在哪年哪月哪日几时几分几秒，哪个类加载到JVM中了）。</p><p>这些记录日志的代码写到静态代码块中。</p></blockquote><h2 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h2><p>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MALE = <span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FEMALE = <span class="hljs-number">2</span>;&#125;</code></pre><p>实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-comment">// 编译器会自动加上public statc final:</span>    <span class="hljs-keyword">int</span> MALE = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> FEMALE = <span class="hljs-number">2</span>;&#125;</code></pre><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>JAVA使用extends关键字实现继承。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;...&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;...&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;...&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;...&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-comment">// 不要重复name和age字段/方法,</span>    <span class="hljs-comment">// 只需要定义新增score字段/方法:</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> score;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123; … &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> score)</span> </span>&#123; … &#125;&#125;</code></pre><p>在OOP的术语中，我们把Person称为超类、父类、基类，把<code>Student</code>称为子类、扩展类。</p><h2 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h2><p>注意到我们在定义<code>Person</code>的时候，没有写<code>extends</code>。在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。所以，任何类，除了<code>Object</code>，都会继承自某个类。下图是<code>Person</code>、<code>Student</code>的继承树：</p><pre><code class="hljs ascii">┌───────────┐│  Object   │└───────────┘      ▲      │┌───────────┐│  Person   │└───────────┘      ▲      │┌───────────┐│  Student  │└───────────┘</code></pre><p>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p><h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p><code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问。</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, "</span> + <span class="hljs-keyword">super</span>.name;    &#125;&#125;</code></pre><p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p><p>但是，在某些时候，就必须使用<code>super</code>。我们来看一个例子：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Student s = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Xiao Ming"</span>, <span class="hljs-number">12</span>, <span class="hljs-number">89</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">protected</span> String name;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> score;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> score)</span> </span>&#123;        <span class="hljs-keyword">this</span>.score = score;    &#125;&#125;</code></pre><p>运行上面的代码，会得到一个编译错误，大意是在<code>Student</code>的构造方法中，无法调用<code>Person</code>的构造方法。</p><p>这是因为在Java中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>。</p><p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p><p>因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p><p>子类<em>不会继承</em>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Student();</code></pre><p>这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。</p><p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p><pre><code class="hljs java">Student s = <span class="hljs-keyword">new</span> Student();Person p = s; <span class="hljs-comment">// upcasting, ok</span>Object o1 = p; <span class="hljs-comment">// upcasting, ok</span>Object o2 = s; <span class="hljs-comment">// upcasting, ok</span></code></pre><p>可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><pre><code class="hljs java">Person p1 = <span class="hljs-keyword">new</span> Student(); <span class="hljs-comment">// upcasting, ok</span>Person p2 = <span class="hljs-keyword">new</span> Person();Student s1 = (Student) p1; <span class="hljs-comment">// ok</span>Student s2 = (Student) p2; <span class="hljs-comment">// runtime error! ClassCastException!</span></code></pre><p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Person();System.out.println(p <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true</span>System.out.println(p <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// false</span>Student s = <span class="hljs-keyword">new</span> Student();System.out.println(s <span class="hljs-keyword">instanceof</span> Person); <span class="hljs-comment">// true</span>System.out.println(s <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// true</span>Student n = <span class="hljs-keyword">null</span>;System.out.println(n <span class="hljs-keyword">instanceof</span> Student); <span class="hljs-comment">// false</span></code></pre><p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。</p><p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：</p><pre><code class="hljs java">Object obj = <span class="hljs-string">"hello"</span>;<span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String) &#123;    String s = (String) obj;    System.out.println(s.toUpperCase());&#125;</code></pre><p>可以改写如下：</p><pre><code class="hljs java">Object obj = <span class="hljs-string">"hello"</span>;<span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String s) &#123;    System.out.println(s.toUpperCase());&#125;</code></pre><p>使用<code>instanceof variable</code>这种判断并转型为指定类型变量的语法时，必须打开编译器开关<code>--source 14</code>和<code>--enable-preview</code>。</p><h1 id="多态（Polymorphic）"><a href="#多态（Polymorphic）" class="headerlink" title="多态（Polymorphic）"></a>多态（Polymorphic）</h1><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p><p>Override和Overload不同的是，如果方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</p><blockquote><p>方法签名由方法名称和一个参数列表(方法的参数的顺序和类型)组成。 </p></blockquote><p>方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p><p>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。但是<code>@Override</code>不是必需的。</p><p>现在，我们考虑一种情况，如果子类覆写了父类的方法：</p><pre><code class="hljs c++"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Person p = <span class="hljs-keyword">new</span> Student();        p.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">//输出Student.run</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Person.run"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-title">extends</span> <span class="hljs-title">Person</span> &#123;</span>    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Student.run"</span>);    &#125;&#125;</code></pre><p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</p><p>假设我们编写这样一个方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runTwice</span><span class="hljs-params">(Person p)</span> </span>&#123;    p.run();    p.run();&#125;</code></pre><p>它传入的参数类型是<code>Person</code>，我们是无法知道传入的参数实际类型究竟是<code>Person</code>，还是<code>Student</code>，还是<code>Person</code>的其他子类，因此，也无法确定调用的是不是<code>Person</code>类定义的<code>run()</code>方法。</p><p>所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span>        Income[] incomes = <span class="hljs-keyword">new</span> Income[] &#123;            <span class="hljs-keyword">new</span> Income(<span class="hljs-number">3000</span>),            <span class="hljs-keyword">new</span> Salary(<span class="hljs-number">7500</span>),            <span class="hljs-keyword">new</span> StateCouncilSpecialAllowance(<span class="hljs-number">15000</span>)        &#125;;        System.out.println(totalTax(incomes));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">totalTax</span><span class="hljs-params">(Income... incomes)</span> </span>&#123;        <span class="hljs-keyword">double</span> total = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (Income income: incomes) &#123;            total = total + income.getTax();        &#125;        <span class="hljs-keyword">return</span> total;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Income</span> </span>&#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> income;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Income</span><span class="hljs-params">(<span class="hljs-keyword">double</span> income)</span> </span>&#123;        <span class="hljs-keyword">this</span>.income = income;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> income * <span class="hljs-number">0.1</span>; <span class="hljs-comment">// 税率10%</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Income</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Salary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> income)</span> </span>&#123;        <span class="hljs-keyword">super</span>(income);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (income &lt;= <span class="hljs-number">5000</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> (income - <span class="hljs-number">5000</span>) * <span class="hljs-number">0.2</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateCouncilSpecialAllowance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Income</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StateCouncilSpecialAllowance</span><span class="hljs-params">(<span class="hljs-keyword">double</span> income)</span> </span>&#123;        <span class="hljs-keyword">super</span>(income);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><p>观察<code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</p><h2 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h2><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">protected</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, "</span> + name;    &#125;&#125;Student extends Person &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 调用父类的hello()方法:</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.hello() + <span class="hljs-string">"!"</span>;    &#125;&#125;</code></pre><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>。</p><p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承。</p><p>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。可以在构造方法中初始化final字段。</p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p><p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h2 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h2><p>无法实例化的抽象类有什么用？</p><p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p><p>例如，<code>Person</code>类定义了抽象方法<code>run()</code>，那么，在实现子类<code>Student</code>的时候，就必须覆写<code>run()</code>方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Person p = <span class="hljs-keyword">new</span> Student();        p.run();    &#125;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Student.run"</span>);    &#125;&#125;</code></pre><h2 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h2><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p><pre><code class="hljs java">Person s = <span class="hljs-keyword">new</span> Student();Person t = <span class="hljs-keyword">new</span> Teacher();</code></pre><p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p><pre><code class="hljs java"><span class="hljs-comment">// 不关心Person变量的具体子类型:</span>s.run();t.run();</code></pre><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><p>面向抽象编程的本质就是：</p><ul><li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>就可以把该抽象类改写为接口：<code>interface</code>。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">" run"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;    &#125;&#125;</code></pre><p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span>, <span class="hljs-title">Hello</span> </span>&#123; <span class="hljs-comment">// 实现了两个interface</span>    ...&#125;</code></pre><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p><p>抽象类和接口的对比如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">abstract class</th><th style="text-align:left">interface</th></tr></thead><tbody><tr><td style="text-align:left">继承</td><td style="text-align:left">只能extends一个class</td><td style="text-align:left">可以implements多个interface</td></tr><tr><td style="text-align:left">字段</td><td style="text-align:left">可以定义实例字段</td><td style="text-align:left">不能定义实例字段</td></tr><tr><td style="text-align:left">抽象方法</td><td style="text-align:left">可以定义抽象方法</td><td style="text-align:left">可以定义抽象方法</td></tr><tr><td style="text-align:left">非抽象方法</td><td style="text-align:left">可以定义非抽象方法</td><td style="text-align:left">可以定义default方法</td></tr></tbody></table></div><h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;&#125;</code></pre><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p>合理设计<code>interface</code>和<code>abstract class</code>的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p><pre><code class="hljs ascii">┌───────────────┐│   Iterable    │└───────────────┘        ▲                ┌───────────────────┐        │                │      Object       │┌───────────────┐        └───────────────────┘│  Collection   │                  ▲└───────────────┘                  │        ▲     ▲          ┌───────────────────┐        │     └──────────│AbstractCollection │┌───────────────┐        └───────────────────┘│     List      │                  ▲└───────────────┘                  │              ▲          ┌───────────────────┐              └──────────│   AbstractList    │                         └───────────────────┘                                ▲     ▲                                │     │                                │     │                     ┌────────────┐ ┌────────────┐                     │ ArrayList  │ │ LinkedList │                     └────────────┘ └────────────┘</code></pre><p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：</p><pre><code class="hljs java">List list = <span class="hljs-keyword">new</span> ArrayList(); <span class="hljs-comment">// 用List接口引用具体子类的实例</span>Collection coll = list; <span class="hljs-comment">// 向上转型为Collection接口</span>Iterable it = coll; <span class="hljs-comment">// 向上转型为Iterable接口</span></code></pre><h2 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h2><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Person p = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Xiao Ming"</span>);        p.run();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(getName() + <span class="hljs-string">" run"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;    &#125;&#125;</code></pre><p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>在Java中，我们使用<code>package</code>来解决名字冲突。</p><p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p><p>例如：</p><p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p><p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p><p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p><p>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</p><p>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</p><p>小明的<code>Person.java</code>文件：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> ming; <span class="hljs-comment">// 申明包名ming</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;&#125;</code></pre><p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</p><p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p><blockquote><p>要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p></blockquote><p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p><p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p><pre><code class="hljs ascii">package_sample└─ src    ├─ hong    │  └─ Person.java    │  ming    │  └─ Person.java    └─ mr       └─ jun          └─ Arrays.java</code></pre><p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下，那么，编译的文件结构就是：</p><pre><code class="hljs ascii">package_sample└─ bin   ├─ hong   │  └─ Person.class   │  ming   │  └─ Person.class   └─ mr      └─ jun         └─ Arrays.class</code></pre><p>编译的命令相对比较复杂，我们需要在<code>src</code>目录下执行<code>javac</code>命令：</p><pre><code class="hljs shell">javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java</code></pre><h2 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h2><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> hello;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-comment">// 包作用域:</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Hello!"</span>);    &#125;&#125;</code></pre><p><code>Main</code>类也定义在<code>hello</code>包下面：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> hello;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Person p = <span class="hljs-keyword">new</span> Person();        p.hello(); <span class="hljs-comment">// 可以调用，因为Main和Person在同一个包</span>    &#125;&#125;</code></pre><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。例如，小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法：</p><p>第一种，直接写出完整类名，例如：</p><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><span class="hljs-keyword">package</span> ming;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        mr.jun.Arrays arrays = <span class="hljs-keyword">new</span> mr.jun.Arrays();    &#125;&#125;</code></pre><p>第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><span class="hljs-keyword">package</span> ming;<span class="hljs-comment">// 导入完整类名:</span><span class="hljs-keyword">import</span> mr.jun.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        Arrays arrays = <span class="hljs-keyword">new</span> Arrays();    &#125;&#125;</code></pre><p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）。</p><p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p><p>第三种<code>import static</code>的语法，它可以导入一个类的静态字段和静态方法：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> main;<span class="hljs-comment">// 导入System类的所有静态字段和静态方法:</span><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 相当于调用System.out.println(…)</span>        out.println(<span class="hljs-string">"Hello, world!"</span>);    &#125;&#125;</code></pre><p><code>import static</code>很少使用。</p><p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li><li>如果是简单类名，按下面的顺序依次查找：<ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li></ul><p>所以编写class的时候，编译器会自动帮我们做两个import动作：</p><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li><li>默认自动<code>import java.lang.*</code>。</li></ul><blockquote><p> 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</p></blockquote><p>如果有两个<code>class</code>名称相同，例如，<code>mr.jun.Arrays</code>和<code>java.util.Arrays</code>，那么只能<code>import</code>其中一个，另一个必须写完整类名。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p><ul><li>org.apache</li><li>org.apache.commons.log</li><li>com.liaoxuefeng.sample</li></ul><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><p>上面的<code>Hello</code>是<code>public</code>，因此，可以被其他包的类访问：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> xyz;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// Main可以访问Hello</span>        Hello h = <span class="hljs-keyword">new</span> Hello();    &#125;&#125;</code></pre><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>推荐把<code>private</code>方法放到后面，因为<code>public</code>方法定义了类对外提供的功能，阅读代码的时候，应该先关注<code>public</code>方法：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.hi();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><p>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Inner i = <span class="hljs-keyword">new</span> Inner();        i.hi();    &#125;    <span class="hljs-comment">// private方法:</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"private hello!"</span>);    &#125;    <span class="hljs-comment">// 静态内部类:</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;            Main.hello();<span class="hljs-comment">//输出private hello!</span>        &#125;    &#125;&#125;</code></pre><p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类。</p><h2 id="protected-1"><a href="#protected-1" class="headerlink" title="protected"></a>protected</h2><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的<em>字段和方法</em>可以被子类访问，以及子类的子类：</p><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。</p><h2 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h2><p>用<code>final</code>修饰<code>class</code>可以阻止被继承：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<span class="hljs-comment">// 无法被继承:</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span> </span>&#123;        <span class="hljs-keyword">long</span> i = t;    &#125;&#125;</code></pre><p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-comment">// 无法被覆写:</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre><p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.n = <span class="hljs-number">1</span>; <span class="hljs-comment">// error!</span>    &#125;&#125;</code></pre><p>用<code>final</code>修饰局部变量可以阻止被重新赋值：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> abc;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> t)</span> </span>&#123;        t = <span class="hljs-number">1</span>; <span class="hljs-comment">// error!</span>    &#125;&#125;</code></pre><h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p><p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p><h1 id="classpath和jar"><a href="#classpath和jar" class="headerlink" title="classpath和jar"></a>classpath和jar</h1><h2 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h2><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p><p>因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件。</p><p>所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来，可能长这样：</p><pre><code class="hljs shell">C:\work\project1\bin;C:\shared;"D:\My Documents\project1\bin"</code></pre><p>在Linux系统上，用<code>:</code>分隔，可能长这样：</p><pre><code class="hljs shell">/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</code></pre><p>现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p><ul><li>&lt;当前目录&gt;\abc\xyz\Hello.class</li><li>C:\work\project1\bin\abc\xyz\Hello.class</li><li>C:\shared\abc\xyz\Hello.class</li></ul><p>注意到<code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p><p><code>classpath</code>的设定方法有两种：</p><p>在系统环境变量中设置<code>classpath</code>环境变量，不推荐；</p><p>在启动JVM时设置<code>classpath</code>变量，推荐。</p><p>我们强烈<em>不推荐</em>在系统环境变量中设置<code>classpath</code>，那样会污染整个系统环境。在启动JVM时设置<code>classpath</code>才是推荐的做法。实际上就是给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数：</p><pre><code class="hljs shell">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</code></pre><p>或者使用<code>-cp</code>的简写：</p><pre><code class="hljs shell">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</code></pre><p>没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即当前目录：</p><pre><code class="hljs shell">java abc.xyz.Hello</code></pre><p>上述命令告诉JVM只在当前目录搜索<code>Hello.class</code>。</p><p>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包。</p><p>通常，我们在自己编写的<code>class</code>中，会引用Java核心库的<code>class</code>，例如，<code>String</code>、<code>ArrayList</code>等。这些<code>class</code>应该上哪去找？</p><p>有很多“如何设置classpath”的文章会告诉你把JVM自带的<code>rt.jar</code>放入<code>classpath</code>，但事实上，根本不需要告诉JVM如何去Java核心库查找<code>class</code>，JVM怎么可能笨到连自己的核心库在哪都不知道？</p><blockquote><p>不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！</p></blockquote><p>更好的做法是，不要设置<code>classpath</code>！默认的当前目录<code>.</code>对于绝大多数情况都够用了。</p><h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><p>jar包可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件。</p><p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath中：</p><pre><code class="hljs shell">java -cp ./hello.jar abc.xyz.Hello</code></pre><p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p><h3 id="创建jar包"><a href="#创建jar包" class="headerlink" title="创建jar包"></a>创建jar包</h3><p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</p><p>假设编译输出的目录结构是这样：</p><pre><code class="hljs ascii">package_sample└─ bin   ├─ hong   │  └─ Person.class   │  ming   │  └─ Person.class   └─ mr      └─ jun         └─ Arrays.class</code></pre><p>这里需要特别注意的是，jar包里的第一层目录，不能是<code>bin</code>，而应该是<code>hong</code>、<code>ming</code>、<code>mr</code>。</p><p>如果jar包里的第一层目录是bin，JVM仍然无法从jar包中查找正确的<code>class</code>，原因是<code>hong.Person</code>必须按<code>hong/Person.class</code>存放，而不是<code>bin/hong/Person.class</code>。</p><p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p><pre><code class="hljs shell">java -jar hello.jar</code></pre><p>jar包还可以包含其它jar包，这个时候，就需要在<code>MANIFEST.MF</code>文件里配置<code>classpath</code>了。</p><p>在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200" target="_blank" rel="noopener">Maven</a>，可以非常方便地创建jar包。</p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>从Java 9开始，JDK又引入了模块（Module）。</p><p>我们知道，<code>.class</code>文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆<code>.class</code>文件，很不便于管理，所以，<code>jar</code>文件就是<code>class</code>文件的容器。</p><p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M。</p><p>如果是自己开发的程序，除了一个自己的<code>app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p><pre><code class="hljs bash">java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</code></pre><blockquote><p>JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。</p></blockquote><p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p><p>为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p><ul><li>java.base.jmod</li><li>java.compiler.jmod</li><li>java.datatransfer.jmod</li><li>java.desktop.jmod</li><li>…</li></ul><p>这些<code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。所有的模块都直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code>Object</code>直接或间接继承而来。</p><p>把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p><h2 id="编写模块"><a href="#编写模块" class="headerlink" title="编写模块"></a>编写模块</h2><p>首先，创建模块和原有的创建Java项目是完全一样的，以<code>oop-module</code>工程为例，它的目录结构如下：</p><pre><code class="hljs ascii">oop-module├── bin├── build.sh└── src    ├── com    │   └── itranswarp    │       └── sample    │           ├── Greeting.java    │           └── Main.java    └── module-info.java</code></pre><p>其中，<code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.world &#123;<span class="hljs-keyword">requires</span> java.base; <span class="hljs-comment">// 可不写，任何模块都会自动引入java.base</span><span class="hljs-keyword">requires</span> java.xml;&#125;</code></pre><p>其中，<code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块。</p><p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，<code>Main.java</code>代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itranswarp.sample;<span class="hljs-comment">// 必须引入java.xml模块后才能使用其中的类:</span><span class="hljs-keyword">import</span> javax.xml.XMLConstants;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Greeting g = <span class="hljs-keyword">new</span> Greeting();System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));&#125;&#125;</code></pre><p>如果把<code>requires java.xml;</code>从<code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。</p><p>下面，我们用JDK提供的命令行工具来编译并创建模块。</p><p>首先，我们把工作目录切换到<code>oop-module</code>，在当前目录下编译所有的<code>.java</code>文件，并存放到<code>bin</code>目录下，命令如下：</p><pre><code class="hljs bash">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</code></pre><p>如果编译成功，现在项目结构如下：</p><pre><code class="hljs ascii">oop-module├── bin│   ├── com│   │   └── itranswarp│   │       └── sample│   │           ├── Greeting.class│   │           └── Main.class│   └── module-info.class└── src    ├── com    │   └── itranswarp    │       └── sample    │           ├── Greeting.java    │           └── Main.java    └── module-info.java</code></pre><p>下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p><pre><code class="hljs bash">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</code></pre><p>现在我们就在当前目录下得到了<code>hello.jar</code>这个jar包，它和普通jar包并无区别，可以直接使用命令<code>java -jar hello.jar</code>来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p><pre><code class="hljs bash">$ jmod create --class-path hello.jar hello.jmod</code></pre><p>于是，在当前目录下我们又得到了<code>hello.jmod</code>这个模块文件。</p><h2 id="运行模块"><a href="#运行模块" class="headerlink" title="运行模块"></a>运行模块</h2><p>要运行一个jar，我们使用<code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要指定模块名。</p><pre><code class="hljs bash">$ java --module-path hello.jar --module hello.world</code></pre><p>那我们辛辛苦苦创建的<code>hello.jmod</code>有什么用？答案是我们可以用它来打包JRE。</p><h2 id="打包JRE"><a href="#打包JRE" class="headerlink" title="打包JRE"></a>打包JRE</h2><p>前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的<code>rt.jar</code>拆成了几十个<code>.jmod</code>模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。</p><p>过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p><p>现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了<code>jlink</code>命令来干这件事。命令如下：</p><pre><code class="hljs bash">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</code></pre><p>我们在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录。</p><p>现在，在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p><pre><code class="hljs bash">$ jre/bin/java --module hello.world</code></pre><p>要分发我们自己的Java应用程序，只需要把这个<code>jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</p><p>确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p><p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：</p><pre><code class="hljs java"><span class="hljs-keyword">module</span> java.xml &#123;    <span class="hljs-keyword">exports</span> java.xml;    <span class="hljs-keyword">exports</span> javax.xml.catalog;    <span class="hljs-keyword">exports</span> javax.xml.datatype;    ...&#125;</code></pre><p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.world &#123;    <span class="hljs-keyword">exports</span> com.itranswarp.sample;      <span class="hljs-keyword">requires</span> java.base;<span class="hljs-keyword">requires</span> java.xml;&#125;</code></pre><p>因此，模块进一步隔离了代码的访问权限。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记（一）Java快速入门</title>
    <link href="/2020/06/14/Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2020/06/14/Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Java开发环境搭建"><a href="#Java开发环境搭建" class="headerlink" title="Java开发环境搭建"></a>Java开发环境搭建</h1><h2 id="Java语言特性"><a href="#Java语言特性" class="headerlink" title="Java语言特性"></a>Java语言特性</h2><p>在Java语言中真正操作内存的是：JVM（Java虚拟机）</p><p>所有的Java程序都是运行在Java虚拟机当中的。</p><p>而Java虚拟机执行过程中再去操作内存。</p><p>Java语言底层是C++，所以JVM是用C++语言写好的一个虚拟的计算机。Java程序实际上没有直接和操作系统打交道。</p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/%E6%8D%95%E8%8E%B71.PNG" srcset="/img/loading.gif" alt=""></p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>JavaSE：标准版；JavaEE：企业版；JavaME：微型版。</p><p>JDK：Java开发工具箱；JRE：Java运行环境。</p><h2 id="Java的加载与执行原理"><a href="#Java的加载与执行原理" class="headerlink" title="Java的加载与执行原理"></a>Java的加载与执行原理</h2><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/%E6%8D%95%E8%8E%B72.PNG" srcset="/img/loading.gif" alt=""></p><p>java HelloWorld的执行过程：</p><ol><li>先启动JVM；</li><li>JVM启动后，JVM会去启动类加载器，类加载器负责去硬盘上找“类”对应的“字节码”文件（HelloWorld.class）；</li><li>类加载器如果在硬盘上找不到对应的字节码文件——错误：找不到或无法加载主类；类加载器如果找到了，类加载器会将字节码文件装载到JVM中，JVM启动解释器将字节码解释为二进制码，操作系统执行二进制码和硬件交互。</li></ol><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>安装Tomcat服务器需要配置JAVA_HOME环境变量。</p><p>让类加载器去指定的路径下加载字节码文件：设置一个环境变量，叫做classpath，classpath环境变量是java特有的。配置了classpath之后类加载器只会去配置的路径下去找不会再去当前路径下找。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">*javadoc注释：这里的注释信息可以自动被javadoc.exe命令解析提取并生成到帮助文档中</span><span class="hljs-comment">*/</span></code></pre><p>例如：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span></span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment">* 这是一个程序的入口</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> args是main方法的参数</span><span class="hljs-comment">*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;            &#125;&#125;</code></pre><p>生成javadoc文档：</p><pre><code class="hljs shell">javadoc -d javaapi T.java</code></pre><p>把javadoc放入javaapi文件夹。</p><h2 id="接收键盘输入"><a href="#接收键盘输入" class="headerlink" title="接收键盘输入"></a>接收键盘输入</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        java.util.Scanner s=<span class="hljs-keyword">new</span> java.util.Scanner(System.in);        <span class="hljs-keyword">int</span> a=s.nextInt();        System.out.println(a);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Scanner s=<span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">int</span> a=s.nextInt();        System.out.println(a);    &#125;&#125;</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>在java中任何有效的代码必须写到类当中。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;    &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;    &#125;<span class="hljs-comment">//编译通过</span></code></pre><p>一个java源代码文件中有多个类，编译后有多个class文件。</p><p>public的类不是必须的。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;    &#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;    &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;    &#125;<span class="hljs-comment">//编译报错</span></code></pre><p>public的类可以没有，但如果有的话，public修饰的类名必须和源文件名保持一致。因此一个java文件里面public的类只能有一个。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        System.out.println(<span class="hljs-string">"T1..."</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T2</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        System.out.println(<span class="hljs-string">"T2..."</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T3</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        System.out.println(<span class="hljs-string">"T3..."</span>);    &#125;&#125;<span class="hljs-comment">//编译通过</span></code></pre><p>想从哪个入口进去，就加载哪个类。例如：</p><pre><code class="hljs sh">java T1java T2java T3</code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>在Java中数据被称为字面量。例如10、1.23、true、’a’、”abc”，分别为整数型字面量、浮点型字面量、布尔型字面量、字符型字面量、字符串型字面量。</p><p>只有字面量内存是无法重复利用的，使用变量以后内存空间就得到了重复利用。</p><h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><p>变量是内存中存储数据的最基本的单元。</p><p>Java变量必须先声明再赋值才能访问（没有值相当于空间没有开辟）。</p><p>局部变量只在方法体中有效，方法体执行结束该变量的内存就释放了。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><div class="table-container"><table><thead><tr><th>类型</th><th>占用字节数量</th><th>取值范围</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>[-128,127]</td></tr><tr><td>short</td><td>2</td><td>[-32768,32767]</td></tr><tr><td>int</td><td>4</td><td>[-2147483648,2147483647]</td></tr><tr><td>long</td><td>8</td><td></td></tr><tr><td>float</td><td>4</td><td></td></tr><tr><td>double</td><td>8</td><td></td></tr><tr><td>boolean</td><td>1</td><td></td></tr><tr><td>char</td><td>2</td><td>[0,65535]</td></tr></tbody></table></div><h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>字符编码规定了一系列文字对应的二进制。</p><p>字符编码涉及到编码和解码两个过程。</p><p>ASCII码：英文；</p><p>国际标准组织制定ISO-8859-1（latin-1）：向上兼容ASCII；</p><p>GB2312&lt;GBK&lt;GB18030：简体中文；</p><p>big5：繁体中文。</p><p>在Java中，采用Unicode编码，支持所有文字，具体的实现包括：UTF-8、UTF-16、UTF-32…</p><p>char可以存储一个汉字。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>\u表示后面的事一个字符的unicode编码。unicode编码是十六进制的。</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-keyword">char</span> x=<span class="hljs-string">'\u4e2d'</span>;System.out.println(x);<span class="hljs-comment">//输出：中</span></code></pre><h2 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h2><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><pre><code class="hljs java"><span class="hljs-comment">//十进制</span><span class="hljs-keyword">int</span> a=<span class="hljs-number">10</span>;<span class="hljs-comment">//八进制</span><span class="hljs-keyword">int</span> b=<span class="hljs-number">010</span>;<span class="hljs-comment">//十六进制</span><span class="hljs-keyword">int</span> c=<span class="hljs-number">0x10</span>;<span class="hljs-comment">//二进制</span><span class="hljs-keyword">int</span> d=<span class="hljs-number">0b10</span>;</code></pre><h3 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h3><p>在任何情况下，整数型的字面量默认被当作int类型处理，浮点型的字面量默认被当作double类型处理。 </p><p>当整数型字面量没有超出byte/short/char的取值范围，那么这个整数型字面量可以直接赋值给byte/short/char。</p><p>多种数据类型做混合运算的时候，最终的结果是最大容量对应的类型，但是byte、char、short做混合运算的时候，各自先转换成int。</p><pre><code class="hljs java"><span class="hljs-keyword">char</span> c1=<span class="hljs-string">'a'</span>;<span class="hljs-keyword">byte</span> b=<span class="hljs-number">1</span>;<span class="hljs-keyword">short</span> s=c1+b;<span class="hljs-comment">//理应是98，但是编译报错：从int转换到short可能会有损失，因为编译器不知道结果</span><span class="hljs-keyword">short</span> k=<span class="hljs-number">98</span>;<span class="hljs-comment">//编译通过</span><span class="hljs-keyword">short</span> s1=(<span class="hljs-keyword">short</span>)c1+b;<span class="hljs-comment">//编译报错</span><span class="hljs-keyword">short</span> s=(<span class="hljs-keyword">short</span>)(c1+b);<span class="hljs-comment">//编译通过</span><span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>;<span class="hljs-keyword">short</span> x=a;<span class="hljs-comment">//编译报错，编译器只知道a是int类型，不知道a中存储的是哪个值</span>System.out.println(x);</code></pre><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>小容量可以自动转换成大容量。</p><blockquote><p>容量排序：</p><p>byte&lt;short/char&lt;int&lt;long&lt;float&lt;double</p></blockquote><p>例如：</p><pre><code class="hljs java"><span class="hljs-comment">//int自动转换成long</span><span class="hljs-keyword">long</span> b=<span class="hljs-number">200</span>;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">long</span> e=<span class="hljs-number">2147483648</span>;<span class="hljs-comment">//编译报错，超过int取值范围</span></code></pre><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>大容量不能直接赋值给小容量，需要使用强制类型转换符进行强制转换，但是运行时可能损失精度。</p><pre><code class="hljs java"><span class="hljs-keyword">long</span> x=<span class="hljs-number">100L</span>;<span class="hljs-keyword">int</span> y=x;<span class="hljs-comment">//编译报错</span></code></pre><h3 id="二进制原码反码补码"><a href="#二进制原码反码补码" class="headerlink" title="二进制原码反码补码"></a>二进制原码反码补码</h3><p>反码是原码的符号位不变，其他位取反；补码是反码+1。</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-keyword">byte</span> b=(<span class="hljs-keyword">byte</span>)<span class="hljs-number">150</span>;<span class="hljs-comment">//10010110（补码）</span><span class="hljs-comment">//10010101（反码）</span><span class="hljs-comment">//11101010（原码）</span>System.out.println(b);<span class="hljs-comment">//输出：-106</span></code></pre><h2 id="字符串连接运算符"><a href="#字符串连接运算符" class="headerlink" title="字符串连接运算符"></a>字符串连接运算符</h2><p>当+运算符两边的任意一边是字符串类型，那么这个+会进行字符串拼接操作。</p><p>String属于引用数据类型。</p><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>凡是有权利自己命名的单词都是标识符。例如类名、方法名（main也是，但是是固定的）、变量名、接口名、常量名。</p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>标识符只能由数字、字母（包括中文）、下划线、美元符号组成，中间不能有空格。</p><p>标识符不能以数字开头。</p><p>关键字不能作标识符。</p><p>区分大小写。</p><blockquote><p>虽然java中的标识符严格区分大小写，但是对于类名来说，如果一个java源文件中同时出现了A类和a类，那么谁在前就生成谁。</p></blockquote><p>标识符没有长度限制。</p><blockquote><p>在123.java中不能定义public的类。</p><p>因为public修饰的类名必须和源文件名保持一致。</p></blockquote><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>驼峰命名。</p><p>类名、接口名每个单词首字母大写。</p><p>变量名、方法名首字母小写，后面每个单词首字母大写。</p><p>常量名全部大小，并且单词和单词之间采用下划线衔接。</p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>java中的所有关键字全部小写，具有特殊含义。</p><h1 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h1><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><p>使用标准的<code>for</code>循环可以完成一个数组的遍历。</p><p>使用<code>for each</code>循环，直接迭代数组的每个元素。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] ns = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span> &#125;;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : ns) &#123;            System.out.println(n);        &#125;    &#125;&#125;</code></pre><p>注意：在<code>for (int n : ns)</code>循环中，变量<code>n</code>直接拿到<code>ns</code>数组的元素，而不是索引。</p><h2 id="打印元素"><a href="#打印元素" class="headerlink" title="打印元素"></a>打印元素</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] ns = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span> &#125;;        System.out.println(Arrays.toString(ns));      <span class="hljs-comment">//输出[1, 1, 2, 3, 5, 8]</span>    &#125;&#125;</code></pre><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>Java的标准库已经内置了排序功能，我们只需要调用JDK提供的<code>Arrays.sort()</code>就可以排序：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] ns = &#123; <span class="hljs-number">28</span>, <span class="hljs-number">12</span>, <span class="hljs-number">89</span>, <span class="hljs-number">73</span>, <span class="hljs-number">65</span>, <span class="hljs-number">18</span>, <span class="hljs-number">96</span>, <span class="hljs-number">50</span>, <span class="hljs-number">8</span>, <span class="hljs-number">36</span> &#125;;        Arrays.sort(ns);        System.out.println(Arrays.toString(ns));      <span class="hljs-comment">//输出[8, 12, 18, 28, 36, 50, 65, 73, 89, 96] </span>    &#125;&#125;</code></pre><p>如果对一个字符串数组进行排序，例如：</p><pre><code class="hljs java">String[] ns = &#123; <span class="hljs-string">"banana"</span>, <span class="hljs-string">"apple"</span>, <span class="hljs-string">"pear"</span> &#125;;</code></pre><p>排序前，这个数组在内存中表示如下：</p><pre><code class="hljs ascii">                   ┌──────────────────────────────────┐               ┌───┼──────────────────────┐           │               │   │                      ▼           ▼         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘           │                 ▲           └─────────────────┘</code></pre><p>调用<code>Arrays.sort(ns);</code>排序后，这个数组在内存中表示如下：</p><pre><code class="hljs ascii">                   ┌──────────────────────────────────┐               ┌───┼──────────┐                       │               │   │          ▼                       ▼         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘           │                              ▲           └──────────────────────────────┘</code></pre><p>原来的3个字符串在内存中均没有任何变化，但是<code>ns</code>数组的每个元素指向变化了。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] ns = &#123;            &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;,            &#123; <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> &#125;,            &#123; <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span> &#125;        &#125;;        System.out.println(ns.length); <span class="hljs-comment">// 3</span>    &#125;&#125;</code></pre><p>因为<code>ns</code>包含3个数组，因此，<code>ns.length</code>为<code>3</code>。</p><p>二维数组的每个数组元素的长度并不要求相同，例如，可以这么定义<code>ns</code>数组：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] ns = &#123;    &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;,    &#123; <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;,    &#123; <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;&#125;;</code></pre><p>要打印一个二维数组，可以使用两层嵌套的for循环：</p><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] arr : ns) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : arr) &#123;        System.out.print(n);        System.out.print(<span class="hljs-string">', '</span>);    &#125;    System.out.println();&#125;</code></pre><p>或者使用Java标准库的<code>Arrays.deepToString()</code>：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] ns = &#123;            &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;,            &#123; <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> &#125;,            &#123; <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span> &#125;        &#125;;        System.out.println(Arrays.deepToString(ns));      <span class="hljs-comment">//输出[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] </span>    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv学习笔记（四）创建Trackbar &amp; 图像对比度、亮度值调整</title>
    <link href="/2020/01/11/opencv4/"/>
    <url>/2020/01/11/opencv4/</url>
    
    <content type="html"><![CDATA[<h1 id="轨迹条的创建和使用"><a href="#轨迹条的创建和使用" class="headerlink" title="轨迹条的创建和使用"></a>轨迹条的创建和使用</h1><h2 id="createTrackbar函数"><a href="#createTrackbar函数" class="headerlink" title="createTrackbar函数"></a>createTrackbar函数</h2><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">createTrackbar</span><span class="hljs-params">(conststring&amp; trackbarname, conststring&amp; winname,<span class="hljs-keyword">int</span>* value,<span class="hljs-keyword">int</span> count,TrackbarCallback onChange=<span class="hljs-number">0</span>,<span class="hljs-keyword">void</span>* userdata=<span class="hljs-number">0</span>)</span></span>;</code></pre><ul><li>第一个参数，const string&amp;类型的trackbarname，表示轨迹条的名字。</li><li>第二个参数，const string&amp;类型的winname，填窗口的名字，表示这个轨迹条会依附到哪个窗口上，即对应namedWindow（）创建窗口时填的某一个窗口名。</li><li>第三个参数，int* 类型的value，一个指向整型的指针，表示滑块的位置。并且在创建时，滑块的初始位置就是该变量当前的值。</li><li>第四个参数，int类型的count，表示滑块可以达到的最大位置的值。PS:滑块最小的位置的值始终为0。</li><li>第五个参数，TrackbarCallback类型的onChange，首先注意他有默认值0。这是一个指向回调函数的指针，每次滑块位置改变时，这个函数都会进行回调。并且这个函数的原型必须为void XXXX(int,void*);其中第一个参数是轨迹条的位置，第二个参数是用户数据（看下面的第六个参数）。如果回调是NULL指针，表示没有回调函数的调用，仅第三个参数value有变化。</li><li>第六个参数，void*类型的userdata，它也有默认值0。这个参数是用户传给回调函数的数据，用来处理轨迹条事件。如果使用的第三个参数value实参是全局变量的话，完全可以不去管这个userdata参数。</li></ul><p>createTrackbar函数，为我们创建一个具有特定名称和范围的轨迹条，指定一个和轨迹条位置同步的变量。而且要指定回调函数onChange（第五个参数），在轨迹条位置改变的时候来调用这个回调函数。并且我们知道，创建的轨迹条显示在指定的winname（第二个参数）所代表的窗口上。</p><blockquote><p>回调函数，就是一个通过函数指针调用的函数。如果我们把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就称其为回调函数。回调函数不由该函数的实现方直接调用，而是在特定的事件或条件发生时由于另外的一方调用，用于对该事件或条件进行响应。</p></blockquote><pre><code class="hljs c++"> <span class="hljs-comment">//创建轨迹条</span>createTrackbar(<span class="hljs-string">"对比度："</span>, <span class="hljs-string">"【效果图窗口】"</span>,&amp;g_nContrastValue,<span class="hljs-number">300</span>,ContrastAndBright );<span class="hljs-comment">//g_nContrastValue为全局的整型变量，ContrastAndBright为回调函数的函数名（即指向函数地址的指针）</span></code></pre><h2 id="getTrackbarPos函数"><a href="#getTrackbarPos函数" class="headerlink" title="getTrackbarPos函数"></a>getTrackbarPos函数</h2><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getTrackbarPos</span><span class="hljs-params">(conststring&amp; trackbarname,conststring&amp; winname)</span></span>;</code></pre><ul><li>第一个参数，const string&amp;类型的trackbarname，表示轨迹条的名字。</li><li>第二个参数，const string&amp;类型的winname，表示轨迹条的父窗口的名称。</li></ul><h1 id="亮度和对比度调整"><a href="#亮度和对比度调整" class="headerlink" title="亮度和对比度调整"></a>亮度和对比度调整</h1><script type="math/tex; mode=display">g(i,j)=a*f(i,j)+b</script><h1 id="访问图片中的像素"><a href="#访问图片中的像素" class="headerlink" title="访问图片中的像素"></a>访问图片中的像素</h1><p>为了执行<script type="math/tex">g(i,j)=a*f(i,j)+b</script>这个运算 ，我们需要访问图像的每一个像素。因为是对RGB图像进行运算，每个像素有三个值（B、G、R），所以我们必须分别访问它们。以下是访问像素的代码片段，三个for循环解决问题：</p><pre><code class="hljs c++"><span class="hljs-comment">//三个for循环，执行运算 new_image(i,j) =a*image(i,j) + b</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-built_in">image</span>.rows; y++ )&#123;       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-built_in">image</span>.cols; x++ )       &#123;              <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">3</span>; c++ )              &#123;                     new_image.at&lt;Vec3b&gt;(y,x)[c]= saturate_cast&lt;uchar&gt;( (g_nContrastValue*<span class="hljs-number">0.01</span>)*(<span class="hljs-built_in">image</span>.at&lt;Vec3b&gt;(y,x)[c] ) + g_nBrightValue );              &#125;       &#125;&#125;</code></pre><p>为了访问图像的每一个像素，我们使用这样的语法：<script type="math/tex">image.at<Vec3b>(y,x)[c]</script>，其中，y是像素所在的行， x是像素所在的列， c是B、G、R（对应0、1、2）其中之一。<br>因为我们的运算结果可能超出像素取值范围（溢出），还可能是非整数（如果是浮点数的话），所以我们要用saturate_cast对结果进行转换，以确保它为有效值。<br>这里的a也就是对比度，一般为了观察的效果，取值为0.0到3.0的浮点值，但是我们的轨迹条一般取值都会整数，所以在这里我们可以，将其代表对比度值的nContrastValue参数设为0到300之间的整型，在最后的式子中乘以一个0.01，这样就可以完成轨迹条中300个不同取值的变化。所以在式子中，我们会看到saturate_cast\<uchar>( (g_nContrastValue<em>0.01)</em>(image.at\<Vec3b>(y,x)[c] ) + g_nBrightValue )中的g_nContrastValue*0.01。</p><h1 id="图像对比度、亮度值调整示例程序"><a href="#图像对比度、亮度值调整示例程序" class="headerlink" title="图像对比度、亮度值调整示例程序"></a>图像对比度、亮度值调整示例程序</h1><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/core/core.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">"opencv2/imgproc/imgproc.hpp"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv; <span class="hljs-comment">//-----------------------------------【全局函数声明部分】--------------------------------------</span><span class="hljs-comment">//     描述：全局函数声明</span><span class="hljs-comment">//-----------------------------------------------------------------------------------------------</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ContrastAndBright</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span> *)</span></span>; <span class="hljs-comment">//-----------------------------------【全局变量声明部分】--------------------------------------</span><span class="hljs-comment">//     描述：全局变量声明</span><span class="hljs-comment">//-----------------------------------------------------------------------------------------------</span><span class="hljs-keyword">int</span> g_nContrastValue; <span class="hljs-comment">//对比度值</span><span class="hljs-keyword">int</span> g_nBrightValue;  <span class="hljs-comment">//亮度值</span>Mat g_srcImage,g_dstImage;<span class="hljs-comment">//-----------------------------------【main( )函数】--------------------------------------------</span><span class="hljs-comment">//     描述：控制台应用程序的入口函数，我们的程序从这里开始</span><span class="hljs-comment">//-----------------------------------------------------------------------------------------------</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(  )</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-comment">//改变控制台前景色和背景色</span>       system(<span class="hljs-string">"color5F"</span>);         <span class="hljs-comment">//读入用户提供的图像</span>       g_srcImage= imread( <span class="hljs-string">"pic1.jpg"</span>);              <span class="hljs-keyword">if</span>(!g_srcImage.data ) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Oh，no，读取g_srcImage图片错误~！\n"</span>); <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;       g_dstImage= Mat::zeros( g_srcImage.<span class="hljs-built_in">size</span>(), g_srcImage.type() );        <span class="hljs-comment">//设定对比度和亮度的初值</span>       g_nContrastValue=<span class="hljs-number">80</span>;       g_nBrightValue=<span class="hljs-number">80</span>;        <span class="hljs-comment">//创建窗口</span>       namedWindow(<span class="hljs-string">"【效果图窗口】"</span>, <span class="hljs-number">1</span>);        <span class="hljs-comment">//创建轨迹条</span>       createTrackbar(<span class="hljs-string">"对比度："</span>, <span class="hljs-string">"【效果图窗口】"</span>,&amp;g_nContrastValue,<span class="hljs-number">300</span>,ContrastAndBright );       createTrackbar(<span class="hljs-string">"亮   度："</span>,<span class="hljs-string">"【效果图窗口】"</span>,&amp;g_nBrightValue,<span class="hljs-number">200</span>,ContrastAndBright );             <span class="hljs-comment">//调用回调函数</span>       ContrastAndBright(g_nContrastValue,<span class="hljs-number">0</span>);       ContrastAndBright(g_nBrightValue,<span class="hljs-number">0</span>);             <span class="hljs-comment">//输出一些帮助信息</span>       <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>&lt;&lt;<span class="hljs-string">"\t嗯。好了，请调整滚动条观察图像效果~\n\n"</span>                     &lt;&lt;<span class="hljs-string">"\t按下“q”键时，程序退出~!\n"</span>                     &lt;&lt;<span class="hljs-string">"\n\n\t\t\t\tby浅墨"</span>;        <span class="hljs-comment">//按下“q”键时，程序退出</span>   <span class="hljs-keyword">while</span>(<span class="hljs-keyword">char</span>(waitKey(<span class="hljs-number">1</span>)) != <span class="hljs-string">'q'</span>) &#123;&#125;       return0;&#125;  <span class="hljs-comment">//-----------------------------【ContrastAndBright( )函数】------------------------------------</span><span class="hljs-comment">//     描述：改变图像对比度和亮度值的回调函数</span><span class="hljs-comment">//-----------------------------------------------------------------------------------------------</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ContrastAndBright</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span> *)</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-comment">//创建窗口</span>       namedWindow(<span class="hljs-string">"【原始图窗口】"</span>, <span class="hljs-number">1</span>);        <span class="hljs-comment">//三个for循环，执行运算 g_dstImage(i,j) =a*g_srcImage(i,j) + b</span>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; g_srcImage.rows; y++ )       &#123;              <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; g_srcImage.cols; x++ )              &#123;                     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">3</span>; c++ )                     &#123;                            g_dstImage.at&lt;Vec3b&gt;(y,x)[c]= saturate_cast&lt;uchar&gt;( (g_nContrastValue*<span class="hljs-number">0.01</span>)*(g_srcImage.at&lt;Vec3b&gt;(y,x)[c] ) + g_nBrightValue );                     &#125;              &#125;       &#125;        <span class="hljs-comment">//显示图像</span>       imshow(<span class="hljs-string">"【原始图窗口】"</span>, g_srcImage);       imshow(<span class="hljs-string">"【效果图窗口】"</span>, g_dstImage);&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv学习笔记（三）分离颜色通道&amp;多通道图像混合</title>
    <link href="/2020/01/11/opencv3/"/>
    <url>/2020/01/11/opencv3/</url>
    
    <content type="html"><![CDATA[<p>为了更好的观察一些图像材料的特征，有时需要对RGB三个颜色通道的分量进行分别显示和调整。通过OpenCV的split和merge方法可以很方便的达到目的。</p><h1 id="分离颜色通道"><a href="#分离颜色通道" class="headerlink" title="分离颜色通道"></a>分离颜色通道</h1><h2 id="split函数"><a href="#split函数" class="headerlink" title="split函数"></a>split函数</h2><p>将一个多通道数组分离成几个单通道数组。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Mat&amp; src, Mat* mvbegin)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(InputArray m,OutputArrayOfArrays mv)</span></span>;</code></pre><ul><li><p>第一个参数，InputArray类型的mat或者const Mat&amp;类型的src，填我们需要进行分离的多通道数组。</p></li><li><p>第二个参数，OutputArrayOfArrays类型的mv，填函数的输出数组或者输出的vector容器。</p></li></ul><p>split函数分割多通道数组转换成独立的单通道数组，公式为<script type="math/tex">mv[c](I)=src(I)_c</script>。</p><p>示例：</p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;Mat&gt; channels;Mat imageBlueChannel;Mat imageGreenChannel;Mat imageRedChannel;srcImage4= imread(<span class="hljs-string">"dota.jpg"</span>);<span class="hljs-comment">// 把一个3通道图像转换成3个单通道图像</span>split(srcImage4,channels);<span class="hljs-comment">//分离色彩通道</span>imageBlueChannel = channels.at(<span class="hljs-number">0</span>);imageGreenChannel = channels.at(<span class="hljs-number">1</span>);imageRedChannel = channels.at(<span class="hljs-number">2</span>);</code></pre><h2 id="merge函数"><a href="#merge函数" class="headerlink" title="merge函数"></a>merge函数</h2><p>将多个数组组合合并成一个多通道的数组。</p><p>它通过组合一些给定的单通道数组，将这些孤立的单通道数组合并成一个多通道的数组，从而创建出一个由多个单通道阵列组成的多通道阵列。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Mat* mv, <span class="hljs-keyword">size_t</span> count, OutputArray dst)</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(InputArrayOfArrays mv,OutputArray dst)</span></span></code></pre><ul><li>第一个参数mv，填需要被合并的输入矩阵或vector容器的阵列，这个mv参数中所有的矩阵必须有着一样的尺寸和深度。</li><li>第二个参数count，当mv为一个空白的C数组时，代表输入矩阵的个数，这个参数显然必须大于1。</li><li>第三个参数dst，即输出矩阵，和mv[0]拥有一样的尺寸和深度，并且通道的数量是矩阵阵列中的通道的总数。</li></ul><p>merge函数的功能是将一些数组合并成一个多通道的数组。关于组合的细节，输出矩阵中的每个元素都将是输出数组的串接，其中，第i个输入数组的元素被视为mv[i]。 c一般用其中的Mat::at()方法对某个通道进行存取,也就是这样用channels.at(0)。</p><blockquote><p>Mat::at（）方法，返回一个引用到指定的数组元素。注意是引用，相当于两者等价，修改其中一个另一个跟着变。</p></blockquote><p>示例：</p><pre><code class="hljs c++">Mat srcImage;Mat imageROI;<span class="hljs-built_in">vector</span>&lt;Mat&gt; channels;srcImage= cv::imread(<span class="hljs-string">"dota.jpg"</span>);<span class="hljs-comment">// 把一个3通道图像转换成3个单通道图像</span>split(srcImage,channels);<span class="hljs-comment">//分离色彩通道</span>imageROI=channels.at(<span class="hljs-number">0</span>);       addWeighted(imageROI(Rect(<span class="hljs-number">385</span>,<span class="hljs-number">250</span>,logoImage.cols,logoImage.rows)),<span class="hljs-number">1.0</span>,     logoImage,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.</span>,imageROI(Rect(<span class="hljs-number">385</span>,<span class="hljs-number">250</span>,logoImage.cols,logoImage.rows))); merge(channels,srcImage4); namedWindow(<span class="hljs-string">"sample"</span>);imshow(<span class="hljs-string">"sample"</span>,srcImage);</code></pre><p>如果我们需要从多通道数组中提取出特定的单通道数组，或者说实现一些复杂的通道组合，可以使用mixChannels()函数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv学习笔记（二）ROI区域图像叠加&amp;初级图像混合</title>
    <link href="/2020/01/11/opencv2/"/>
    <url>/2020/01/11/opencv2/</url>
    
    <content type="html"><![CDATA[<h1 id="ROI"><a href="#ROI" class="headerlink" title="ROI"></a>ROI</h1><h2 id="cv-Rect"><a href="#cv-Rect" class="headerlink" title="cv:Rect"></a>cv:Rect</h2><p>指定矩形的左上角坐标（构造函数的前两个参数）和矩形的长宽（构造函数的后两个参数）就可以定义一个矩形区域。</p><pre><code class="hljs c++"><span class="hljs-comment">//定义一个Mat类型并给其设定ROI区域</span>Mat imageROI;<span class="hljs-comment">//方法一</span>imageROI=<span class="hljs-built_in">image</span>(Rect(<span class="hljs-number">500</span>,<span class="hljs-number">250</span>,logo.cols,logo.rows));</code></pre><h2 id="cv-Range"><a href="#cv-Range" class="headerlink" title="cv::Range"></a>cv::Range</h2><p>Range是指从起始索引到终止索引（不包括终止索引）的一连段连续序列。</p><pre><code class="hljs c++"><span class="hljs-comment">//方法二</span>imageROI=srcImage3(Range(<span class="hljs-number">250</span>,<span class="hljs-number">250</span>+logoImage.rows),Range(<span class="hljs-number">500</span>,<span class="hljs-number">500</span>+logoImage.cols));</code></pre><h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>操作系统为B开辟了新的内存空间，所以A改变不会导致B改变。</p><pre><code class="hljs c++">Mat A,B;A = imread(<span class="hljs-string">"1.jpg"</span>);B = A.clone();<span class="hljs-comment">//A.copyTo(B);</span></code></pre><p>copyTo()以及掩膜的用法：</p><p><a href="https://www.cnblogs.com/phoenixdsg/p/8420716.html" target="_blank" rel="noopener">https://www.cnblogs.com/phoenixdsg/p/8420716.html</a></p><p><a href="https://www.cnblogs.com/skyfsm/p/6894685.html" target="_blank" rel="noopener">https://www.cnblogs.com/skyfsm/p/6894685.html</a></p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>B只拷贝了A的地址，所以A改变的话会导致B改变。</p><pre><code class="hljs c++">Mat A,B;A = imread(<span class="hljs-string">"1.jpg"</span>);B = A;</code></pre><h1 id="初级图像混合——线性混合操作"><a href="#初级图像混合——线性混合操作" class="headerlink" title="初级图像混合——线性混合操作"></a>初级图像混合——线性混合操作</h1><h2 id="addWeighted函数"><a href="#addWeighted函数" class="headerlink" title="addWeighted函数"></a>addWeighted函数</h2><p>这个函数的作用是，计算两个数组（图像阵列）的加权和。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addWeighted</span><span class="hljs-params">(InputArray src1, <span class="hljs-keyword">double</span> alpha, InputArray src2, <span class="hljs-keyword">double</span> beta, <span class="hljs-keyword">double</span> gamma, OutputArray dst, <span class="hljs-keyword">int</span> dtype=<span class="hljs-number">-1</span>)</span></span>;</code></pre><ul><li>第一个参数，表示需要加权的第一个数组，常常填一个Mat。</li><li>第二个参数，表示第一个数组的权重。</li><li>第三个参数，表示第二个数组，它需要和第一个数组拥有相同的尺寸和通道数。</li><li>第四个参数，表示第二个数组的权重值。</li><li>第五个参数，一个加到权重总和上的标量值。</li><li>第六个参数，输出的数组，它和输入的两个数组拥有相同的尺寸和通道数。</li><li>第七个参数，输出阵列的可选深度，有默认值-1。;当两个输入数组具有相同的深度时，这个参数设置为-1（默认值），即等同于src1.depth（）。</li></ul><script type="math/tex; mode=display">dst = src1[I]*alpha+ src2[I]*beta + gamma</script><p>其中的I是多维数组元素的索引值。而且，在遇到多通道数组的时候，每个通道都需要独立地进行处理。另外需要注意的是，当输出数组的深度为CV_32S时，这个函数就不适用了，这时候就会内存溢出或者算出的结果压根不对。</p><blockquote><p><strong>图像深度</strong>是指存储每个像素所用的位数,也用于量度图像的色彩分辨率.图像深度确定彩色图像的每个像素可能有的颜色数,或者确定灰度图像的每个像素可能有的灰度级数.它决定了彩色图像中可出现的最多颜色数,或灰度图像中的最大灰度等级.比如一幅单色图像,若每个象素有8位,则最大灰度数目为2的8次方,即256.一幅彩色图像RGB3个分量的象素位数分别为4,4,2,则最大颜色数目为2的4+4+2次方,即1024,就是说像素的深度为10位,每个像素可以是1024种颜色中的一种.</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>opencv学习笔记（一）图像的载入、显示和输出</title>
    <link href="/2020/01/11/opencv1/"/>
    <url>/2020/01/11/opencv1/</url>
    
    <content type="html"><![CDATA[<h1 id="图像的载入和显示"><a href="#图像的载入和显示" class="headerlink" title="图像的载入和显示"></a>图像的载入和显示</h1><h2 id="imread函数"><a href="#imread函数" class="headerlink" title="imread函数"></a>imread函数</h2><pre><code class="hljs c++"><span class="hljs-function">Mat <span class="hljs-title">imread</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; filename, intflags=<span class="hljs-number">1</span> )</span></span>;</code></pre><p>第一个参数，填需要载入的图片路径名。</p><p>第二个参数，</p><ul><li>flags &gt;0返回一个3通道的彩色图像。</li><li>flags =0返回灰度图像。</li><li>flags &lt;0返回包含Alpha通道的加载的图像。</li></ul><h2 id="namedWindow函数"><a href="#namedWindow函数" class="headerlink" title="namedWindow函数"></a>namedWindow函数</h2><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">namedWindow</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; winname,<span class="hljs-keyword">int</span> flags=WINDOW_AUTOSIZE )</span></span>;</code></pre><p>第一个参数，填被用作窗口的标识符的窗口名称。</p><p>第二个参数，</p><ul><li><p>WINDOW_NORMAL设置了这个值，用户便可以改变窗口的大小（没有限制）</p></li><li><p>WINDOW_AUTOSIZE如果设置了这个值，窗口大小会自动调整以适应所显示的图像，并且不能手动改变窗口大小。</p></li><li>WINDOW_OPENGL 如果设置了这个值的话，窗口创建的时候便会支持OpenGL。</li></ul><p>我们可以调用destroyWindow()或者destroyAllWindows()函数来关闭窗口，并取消之前分配的与窗口相关的所有内存空间。</p><h2 id="imshow函数"><a href="#imshow函数" class="headerlink" title="imshow函数"></a>imshow函数</h2><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">imshow</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; winname, InputArray mat)</span></span>;</code></pre><p> 第一个参数，填需要显示的窗口标识名称。</p><p> 第二个参数，填需要显示的图像。</p><h2 id="imwrite函数"><a href="#imwrite函数" class="headerlink" title="imwrite函数"></a>imwrite函数</h2><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">imwrite</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; filename,InputArray img, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; params=<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;() )</span></span>;</code></pre><p>第一个参数，填需要写入的文件名。</p><p>第二个参数，填一个Mat类型的图像数据。</p><p>第三个参数，表示为特定格式保存的参数编码，它有默认值vector<int>()，所以一般情况下不需要填写。而如果要填写的话，有下面这些需要了解的地方：</p><p>对于JPEG格式的图片，这个参数表示从0到100的图片质量（CV_IMWRITE_JPEG_QUALITY），默认值是95.<br>对于PNG格式的图片，这个参数表示压缩级别（CV_IMWRITE_PNG_COMPRESSION）从0到9。较高的值意味着更小的尺寸和更长的压缩时间，而默认值是3。<br>对于PPM，PGM，或PBM格式的图片，这个参数表示一个二进制格式标志（CV_IMWRITE_PXM_BINARY），取值为0或1，而默认值是1。</p>]]></content>
    
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVL树的插入与旋转</title>
    <link href="/2019/02/26/AVL%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E6%97%8B%E8%BD%AC/"/>
    <url>/2019/02/26/AVL%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E6%97%8B%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>AVL树本质上是一颗二叉查找树，但是它又具有以下特点：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><h2 id="插入与旋转"><a href="#插入与旋转" class="headerlink" title="插入与旋转"></a>插入与旋转</h2><h3 id="单旋"><a href="#单旋" class="headerlink" title="单旋"></a>单旋</h3><h4 id="LL型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h4><p>在根结点的左子树的左子树上插入节点。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0jwi1qpmcj30j20ax74x.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="RR型"><a href="#RR型" class="headerlink" title="RR型"></a>RR型</h4><p>在根结点的右子树的右子树上插入节点。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0jwklqkdij30ic0b3mxo.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0jwlpjmywj30x10lsaby.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="双旋"><a href="#双旋" class="headerlink" title="双旋"></a>双旋</h3><h4 id="LR型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h4><p>在根结点的左子树的右子树上插入节点。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0jwr9l5h8j30j60bmq3f.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="RL型"><a href="#RL型" class="headerlink" title="RL型"></a>RL型</h4><p>在根结点的右子树的左子树上插入节点。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0k1kzljl3j30gh0avq3e.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0k1lze2bzj30z50kxta4.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">int</span> high;    node *left,*right;    node(<span class="hljs-keyword">int</span> x)    &#123;        val=x;high=<span class="hljs-number">0</span>;        left=right=<span class="hljs-literal">NULL</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gethigh</span><span class="hljs-params">(node *temp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(temp==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> temp-&gt;high;&#125;<span class="hljs-function">node* <span class="hljs-title">SingleRotateLL</span><span class="hljs-params">(node *root)</span></span><span class="hljs-function"></span>&#123;    node *temp;    temp=root-&gt;left;    root-&gt;left=temp-&gt;right;    temp-&gt;right=root;    root-&gt;high=<span class="hljs-built_in">max</span>(gethigh(root-&gt;left),gethigh(root-&gt;right))+<span class="hljs-number">1</span>;     <span class="hljs-comment">//更新高度</span>    temp-&gt;high=<span class="hljs-built_in">max</span>(gethigh(temp-&gt;left),gethigh(temp-&gt;right))+<span class="hljs-number">1</span>;         <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function">node *<span class="hljs-title">SingleRotateRR</span><span class="hljs-params">(node *root)</span></span><span class="hljs-function"></span>&#123;    node *temp;    temp=root-&gt;right;    root-&gt;right=temp-&gt;left;    temp-&gt;left=root;    root-&gt;high=<span class="hljs-built_in">max</span>(gethigh(root-&gt;left),gethigh(root-&gt;right))+<span class="hljs-number">1</span>; <span class="hljs-comment">//更新高度</span>    temp-&gt;high=<span class="hljs-built_in">max</span>(gethigh(temp-&gt;left),gethigh(temp-&gt;right))+<span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function">node *<span class="hljs-title">DoubleRotateLR</span><span class="hljs-params">(node *root)</span></span><span class="hljs-function"></span>&#123;    root-&gt;left=SingleRotateRR(root-&gt;left);    <span class="hljs-keyword">return</span> SingleRotateLL(root);&#125;<span class="hljs-function">node *<span class="hljs-title">DoubleRotateRL</span><span class="hljs-params">(node *root)</span></span><span class="hljs-function"></span>&#123;    root-&gt;right=SingleRotateLL(root-&gt;right);    <span class="hljs-keyword">return</span> SingleRotateRR(root);&#125;<span class="hljs-function">node* <span class="hljs-title">Insert</span><span class="hljs-params">(node *root,<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> node(x);&#125;    <span class="hljs-keyword">if</span>(x&lt;root-&gt;val)    &#123;        root-&gt;left=Insert(root-&gt;left,x);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(gethigh(root-&gt;left)-gethigh(root-&gt;right))&gt;<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">if</span>(x&lt;root-&gt;left-&gt;val)                root=SingleRotateLL(root);            <span class="hljs-keyword">else</span>                root=DoubleRotateLR(root);        &#125;    &#125;    <span class="hljs-keyword">else</span>    &#123;        root-&gt;right=Insert(root-&gt;right,x);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(gethigh(root-&gt;left)-gethigh(root-&gt;right))&gt;<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">if</span>(x&gt;root-&gt;right-&gt;val)                root=SingleRotateRR(root);            <span class="hljs-keyword">else</span>                root=DoubleRotateRL(root);        &#125;    &#125;    root-&gt;high=<span class="hljs-built_in">max</span>(gethigh(root-&gt;left),gethigh(root-&gt;right))+<span class="hljs-number">1</span>; <span class="hljs-comment">//更新高度</span>    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    node *root=<span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">while</span>(n--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        root=Insert(root,x);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,root-&gt;val);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tips</title>
    <link href="/2019/02/09/tips/"/>
    <url>/2019/02/09/tips/</url>
    
    <content type="html"><![CDATA[<p>不要直接在辅导书上做题！因为要做很多遍。</p><p>推荐作息时间表：</p><p>6：30 起床(严格执行)</p><p>6：40—7：00 洗漱10分钟，跑步10分钟。</p><p>7：10—7：30 吃饭 少油，少糖，有汤，吃七成饱</p><p>7：40—8：20 背单词</p><p>8：30—11：40 做训练 做练习的速度要越快越好，最好看着手表做</p><p>11：50—12：20 吃饭 有肉，多菜，九成饱</p><p>12：20—13：00 午睡 午睡不可超过一小时(严格执行)</p><p>13：00—17：00 做练习</p><p>17：00—17：30 跑步，假如条件允许，做一些力量性(哑铃类)的运动</p><p>17：30—18：00 吃晚饭要八成饱，多吃青菜少吃肉类</p><p>18：00—22：00 看书、做练习</p><p>22：00—23：00 锻炼、洗漱、洗澡</p><p>23：00—23：30 背单词</p><p>23：30—6：30 睡觉 (严格执行)</p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>在考试前复习全书应该至少是过了两遍、历年真题及真题解析3—4遍。</p><p>最好是在九月或十月就得开始做真题了，尽量是一周一套。</p><h3 id="高数"><a href="#高数" class="headerlink" title="高数"></a>高数</h3><ul><li>基础知识课本：张宇《高等数学十八讲》</li><li>习题：《张宇考研数学习题1000题》辅以李老师660题刷一下概念小题</li><li>模拟题：《张宇考研模拟题8套卷》+《张宇最后考场4套卷》 合工大超越135</li><li>真题：《张宇考研真题大全解》</li></ul><h3 id="线代"><a href="#线代" class="headerlink" title="线代"></a>线代</h3><ul><li>基础知识课本：李永乐《线性代数辅导讲义》</li><li>听一遍张或汤的基础班了解基本概念后认真听李永乐老师的线代课。</li></ul><h3 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h3><ul><li>曹显兵的概率论辅导讲义</li></ul><p>3-6月底：</p><p>尽力把高数基础知识过一遍，实在看不完，也至少要看完微积分上下。</p><p>课本要不要看：建议高数主要是看公式推导，定理性质推导例题。积分和求导部分课后题有必要做。线代课本定理，例题都要看。课后题可以不做。</p><p>7-8月底：</p><p>至少要完成基础知识完完整整一遍，讲义看完，习题做完。可以对着强化课程学习，一边看视频整理笔记，整理完听课笔记马上开始刷题。</p><p>9-10月底：</p><p>继续刷1000题。最迟到十月上旬要完成1000题。完成真题和模拟卷。</p><p>11月-12月底：</p><p>完成剩余的真题和模拟题。</p><p>对冲击120+的人推荐毛岗源的考研数学解题技巧那本书，认真学一遍受益匪浅，会补充很多其他书上没有的东西，不过此书颇厚，学时候要挑着看。对于冲击150的人推荐大学数学竞赛教程（今年压轴题题源）与高等数学证明题500例解析（专攻各类证明），解决压轴题。还有一本书叫李正元最后冲刺超越135分，是少见的分题型习题书，我做了一半实在没时间做了，书不厚但是题难，大家有兴趣的可以最后买本看看。</p><p>冲刺时候老师还推荐一位：方浩。押题请看李林，别的不说他出的押题卷本身质量也属于中上。</p><ul><li>模拟卷排序：合工大超越卷（推荐13-19年的都做。淘宝有打印整合版，模拟卷唯一神卷）—合工大共创卷（这个简单一点，和超越卷有部分重合的，做了近两年就行）—张宇八套卷四套卷个别题目（有些题目居然要求泰勒展开到七阶基本毫无意义）—李林押题卷（这卷子我建议明年人手一份吧，既然都连着两年“押中”了）—李永乐老师汤加凤老师各自模拟卷及李正元400题（这个卷子计算量挺大的）等一系列。最后刷模拟卷真题卷时候淘宝买一些答题卡（英语数学），严格按考研时间做，答案铅笔涂，能很好的模拟考场环境，保持上午数学头脑兴奋，下午英语头脑兴奋。</li><li>数学公式最后要经常过。</li><li>题目一定要自己做，题目一定自己做，题目一定自己做。</li></ul><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>题型分布：（英语一）</p><p>完型10分</p><p>阅读40分</p><p>新题型10分</p><p>翻译10分</p><p>小作文 10分</p><p>大作文20分</p><ul><li><p>英语真题（淘宝最畅销的黄皮书）</p><blockquote><p>模拟和真题</p><p>可以在背单词期间做2000年之前的真题，2000年之后的真题在背好单词之后用。</p></blockquote></li><li><p>单词：新东方乱序单词书、</p><p>单词一直背到上考场。</p></li><li><p>长难句：看唐迟老师的长难句课。宋逸轩的长难句。</p></li><li><p>阅读：唐迟老师。何凯文《阅读思路解析》。</p></li><li><p>语法：田静。</p></li><li><p>新题型：看徐家朋。</p></li><li><p>作文：何凯文作文写作高分攻略。</p><p><a href="https://mp.weixin.qq.com/s/fKKHFvLSLzT7tjfTGPmahQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fKKHFvLSLzT7tjfTGPmahQ</a></p><p>潘赟。九宫格的方法。</p><blockquote><p>将作文分类，写出模板，以及一些事物好坏的好句。</p></blockquote></li></ul><p>3月-6月底：</p><p>单词和句子。</p><p>至少要背完一本单词书一遍。</p><p>7-8月底：</p><p>可以开始做阅读。推荐从97年的真题开始做，同时配着阅读的视频学习。</p><p>两个要点：</p><p>阅读思路的总结（比如细节事实题、推理判断题之类）。</p><p>阅读材料的学习（把每篇文章中比较难的句子抄下来进行翻译，然后对照标准翻译来修改）。</p><p>9-10月底：</p><p>继续完成历年真题阅读。近五年的真题不要做。</p><p>十月开始学习作文。</p><p>11月-12月底：</p><p>做五年真题来模拟考试。花一下午三小时去模拟。再把历年的新题型和完型做掉。每周大小作文各两篇。</p><h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><p>多关心国家大事。</p><p>9月-10月：</p><ul><li><p>大概暑假后期的时候就可以看徐涛的强化课程。</p></li><li><p>要听完一节课之后及时做1000题。</p></li><li><p>听课顺序是马原、史纲、毛中特，思修可以不听。</p></li><li><p>选择题：肖秀荣1000题+风中劲草核心考点、肖秀荣知识点精讲精练（工具书 只当字典别细看）</p><p>快速看一章风中劲草-&gt;做1000题并认真看答案解析-&gt;看一遍本章核心考点</p><p>每天2h左右。</p><p>再刷一遍1000题，重点是错题。然后再穿插看一遍风中劲草核心考点。</p><blockquote><p>努力把知识体系化。</p></blockquote></li></ul><p>11月-12月：</p><ul><li><p>12月中旬有肖秀荣的南京预测3小时。</p></li><li><p>简答题：肖秀荣8套卷、肖秀荣4套卷、肖秀荣形势与政策、新东方预测20题</p><blockquote><p>记住每道题答题的框架，即关键句。</p></blockquote></li></ul><p>政治每年规律是一般单选4A4B4C4D的，顶多一两个偏差，今年也是如此。近几年多选一般有两个左右二选的，五个左右四选的，其他都是三选。把握这个规律包括英语阅读的可以做完自己检查用，当然只是个参考。</p><h2 id="专业"><a href="#专业" class="headerlink" title="专业"></a>专业</h2><p>数据结构：</p><p>目标院校要求的教材。</p><p>高分笔记系列，配合王道。</p><p>1800题 （算法与数据结构考研试题精析）。</p><p>真题。</p><p>算法导论可行？</p><p>3-6月底：</p><p>每天至少都要有1个小时到2个小时的时间进行复习。这个阶段是打基础最好的时间，具体方法就是高分笔记或者考研复习指导其中一本书或者两本书，我建议是高分笔记，比较容易入门。配合着网易云或者网上很多的视频资源，基本上2个月就能掌握一本书。</p><p>7-8月底 ：</p><p>做第一遍真题（留着近三年的试卷下来进行模考）和总结做题流程。</p><p>真题是最重要的参考卷，不仅可以看到题型，还可以总结出出题规律。什么题目必考在你做真题就可以看出来。</p><p>开始总结自己的做题方法。比如时间复杂度怎么求，每个外部排序方式的时间复杂度，还有最开始说的已知两种二叉树遍历序列求另一种序列等等。当你做了一定的题量以后，一定要学会做总结，每种题目要怎么解，怎么样求比较快。</p><p>9-11底：</p><p>刷题，刷题，刷题。真题二刷。</p><p>做留着的近三年试卷，每周一套，按照严格的考研时间进行模考。除了真题之外，数据结构1800题，真题甚至是看过书的习题，都可以拿出来再刷一遍。</p><p>错题本很重要，把真题和经常错的题目整理出来，与总结的解题步骤放在一起。</p><p>这时候可以配合严版的教材和习题一起展开了，特别是在排序和查找之前的章节。这个时候你有了一定的代码积累，再看严版教材就不会有太多的困难。要注意严版教材配套的习题，基础的一定要会，网上也有很多这本书配套的视频，可以自己搜索来看看。</p><p>12月：</p><p>错题本和笔记就可以拿出来一遍一遍的看。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT题集</title>
    <link href="/2019/02/01/PAT%E9%A2%98%E9%9B%86/"/>
    <url>/2019/02/01/PAT%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="PAT-Advanced-Level"><a href="#PAT-Advanced-Level" class="headerlink" title="PAT Advanced Level"></a>PAT Advanced Level</h2><ol><li>具有充分的英文阅读理解能力；</li><li>理解并掌握基础数据结构，包括：线性表、树、图；</li><li>理解并熟练编程实现经典高级算法，包括哈希映射、并查集、最短路径、拓扑排序、关键路径、贪心、深度优先搜索、广度优先搜索、回溯剪枝等；</li><li>具备较强的问题抽象和建模能力，能实现对复杂实际问题的模拟求解。</li></ol><p>1、排序：快速排序，直接插入排序，希尔排序，分治排序，堆排序。</p><p>2、图论：拓扑排序(好像没考过)、最短路径、深度搜索、广度搜索。</p><p>3、树：树的遍历、完全二叉树、AVL,CBT,BST。</p><p>4、其他：并查集，模拟，哈希(二次探测一次，简单hash多次)、背包(一次)，lcs（一次），最大子和（一次）,set(一次)，1057（分块搜索）</p><h2 id="一些东西"><a href="#一些东西" class="headerlink" title="一些东西"></a>一些东西</h2><h3 id="整行读入字符串"><a href="#整行读入字符串" class="headerlink" title="整行读入字符串"></a>整行读入字符串</h3><pre><code class="hljs c++"><span class="hljs-built_in">string</span> str;getline(<span class="hljs-built_in">cin</span>,str);<span class="hljs-comment">//读入string</span><span class="hljs-keyword">char</span> str2[<span class="hljs-number">1024</span>];<span class="hljs-built_in">cin</span>.getline(str2,<span class="hljs-number">1024</span>);<span class="hljs-comment">//读入char数组</span></code></pre><h3 id="string-erase"><a href="#string-erase" class="headerlink" title="string::erase"></a>string::erase</h3><p>erase(pos,n)：</p><p>删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符。</p><p>erase(position)：</p><p>删除position处的一个字符(position是个string类型的迭代器)。</p><p>erase(first,last)：</p><p>删除从first到last之间的字符（first和last都是迭代器）。</p><h2 id="记模板"><a href="#记模板" class="headerlink" title="记模板"></a>记模板</h2><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><blockquote><p>gcd(a,b)=gcd(b,a mod b)​</p></blockquote><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a&lt;b)&#123;<span class="hljs-keyword">int</span> temp;temp=a;a=b;b=temp;&#125;<span class="hljs-comment">//使a&gt;=b</span>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">return</span> gcd(b,a%b);&#125;</code></pre><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><h4 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h4><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=n;k++)    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)    dis[i][j]=dis[i][j]||(dis[i][k]&amp;&amp;dis[k][j]);</code></pre><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to,cost;&#125;;<span class="hljs-built_in">vector</span>&lt;edge&gt;v[<span class="hljs-number">1010</span>];<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;p;<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">fill</span>(dis+<span class="hljs-number">1</span>,dis+n+<span class="hljs-number">1</span>,INF);    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    priority_queue&lt;p,<span class="hljs-built_in">vector</span>&lt;p&gt;,greater&lt;p&gt; &gt;q;    q.push(p(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        p temp=q.top();        q.pop();        <span class="hljs-keyword">int</span> w=temp.first;<span class="hljs-keyword">int</span> id=temp.second;        <span class="hljs-keyword">if</span>(vid[id])<span class="hljs-keyword">continue</span>;        vis[id]=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)        &#123;            edge &amp;e=v[id][i];            <span class="hljs-keyword">if</span>(w+e.cost&lt;dis[e.to])            &#123;                dis[e.to]=w+e.cost;                q.push(p(dis[e.to],e.to));            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dp[<span class="hljs-number">20</span>][state];<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-comment">/*state变量*/</span>,<span class="hljs-keyword">bool</span> lead,<span class="hljs-keyword">bool</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[pos][state];    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)    &#123;        <span class="hljs-keyword">if</span>() ...        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>()...        ans+=dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-comment">/*状态转移*/</span>,lead &amp;&amp; i==<span class="hljs-number">0</span>,limit &amp;&amp; i==a[pos])    &#125;    <span class="hljs-keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][state]=ans;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        a[pos++]=x%<span class="hljs-number">10</span>;        x/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-comment">/*一系列状态 */</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> le,ri;    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;le,&amp;ri))    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(ri)-solve(le<span class="hljs-number">-1</span>));    &#125;&#125;</code></pre><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>（下标都从1开始）</p><h4 id="区间查询-单点修改"><a href="#区间查询-单点修改" class="headerlink" title="区间查询 单点修改"></a>区间查询 单点修改</h4><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> d[<span class="hljs-number">500010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//查询前缀和</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        res+=d[x];        x-=lowbit(x);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span><span class="hljs-comment">//单点修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(x&lt;=n)    &#123;        d[x]+=v;        x+=lowbit(x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,x,y,ope;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        add(i,x);    &#125;    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;ope,&amp;x,&amp;y);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)add(x,y);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">2</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,query(y)-query(x<span class="hljs-number">-1</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="单点查询-区间修改"><a href="#单点查询-区间修改" class="headerlink" title="单点查询 区间修改"></a>单点查询 区间修改</h4><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> c[<span class="hljs-number">500010</span>];<span class="hljs-comment">//差分数组</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//单点查询</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        res+=c[x];        x-=lowbit(x);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span><span class="hljs-comment">//区间修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(x&lt;=n)    &#123;        c[x]+=v;        x+=lowbit(x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,x,y,k,ope,ls;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(c));    ls=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        add(i,x-ls);        ls=x;    &#125;    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;ope);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;k);            add(x,k);            add(y+<span class="hljs-number">1</span>,-k);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">2</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,query(x));        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="求满足条件的最大值"><a href="#求满足条件的最大值" class="headerlink" title="求满足条件的最大值"></a>求满足条件的最大值</h4><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=maxn,ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(l&lt;=r)&#123;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(judge(mid))ans=mid,l=mid+<span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;</code></pre><h4 id="求满足条件的最小值"><a href="#求满足条件的最小值" class="headerlink" title="求满足条件的最小值"></a>求满足条件的最小值</h4><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=maxn,ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(l&lt;=r)&#123;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(judge(mid))ans=mid,r=mid<span class="hljs-number">-1</span>;    <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;</code></pre><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><pre><code class="hljs c++"><span class="hljs-keyword">int</span> par[<span class="hljs-number">1010</span>],high[<span class="hljs-number">1010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        par[i]=i;        high[i]=<span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> par[x]=<span class="hljs-built_in">find</span>(par[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    x=<span class="hljs-built_in">find</span>(x);    y=<span class="hljs-built_in">find</span>(y);    <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(high[x]&lt;high[y])par[x]=y;   <span class="hljs-comment">//启发式合并</span>    <span class="hljs-keyword">else</span>    &#123;        par[y]=x;        <span class="hljs-keyword">if</span>(high[x]==high[y])high[x]++;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);&#125;</code></pre><h3 id="优先队列的优先级设置"><a href="#优先队列的优先级设置" class="headerlink" title="优先队列的优先级设置"></a>优先队列的优先级设置</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fruit</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-built_in">string</span> name;    <span class="hljs-keyword">double</span> price;&#125;f1,f2,f3; <span class="hljs-comment">//定义三个结构体变量</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(fruit f1, fruit f2)</span> <span class="hljs-comment">//重载括号</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> f1.price&lt;f2.price; <span class="hljs-comment">//等同于less</span>    &#125;&#125;;调用：priority_queue&lt;fruit,<span class="hljs-built_in">vector</span>&lt;fruit&gt;,cmp&gt;q;</code></pre><h3 id="AVL的插入"><a href="#AVL的插入" class="headerlink" title="AVL的插入"></a>AVL的插入</h3><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">int</span> high;    node *left,*right;    node(<span class="hljs-keyword">int</span> x)    &#123;        val=x;high=<span class="hljs-number">0</span>;        left=right=<span class="hljs-literal">NULL</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gethigh</span><span class="hljs-params">(node *temp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(temp==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> temp-&gt;high;&#125;<span class="hljs-function">node* <span class="hljs-title">SingleRotateLL</span><span class="hljs-params">(node *root)</span></span><span class="hljs-function"></span>&#123;    node *temp;    temp=root-&gt;left;    root-&gt;left=temp-&gt;right;    temp-&gt;right=root;    root-&gt;high=<span class="hljs-built_in">max</span>(gethigh(root-&gt;left),gethigh(root-&gt;right))+<span class="hljs-number">1</span>;     <span class="hljs-comment">//更新高度</span>    temp-&gt;high=<span class="hljs-built_in">max</span>(gethigh(temp-&gt;left),gethigh(temp-&gt;right))+<span class="hljs-number">1</span>;         <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function">node *<span class="hljs-title">SingleRotateRR</span><span class="hljs-params">(node *root)</span></span><span class="hljs-function"></span>&#123;    node *temp;    temp=root-&gt;right;    root-&gt;right=temp-&gt;left;    temp-&gt;left=root;    root-&gt;high=<span class="hljs-built_in">max</span>(gethigh(root-&gt;left),gethigh(root-&gt;right))+<span class="hljs-number">1</span>; <span class="hljs-comment">//更新高度</span>    temp-&gt;high=<span class="hljs-built_in">max</span>(gethigh(temp-&gt;left),gethigh(temp-&gt;right))+<span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function">node *<span class="hljs-title">DoubleRotateLR</span><span class="hljs-params">(node *root)</span></span><span class="hljs-function"></span>&#123;    root-&gt;left=SingleRotateRR(root-&gt;left);    <span class="hljs-keyword">return</span> SingleRotateLL(root);&#125;<span class="hljs-function">node *<span class="hljs-title">DoubleRotateRL</span><span class="hljs-params">(node *root)</span></span><span class="hljs-function"></span>&#123;    root-&gt;right=SingleRotateLL(root-&gt;right);    <span class="hljs-keyword">return</span> SingleRotateRR(root);&#125;<span class="hljs-function">node* <span class="hljs-title">Insert</span><span class="hljs-params">(node *root,<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> node(x);&#125;    <span class="hljs-keyword">if</span>(x&lt;root-&gt;val)    &#123;        root-&gt;left=Insert(root-&gt;left,x);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(gethigh(root-&gt;left)-gethigh(root-&gt;right))&gt;<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">if</span>(x&lt;root-&gt;left-&gt;val)                root=SingleRotateLL(root);            <span class="hljs-keyword">else</span>                root=DoubleRotateLR(root);        &#125;    &#125;    <span class="hljs-keyword">else</span>    &#123;        root-&gt;right=Insert(root-&gt;right,x);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(gethigh(root-&gt;left)-gethigh(root-&gt;right))&gt;<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">if</span>(x&gt;root-&gt;right-&gt;val)                root=SingleRotateRR(root);            <span class="hljs-keyword">else</span>                root=DoubleRotateRL(root);        &#125;    &#125;    root-&gt;high=<span class="hljs-built_in">max</span>(gethigh(root-&gt;left),gethigh(root-&gt;right))+<span class="hljs-number">1</span>; <span class="hljs-comment">//更新高度</span>    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    node *root=<span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">while</span>(n--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        root=Insert(root,x);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,root-&gt;val);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="Nowcoder"><a href="#Nowcoder" class="headerlink" title="Nowcoder"></a>Nowcoder</h3><h4 id="1017"><a href="#1017" class="headerlink" title="1017"></a>1017</h4><p>求栈的中位数，包括push和pop操作。</p><p>对于求中位数，二分+树状数组。</p><h4 id="1038"><a href="#1038" class="headerlink" title="1038"></a>1038</h4><p>求1～N十进制表示中1的个数。</p><p>数位dp。</p><p>$dp[i][j]​$：长度为i已有j个1的数字中1的个数。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">bool</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> num;    <span class="hljs-keyword">if</span>(!limit&amp;&amp;dp[pos][num]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> dp[pos][num];    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)        ans+=dfs(pos<span class="hljs-number">-1</span>,i==<span class="hljs-number">1</span>?num+<span class="hljs-number">1</span>:num,limit&amp;&amp;i==up);    <span class="hljs-keyword">if</span>(!limit)dp[pos][num]=ans;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre><h4 id="1049"><a href="#1049" class="headerlink" title="1049"></a>1049</h4><p>给你一些数字的片段，希望拼接之后能拼出的最小的数字。</p><p>样例输入：5 32 321 3214 0229 87，样例输出：22932132143287。</p><p>假设有两个相邻的数字片段a,b。然后我们就要想，把a和b交换能不能使整个序列变小呢？这个问题的其实等价于b+a 是否小于a+b，也就是说对于这样一个序列，如果某两个相邻的元素之间发生交换可以使得整个序列的值变小，就应该交换。</p><p>注意00000的情况即可。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">string</span> x,<span class="hljs-built_in">string</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x+y&lt;y+x)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><h3 id="PTA"><a href="#PTA" class="headerlink" title="PTA"></a>PTA</h3><h4 id="1045"><a href="#1045" class="headerlink" title="1045"></a>1045</h4><p>有一组喜欢的数字序列，要从另一组数字里面选出最长的子序列，使得喜欢的数字序列包含在子序列中（不需要每一个都被包含）。</p><p>可以把喜欢的数字序列从小到大编号，然后在数字里选出子序列就相当于最长非递减子序列。</p><h4 id="1091"><a href="#1091" class="headerlink" title="1091"></a>1091</h4><p>如果dfs要考虑深度，避免递归深度过大爆栈。</p><p>这题<script type="math/tex">60*1280*80</script>。所以用bfs。</p><h4 id="1103"><a href="#1103" class="headerlink" title="1103"></a>1103</h4><p>给出N，K，P，使得<script type="math/tex">N = n[1]^P + ... n[K]^P</script>。输出的方案首先<script type="math/tex">n[1]+n[2]+…n[k]</script>最大然后字典序最大。</p><p>dfs。注意写法。</p><p>dfs里面不要用循环写，因为要字典序最大，肯定是从最大的数开始枚举。</p><pre><code class="hljs c++">dfs(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> now, <span class="hljs-keyword">int</span> cnt, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> path[])转移：<span class="hljs-keyword">if</span>(now+a[id]&lt;=n)    &#123;        path[cnt + <span class="hljs-number">1</span>] = id;        dfs(id,now + a[id], cnt + <span class="hljs-number">1</span>, sum + id, path);    &#125;    <span class="hljs-keyword">if</span>(id<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>)        dfs(id<span class="hljs-number">-1</span>,now,cnt,sum,path);调用：dfs(a[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, pp);</code></pre><h4 id="1123"><a href="#1123" class="headerlink" title="1123"></a>1123</h4><p>判断是不是完全二叉树。当某个节点的儿子有为空的以后，出现子节点不为空的则说明不是完全二叉树，否则是。</p><h4 id="1135"><a href="#1135" class="headerlink" title="1135"></a>1135</h4><p>给出一个二叉查找树的前序遍历序列，判断该树是不是红黑树。</p><p>已知红黑树满足以下性质：</p><p>（1）每个结点要么是红的要么是黑的。</p><p>（2）根结点是黑的。 </p><p>（3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。 </p><p>（4）如果一个结点是红的，那么它的两个儿子都是黑的。 </p><p>（5）对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。</p><p>这道题debug了好久…一直有几个点过不去，然后看题解发现是自己不清楚红黑树的定义。它的叶子并不是我之前所想的叶子。</p><p>如图是一棵红黑树：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g0jsxaj9ifj30m80apaaf.jpg" srcset="/img/loading.gif" alt=""></p><p>此图忽略了叶子和根部的父结点。同时，上文中我们所说的 “叶结点” 或”NULL结点”，如上图所示，它不包含数据而只充当树在此结束的指示，这些节点在绘图中经常被省略。</p><p>然后改一下写的代码就可以过了。</p><h4 id="1139"><a href="#1139" class="headerlink" title="1139"></a>1139</h4><p>A想要联系B需要这样的步骤：A先找一个同性朋友C，再让C找一个与B同性且同时是C和B的D，由D联系B。现给出一些关系，给出A和B，输出可能的联系的方案，即输出C和D。编号都用四位数表示。          </p><p>本来想的是DFS，这样会超时，其实已经规定了深度为4，所以只要枚举A的同性朋友C和B的同性朋友D，判断C和D是否是朋友即可。因为这里N最大为300，所以根据复杂度知道可行。</p><p>这里还有一些坑，比如男女用+-来表示，如果直接用int来接收的话，如果出现-0000就没法判断到底是+还是-了。还有输出的时候应该要<strong>%04d</strong>（注意！！！）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O调度</title>
    <link href="/2018/12/04/I-O%E8%B0%83%E5%BA%A6/"/>
    <url>/2018/12/04/I-O%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>​    每个块设备或者块设备的分区，都对应有自身的请求队列，而每个请求队列都可以选择一个I/O调度器来协调所递交的request。I/O调度器的基本目的是将请求按照它们对应在块设备上的扇区号进行排列，以减少磁头的移动，提高效率。每个设备的请求队列里的请求将按顺序被响应。实际上，除了这个队列，每个调度器自身都维护有不同数量的队列，用来对递交上来的request进行处理，而排在队列最前面的request将适时被移动到请求队列中等待响应。</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="CFQ"><a href="#CFQ" class="headerlink" title="CFQ"></a>CFQ</h4><p>​    CFQ（Completely Fair Queuing）算法，顾名思义，绝对公平算法。它试图为竞争块设备使用权的所有进程分配一个请求队列和一个时间片，在调度器分配给进程的时间片内，进程可以将其读写请求发送给底层块设备，当进程的时间片消耗完，进程的请求队列将被挂起，等待调度。 </p><p>​    每个进程的时间片和每个进程的队列长度取决于进程的IO优先级，每个进程都会有一个IO优先级，CFQ调度器将会将其作为考虑的因素之一，来确定该进程的请求队列何时可以获取块设备的使用权。IO优先级从高到低可以分为三大类:RT(real time),BE(best try),IDLE(idle),其中RT和BE又可以再划分为8个子优先级。实际上，我们已经知道CFQ调度器的公平是针对于进程而言的，而只有同步请求(read或syn write)才是针对进程而存在的，他们会放入进程自身的请求队列，而所有同优先级的异步请求，无论来自于哪个进程，都会被放入公共的队列，异步请求的队列总共有8(RT)+8(BE)+1(IDLE)=17个。                              </p><p>​    从Linux 2.6.18起，CFQ作为默认的IO调度算法。</p><p>​    对于通用的服务器来说，CFQ是较好的选择。</p><h4 id="Deadline"><a href="#Deadline" class="headerlink" title="Deadline"></a>Deadline</h4><p>​    Deadline使用了两种不同的数据结构来管理请求：排序队列是基于红黑树的，根据请求的块号排序；FIFO队列使用双向链表，按照请求到达的顺序排列。</p><p>​    Deadline把请求按照读写方向分成两类。同时维持4个队列：两个排序队列以及两个FIFO队列，根据读写方向把请求放置到对应的排序队列和 FIFO队列中。</p><p>​    在分派请求的过程中，Deadline首先选择一个排序队列(读或者写)，按照扇区号由小到大的顺序分派16(可以通过fifo_batch修改)请求。请求的分派过程类似于磁盘的C—SCAN调度策略。当该排序队列已经没有请求可以分派，Deadline选择另一个方向的排序队列进行分派。选择队列时的方向默认为读，只有写请求队列被忽略2次(Writes_starved)后，算法才会选择写请求队列。Deadline把读和写分开处理，且读请求的优先级高于写请求，是因为读请求一般是同步的，可以阻塞进程的运行，而写请求大多是系统在空闲时才发的(例如脏页的回写)，适当的延迟对系统整体性能影响不大。</p><p>1）读写请求分离，读请求具有高优先调度权，除非写请求即将被饿死的时候，才会去调度处理写请求。这种处理可以保证读请求的延迟时间最小化。</p><p>2）对请求的顺序批量处理。对那些地址临近的顺序化请求，deadline给予了高优先级处理权。例如一个写请求得到调度后，其临近的request会在紧接着的调度过程中被处理掉。这种顺序批量处理的方法可以最大程度的减少磁盘抖动。</p><p>3）保证每个请求的延迟时间。每个请求都赋予了一个最大延迟时间，如果达到延迟时间的上限，那么这个请求就会被提前处理掉，此时，会破坏磁盘访问的顺序化特征，回影响性能，但是，保证了每个请求的最大延迟时间。</p><h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><h4 id="CFQ-1"><a href="#CFQ-1" class="headerlink" title="CFQ"></a>CFQ</h4><p>​    由于缺乏Linux电梯框架提供的信息，CFQ<u>无法正确地将请求映射到进程</u>导致不公平。此外，<u>文件系统排序要求限制了CFQ的重新排序选项，从而导致优先级倒置。</u>为了克服这两个缺点，我们引入了AFQ（实际公平队列调度程序），以根据优先级在进程间公平地分配I/O。</p><h4 id="Deadline-1"><a href="#Deadline-1" class="headerlink" title="Deadline"></a>Deadline</h4><p>​    由于<u>在文件系统排序要求存在时无法重新排序块I/O</u>，所以Block-Deadline在试图限制尾部延迟时表现得很差。</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><h4 id="AFQ"><a href="#AFQ" class="headerlink" title="AFQ"></a>AFQ</h4><p>​    AFQ采用两级调度策略。读取在块级处理，写入在系统调用级别处理。这种设计允许读取命中高速缓存，同时保护写入不受日志纠缠的影响。</p><p>​    <strong>命中高速缓存：</strong></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fxw8bcqfdfj30nc0x0q65.jpg" srcset="/img/loading.gif" alt=""></p><p>​    块级可以应用程序-&gt;缓存-&gt;文件系统-&gt;块级队列，就可以实现对于缓存的读取。直接系统调用是应用程序-&gt;块级队列，无法读取缓存。</p><p>​    <strong>写入不受日志纠缠：</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxw8goz8fej305h01zmwz.jpg" srcset="/img/loading.gif" alt=""></p><p>​    如果用块级调用的话，日志会以为p3(p1、p2的回写代理）把DataPage弄脏了，事实上是p1、p2弄脏的。</p><h4 id="Deadline-2"><a href="#Deadline-2" class="headerlink" title="Deadline"></a>Deadline</h4><p>​    Split-Deadline使用缓冲区脏钩子监视一个缓存文件的脏污程度，从而估算fsync的成本。如果存在可能通过导致过多I / O而影响其他进程的fsync挂起，则不会直接调度。相反，调度程序要求内核启动文件脏数据的异步写回，并等待，直到脏数据量下降到一定程度，以便发出的fsync不会影响其他截止日期。异步写回不会生成文件系统同步点，也没有截止日期，因此不会强制其他操作等待。</p><blockquote><p>所谓同步，就是调用后直到返回结果，程序才继续往下运行。</p><p>异步，就是调用后立刻执行之后的代码。调用的结果以事件/委托在不确定的一段时间以后才返回。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的一些常识</title>
    <link href="/2018/11/15/%E5%85%B3%E4%BA%8E%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%AF%86/"/>
    <url>/2018/11/15/%E5%85%B3%E4%BA%8E%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="树上与某个结点的距离为k的结点个数"><a href="#树上与某个结点的距离为k的结点个数" class="headerlink" title="树上与某个结点的距离为k的结点个数"></a>树上与某个结点的距离为k的结点个数</h3><p>首先一次dfs处理出每个结点的子树中和它距离为k的结点个数<script type="math/tex">num[i][k]</script>。</p><p>之后再从根开始dfs根据当前结点和父结点的距离计算答案，比如当前结点和父结点的距离为2，由于父结点已经处理出答案了，那么与当前结点距离为k的结点个数为<script type="math/tex">ans[fa][k-2]-num[now][k-4]+num[now][k]​</script>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈打表</title>
    <link href="/2018/11/14/%E5%8D%9A%E5%BC%88%E6%89%93%E8%A1%A8/"/>
    <url>/2018/11/14/%E5%8D%9A%E5%BC%88%E6%89%93%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>利用这个性质：后续有必败态的当前一定是必胜态。</p><h3 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h3><p>有N颗石子，A先手，第一次他可以拿1～n-1个石子。后面拿的时候一定是1～2*上一次拿的石子数。拿到最后一颗石子的人是赢家。</p><p>打表：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum,<span class="hljs-keyword">int</span> pre)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//没有石子当前为必败态</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*pre&amp;&amp;i&lt;=sum;i++)    &#123;        <span class="hljs-keyword">if</span>(dfs(sum-i,i)==<span class="hljs-literal">false</span>)<span class="hljs-comment">//后面有一个是必败态</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//当前为必胜态</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n=<span class="hljs-number">2</span>;n&lt;=<span class="hljs-number">30</span>;n++)    &#123;        <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n&amp;&amp;sign==<span class="hljs-number">0</span>;i++)        &#123;            <span class="hljs-keyword">if</span>(dfs(n-i,i)==<span class="hljs-literal">false</span>)<span class="hljs-comment">//后手败</span>            &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:first %d\n"</span>,n,i);                sign++;            &#125;        &#125;        <span class="hljs-keyword">if</span>(sign==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:second\n"</span>,n);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="Gym101775L"><a href="#Gym101775L" class="headerlink" title="Gym101775L"></a>Gym101775L</h3><p>有1*n的方格，每个人可以写S或者O，如果从左到右出现了SOS，那么最后一个写S的人赢，问最后是谁赢或者平局。</p><p>打表：</p><p>这个存状态有点东西的，用char存的而且初始化成INF…的确比用orderedmap快多了…比初始化成0也快多了…</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f</span><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> a[<span class="hljs-number">35</span>];  <span class="hljs-comment">//s:1,o:2</span><span class="hljs-keyword">char</span> mp[<span class="hljs-number">1000000000</span>];<span class="hljs-function">ull <span class="hljs-title">calc</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ull temp=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        temp=temp*<span class="hljs-number">3</span>+<span class="hljs-number">1l</span>l*a[i];    <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i+<span class="hljs-number">2</span>&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>&amp;&amp;a[i+<span class="hljs-number">1</span>]==<span class="hljs-number">2</span>&amp;&amp;a[i+<span class="hljs-number">2</span>]==<span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,a[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>)</span></span><span class="hljs-function"></span>&#123;    ull sta=calc();    <span class="hljs-keyword">if</span>(mp[sta]^INF)<span class="hljs-keyword">return</span> mp[sta];    <span class="hljs-keyword">if</span>(check())   <span class="hljs-comment">//必败态</span>    &#123;        mp[sta]=<span class="hljs-number">-1</span>;        <span class="hljs-comment">/*show();</span><span class="hljs-comment">        printf("%llu:-1\n",sta);*/</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">step</span>==n+<span class="hljs-number">1</span>)    &#123;        <span class="hljs-comment">/*show();</span><span class="hljs-comment">        printf("%llu:0\n",sta);*/</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//平局</span>    &#125;    <span class="hljs-keyword">bool</span> ex0=<span class="hljs-literal">false</span>;  <span class="hljs-comment">//后续是否存在平局</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;j++)        &#123;            a[i]=j;            <span class="hljs-keyword">int</span> temp=dfs(<span class="hljs-built_in">step</span>+<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(temp==<span class="hljs-number">-1</span>)    <span class="hljs-comment">//后续存在必败态</span>            &#123;                mp[sta]=<span class="hljs-number">1</span>;  <span class="hljs-comment">//当前肯定是必胜态</span>                a[i]=<span class="hljs-number">0</span>;                <span class="hljs-comment">/*show();</span><span class="hljs-comment">                printf("%llu:1\n",sta);*/</span>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">if</span>(temp==<span class="hljs-number">0</span>)ex0=<span class="hljs-literal">true</span>;            a[i]=<span class="hljs-number">0</span>;     <span class="hljs-comment">//恢复标记</span>        &#125;    &#125;    <span class="hljs-keyword">if</span>(ex0)    &#123;        mp[sta]=<span class="hljs-number">0</span>;        <span class="hljs-comment">/*show();</span><span class="hljs-comment">        /printf("%llu:0\n",sta);*/</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    mp[sta]=<span class="hljs-number">-1</span>;    <span class="hljs-comment">/*show();</span><span class="hljs-comment">    printf("%llu:-1\n",sta);*/</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(n=<span class="hljs-number">1</span>;n&lt;=<span class="hljs-number">30</span>;n++)    &#123;        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));        <span class="hljs-built_in">memset</span>(mp,INF,<span class="hljs-keyword">sizeof</span>(mp));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:%d\n"</span>,n,dfs(<span class="hljs-number">1</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-SAT</title>
    <link href="/2018/11/11/2-SAT/"/>
    <url>/2018/11/11/2-SAT/</url>
    
    <content type="html"><![CDATA[<p>1.首先利用⇒(蕴含)将每一个子句<script type="math/tex">a∨b</script>改写成等价的<script type="math/tex">(¬a⇒b)∧(¬b⇒a)</script>。</p><p>可以给第 i个变量标号为 i，其对应的反值标号为i+n。</p><div class="table-container"><table><thead><tr><th style="text-align:center">原式</th><th style="text-align:center">建图</th></tr></thead><tbody><tr><td style="text-align:center"><script type="math/tex">¬a∨b</script></td><td style="text-align:center"><script type="math/tex">a→b∧¬b→¬a</script></td></tr><tr><td style="text-align:center"><script type="math/tex">a∨b</script></td><td style="text-align:center"><script type="math/tex">¬a→b∧¬b→a</script></td></tr><tr><td style="text-align:center"><script type="math/tex">¬a∨¬b</script></td><td style="text-align:center"><script type="math/tex">a→¬b∧b→¬a</script></td></tr></tbody></table></div><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fx4aedrt60j30ab09haa6.jpg" srcset="/img/loading.gif" alt="built"></p><p>2.如果a点能够到达b点，就表示当a为真时b也为真。因此图中的同一个强联通分量中的所有布尔值均相同。也就是说，如果x与¬x在同一强连通分量内部，一定无解。反之，就一定有解了。</p><p>3.当x所在的强连通分量的拓扑序在¬x所在的强连通分量的拓扑序之后取x为真 就可以了。在使用Tarjan算法缩点找强连通分量的过程中，已经为每组强连通分量标记好顺序了。不过是反着的拓扑序。所以一定要写成<script type="math/tex">sccn[x]<sccn[-x]</script>。</p><p>时间复杂度：<script type="math/tex">O(N+M)</script></p><p>模板：</p><p>有n个布尔变量<script type="math/tex">x_1～x_n</script>，另有m个需要满足的条件，每个条件的形式都是”<script type="math/tex">x_i</script>为true/false或<script type="math/tex">x_j</script>为true/false”。给每个变量赋值使得所有条件得到满足。</p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">2000010</span>];<span class="hljs-keyword">int</span> dfn[<span class="hljs-number">2000010</span>];<span class="hljs-comment">//在DFS中该节点被搜索的次序</span><span class="hljs-keyword">int</span> low[<span class="hljs-number">2000010</span>];<span class="hljs-comment">//i或i的子树能够通过非树边追溯到最早的祖先节点（即DFS次序号最小）</span><span class="hljs-keyword">int</span> sccn[<span class="hljs-number">2000010</span>];<span class="hljs-comment">//缩点数组，表示某个点对应的强连通分量编号</span><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">2000010</span>];<span class="hljs-comment">//是否在栈中</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>;<span class="hljs-keyword">int</span> cnt;<span class="hljs-comment">//强连通分量编号</span><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;s;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><span class="hljs-function"></span>&#123;    dfn[u]=low[u]=++<span class="hljs-built_in">step</span>;    vis[u]=<span class="hljs-literal">true</span>;    s.push(u);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[u].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[u][i];        <span class="hljs-keyword">if</span>(!dfn[temp])<span class="hljs-comment">//没有被访问过</span>        &#123;            tarjan(temp);            low[u]=<span class="hljs-built_in">min</span>(low[u],low[temp]);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[temp])<span class="hljs-comment">//在栈中</span>            low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[temp]);    &#125;    <span class="hljs-keyword">if</span>(low[u]==dfn[u])<span class="hljs-comment">//构成强连通分量</span>    &#123;        cnt++;        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">int</span> temp=s.top();            s.pop();<span class="hljs-comment">//此点以上的点全部出栈，构成一个强连通分量</span>            vis[temp]=<span class="hljs-literal">false</span>;            sccn[temp]=cnt;<span class="hljs-comment">//cnt是强连通分量的序号</span>            <span class="hljs-keyword">if</span>(temp==u)<span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,a,va,b,vb;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;a,&amp;va,&amp;b,&amp;vb);        v[a+n*(va&amp;<span class="hljs-number">1</span>)].push_back(b+n*(vb^<span class="hljs-number">1</span>));        v[b+n*(vb&amp;<span class="hljs-number">1</span>)].push_back(a+n*(va^<span class="hljs-number">1</span>));    &#125;    <span class="hljs-built_in">step</span>=cnt=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(dfn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dfn));    <span class="hljs-built_in">memset</span>(sccn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sccn));    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;i++)        <span class="hljs-keyword">if</span>(!dfn[i])            tarjan(i);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(sccn[i]==sccn[i+n])        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"IMPOSSIBLE\n"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"POSSIBLE\n"</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,sccn[i]&lt;sccn[i+n]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCPC2014C 双调欧几里得旅行商问题</title>
    <link href="/2018/11/04/GCPC2014C-%E5%8F%8C%E8%B0%83%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"/>
    <url>/2018/11/04/GCPC2014C-%E5%8F%8C%E8%B0%83%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出二维平面上的n个点，现在从最左端出发，到达最右端的点，再返回最左端的点，要求遍历所有点且路程最短。</p><p><strong>思路：</strong></p><p>这是一个双调欧几里得旅行商问题。双线程dp。</p><p><script type="math/tex">dp[i][j]</script>：快的人走到i，慢的人走到j的最短路程(i&gt;j)。</p><p>对于当前点，要不在走得快的人走的边上，要不在走得慢的人走的边上。</p><p>有状态转移方程：</p><p>在走得快的人走的边上：</p><p><script type="math/tex">dp[i+1][j]=min(dp[i+1][j],dp[i][j]+dis(i,i+1))</script>。</p><p>在走得慢的人走的边上：</p><p><script type="math/tex">dp[i+1][i]=min(dp[i+1][i],dp[i][j]+dis(j,i+1))</script>。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> x,y;&#125;p[<span class="hljs-number">530</span>];<span class="hljs-keyword">double</span> dp[<span class="hljs-number">530</span>][<span class="hljs-number">530</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a,<span class="hljs-built_in">point</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> a.x&lt;b.x;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a,<span class="hljs-built_in">point</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span>*(a.x-b.x)*(a.x-b.x)+<span class="hljs-number">1.0</span>*(a.y-b.y)*(a.y-b.y));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;p[i].x,&amp;p[i].y);        sort(p,p+n,cmp);        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x7f</span>,<span class="hljs-keyword">sizeof</span>(dp));        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            dp[i][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+dis(p[i],p[i<span class="hljs-number">-1</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)            &#123;                dp[i+<span class="hljs-number">1</span>][j]=<span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i][j]+dis(p[i],p[i+<span class="hljs-number">1</span>]));                dp[i+<span class="hljs-number">1</span>][i]=<span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][i],dp[i][j]+dis(p[j],p[i+<span class="hljs-number">1</span>]));            &#125;        <span class="hljs-keyword">double</span> ans=<span class="hljs-number">1e18</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)            ans=<span class="hljs-built_in">min</span>(ans,dp[n<span class="hljs-number">-1</span>][i]+dis(p[i],p[n<span class="hljs-number">-1</span>]));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2f\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树上差分</title>
    <link href="/2018/10/30/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    <url>/2018/10/30/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>参考博客：</p><p><a href="https://www.cnblogs.com/ice-wing/p/7709311.html" target="_blank" rel="noopener">https://www.cnblogs.com/ice-wing/p/7709311.html</a></p><p><a href="https://www.luogu.org/blog/sincereactor/shu-shang-ci-fen-di-liang-zhong-sai-lu" target="_blank" rel="noopener">https://www.luogu.org/blog/sincereactor/shu-shang-ci-fen-di-liang-zhong-sai-lu</a></p><p><a href="https://blog.csdn.net/Fine_rose/article/details/77991839" target="_blank" rel="noopener">https://blog.csdn.net/Fine_rose/article/details/77991839</a></p><p><a href="https://blog.csdn.net/ArliaStark/article/details/80720181" target="_blank" rel="noopener">https://blog.csdn.net/ArliaStark/article/details/80720181</a></p><h3 id="已知路径求被所有路径覆盖的边"><a href="#已知路径求被所有路径覆盖的边" class="headerlink" title="已知路径求被所有路径覆盖的边"></a>已知路径求被所有路径覆盖的边</h3><p>首先对已知的这 n 条路径的起点a和终点b的权值+1，并对lca(a,b)的权值-2 。</p><p>从根节点开始深搜，回溯时将其本身的权值加上所有子节点的权值。</p><p>那么满足要求的边就是权值等于n的节点与其父节点所连的边。</p><p><strong>例题：</strong></p><h4 id="P2680"><a href="#P2680" class="headerlink" title="P2680"></a>P2680</h4><p>询问m条链中，删去一条边，使权值最大的链权值最小。</p><p>思路：</p><p>二分最大链的权值L。</p><p>对于链长小于等于L的，不用管。</p><p>对于链长大于L的，要确保删的这条边在该链上。</p><p>所以选定的这条边要被所有链长大于L的链所覆盖，在符合条件的边里选最长的那一条才最优，然后判断当前最长链-该边的权值是否小于这个二分的最大链的权值即可。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cost;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">300010</span>*<span class="hljs-number">2</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">imfo</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> a,b,lc;    <span class="hljs-keyword">int</span> len;&#125;p[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> val[<span class="hljs-number">300010</span>];<span class="hljs-comment">//i-&gt;par[i]的权值</span><span class="hljs-keyword">int</span> top;<span class="hljs-keyword">int</span> head[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> tot[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> son[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> idx[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> topp[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> par[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> dep[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> mark[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> pre[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> maxlen;<span class="hljs-keyword">int</span> cnt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> c=getchar();    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">'0'</span>||c&gt;<span class="hljs-string">'9'</span>)c=getchar();    <span class="hljs-keyword">while</span>(c&gt;=<span class="hljs-string">'0'</span>&amp;&amp;c&lt;=<span class="hljs-string">'9'</span>)x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">'0'</span>,c=getchar();    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> t)</span></span><span class="hljs-function"></span>&#123;    eg[top].to=b;    eg[top].cost=t;    eg[top].next=head[a];    head[a]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth,<span class="hljs-keyword">int</span> sum)</span></span><span class="hljs-function"></span>&#123;    dep[id]=depth;    tot[id]=<span class="hljs-number">1</span>;    dis[id]=sum;    par[id]=fa;    <span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>;    son[id]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(temp==fa)<span class="hljs-keyword">continue</span>;        val[eg[i].to]=eg[i].cost;        tot[id]+=dfs1(eg[i].to,id,depth+<span class="hljs-number">1</span>,sum+val[eg[i].to]);        <span class="hljs-keyword">if</span>(tot[temp]&gt;maxson)        &#123;            son[id]=temp;            maxson=tot[temp];        &#125;    &#125;    <span class="hljs-keyword">return</span> tot[id];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> topf)</span></span><span class="hljs-function"></span>&#123;    idx[id]=++cnt;    topp[id]=topf;    <span class="hljs-keyword">if</span>(son[id]==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;     <span class="hljs-comment">//子节点的son为0</span>    dfs2(son[id],topf);     <span class="hljs-comment">//优先标记重儿子</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(idx[temp]==<span class="hljs-number">0</span>)            dfs2(temp,temp);     <span class="hljs-comment">//每一条链以轻儿子为起点</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(topp[x]!=topp[y])    &#123;        <span class="hljs-keyword">if</span>(dep[topp[x]]&lt;dep[topp[y]])swap(x,y);     <span class="hljs-comment">//谁的top低谁就往上走</span>        x=par[topp[x]];    &#125;    <span class="hljs-keyword">if</span>(dep[x]&gt;dep[y])swap(x,y);    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calcpre</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    pre[id]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        <span class="hljs-keyword">if</span>(eg[i].to!=fa)            pre[id]+=calcpre(eg[i].to,id);    pre[id]+=mark[id];    <span class="hljs-keyword">return</span> pre[id];&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">if</span>(p[i].len&gt;x)        &#123;            mark[p[i].a]++;            mark[p[i].b]++;            mark[p[i].lc]-=<span class="hljs-number">2</span>;            num++;        &#125;    &#125;    <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    calcpre(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> MAX=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(pre[i]==num)            MAX=<span class="hljs-built_in">max</span>(MAX,val[i]);        mark[i]=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">if</span>(maxlen-MAX&lt;=x)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a,b,t;    n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)    &#123;        a=<span class="hljs-built_in">read</span>();b=<span class="hljs-built_in">read</span>();t=<span class="hljs-built_in">read</span>();        add(a,b,t);add(b,a,t);    &#125;    cnt=<span class="hljs-number">0</span>;    dfs1(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    dfs2(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);    maxlen=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        p[i].a=<span class="hljs-built_in">read</span>();p[i].b=<span class="hljs-built_in">read</span>();        p[i].lc=lca(p[i].a,p[i].b);        p[i].len=dis[p[i].a]+dis[p[i].b]<span class="hljs-number">-2</span>*dis[p[i].lc];        maxlen=<span class="hljs-built_in">max</span>(maxlen,p[i].len);    &#125;    <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=maxlen,ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(l&lt;=r)    &#123;        <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(judge(mid))ans=mid,r=mid<span class="hljs-number">-1</span>;        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="已知路径求树上所有节点被路径覆盖次数"><a href="#已知路径求树上所有节点被路径覆盖次数" class="headerlink" title="已知路径求树上所有节点被路径覆盖次数"></a>已知路径求树上所有节点被路径覆盖次数</h3><p>对每条路径的起点a和终点b的权值+1 , 对lca(a, b)的权值-1 , 对lca(a,b)的父节点权值-1。</p><p>从根节点开始深搜，回溯时将其本身的权值加上所有子节点的权值。</p><p>每个节点的权值即是其被路径覆盖的次数。</p><p><strong>例题：</strong></p><h3 id="P3258"><a href="#P3258" class="headerlink" title="P3258"></a>P3258</h3><p>给出一棵树，以及访问结点的顺序，问每个结点要访问几次，访问最后一个结点不算。</p><p>思路：裸题。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">300010</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> par[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> dep[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> tot[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> son[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> top[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> idx[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> mark[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> ans[<span class="hljs-number">300010</span>];<span class="hljs-keyword">int</span> cnt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span></span><span class="hljs-function"></span>&#123;    par[id]=fa;    dep[id]=depth;    <span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>;    son[id]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len=v[id].<span class="hljs-built_in">size</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[id][i];        <span class="hljs-keyword">if</span>(temp==fa)<span class="hljs-keyword">continue</span>;        tot[id]+=dfs1(temp,id,depth+<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(tot[temp]&gt;maxson)        &#123;            son[id]=temp;            maxson=tot[temp];        &#125;    &#125;    <span class="hljs-keyword">return</span> tot[id];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> topf)</span></span><span class="hljs-function"></span>&#123;    idx[id]=++cnt;    top[id]=topf;    <span class="hljs-keyword">if</span>(son[id]==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;    dfs2(son[id],topf);    <span class="hljs-keyword">int</span> len=v[id].<span class="hljs-built_in">size</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[id][i];        <span class="hljs-keyword">if</span>(idx[temp]==<span class="hljs-number">0</span>)dfs2(temp,temp);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(top[x]!=top[y])    &#123;        <span class="hljs-keyword">if</span>(dep[top[x]]&lt;dep[top[y]])swap(x,y);        x=par[top[x]];    &#125;    <span class="hljs-keyword">if</span>(dep[x]&gt;dep[y])swap(x,y);    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=v[id].<span class="hljs-built_in">size</span>();    ans[id]=mark[id];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[id][i];        <span class="hljs-keyword">if</span>(temp==fa)<span class="hljs-keyword">continue</span>;        ans[id]+=dfs(temp,id);    &#125;    <span class="hljs-keyword">return</span> ans[id];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);    <span class="hljs-built_in">memset</span>(idx,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(idx));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        v[x].push_back(y);        v[y].push_back(x);    &#125;    dfs1(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    cnt=<span class="hljs-number">0</span>;    dfs2(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)    &#123;        mark[a[i]]++;        mark[a[i+<span class="hljs-number">1</span>]]++;        <span class="hljs-keyword">int</span> lc=lca(a[i],a[i+<span class="hljs-number">1</span>]);        mark[lc]--;        mark[par[lc]]--;    &#125;    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(i==a[<span class="hljs-number">1</span>])<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans[i]);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans[i]<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率 &amp; 期望</title>
    <link href="/2018/10/25/%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/"/>
    <url>/2018/10/25/%E6%A6%82%E7%8E%87-%E6%9C%9F%E6%9C%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>举一个求期望最简单的例子：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwkei7xqjxj30da07fgli.jpg" srcset="/img/loading.gif" alt=""></p><p>假设有个人在 1号节点处，每一分钟他会缘着边随机走到一个节点或者在原地停留，问他走到4号节点需要平均几分钟？</p><p>这是个简单的期望问题，我们用 Ei(i=1,2,3,4) 表示从i号节点走到4号节点的数学期望值。根据题意对1号节点有 </p><p><script type="math/tex">E1=\frac{1}{3}∗(E1+1)+\frac{1}{3}∗(E2+1)+\frac{1}{3}∗(E3+1)</script> ①</p><p>表示他下一分钟可以走到2或者3或在原地1，每个可能概率是1/3 ,注意是下一分钟，故要加上1。</p><p>同理我们对节点2，3同样可以列出</p><p><script type="math/tex">E2=\frac{1}{3}∗(E1+1)+\frac{1}{3}∗(E2+1)+\frac{1}{3}∗(E4+1)</script> ② </p><p><script type="math/tex">E3=\frac{1}{3}∗(E1+1)+\frac{1}{3}∗(E3+1)+\frac{1}{3}∗(E4+1)</script> ③ </p><p>因为E4=0，这样上面1234式其实就是组成了一组方程组，解方程组就可得出E1，用高斯消元，复杂度是<script type="math/tex">O(n^3)</script>。</p><p>从上述例子，我们可总结出如何解决期望类问题，根据题意，表示出各个状态的期望（上例的Ei(i=1,2,3,4)），根据概率公式，列出期望之间的方程，解方程即可。</p><p>当我们把各个状态当成是一个个节点时，概率关系为有向边，我们可看到，可递推的问题其实就是这个关系图是无环的！那必须要用方程组解决的问题其实就是存在环！ 而且还要指出的是用高斯消元的时候，要注意误差的问题，最好把式子适当的增大，避免解小数，否则误差太大，估计也会卡题。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="LightOj1027"><a href="#LightOj1027" class="headerlink" title="LightOj1027"></a>LightOj1027</h3><p><strong>题意：</strong></p><p>有n扇门，正数的门可以<script type="math/tex">x_i</script>时间把人带到终点，负数的门可以<script type="math/tex">x_i</script>时间把人带回起点，问到终点的时间的期望为多少。</p><p><strong>思路：</strong></p><p>设期望为E。</p><p>比如样例3 -6 -9，是这样求期望的<script type="math/tex">E=\frac{1}{3}*3+\frac{1}{3}*(6+E)+\frac{1}{3}*(9+E)</script>，解一下方程就可以了。解释一下这个<script type="math/tex">(6+E)</script>是为什么，因为被带回到起点，就相当于重新开始选择，所以时间就是<script type="math/tex">(6+E)</script>。</p><h3 id="牛客小白赛8G"><a href="#牛客小白赛8G" class="headerlink" title="牛客小白赛8G"></a>牛客小白赛8G</h3><p><strong>题意：</strong></p><p>微信抢红包，有一个红包可以被m个人领取，而且红包的总金额是n。如果为第k个抢红包的人时候,所抢到红包金额的期望是多少？（红包的大小在<script type="math/tex">[0,\frac{2n}{m}]</script>中均匀随机,特别的当红包的大小小于<script type="math/tex">\frac{2n}{m}</script>时,最后剩下的金额会被包入最后一个红包中）。</p><p><strong>思路：</strong></p><p><script type="math/tex">dp[i][j][k]</script>：剩余i元，还有j个红包，在第k个抢到的期望。</p><p>有转移：</p><p><script type="math/tex">dp[i][j][k]=\int_0^{\frac{2n}{m}}\frac{m}{2n}dp[i-x][j-1][k-1]dx</script>。</p><p>手推：</p><p>k=2。</p><p>k=1的时候好算，为<script type="math/tex">\frac{n}{m}</script>。</p><p>k=2：</p><p><script type="math/tex">\int_0^{\frac{2n}{m}}\frac{m}{2n}\int_0^{\frac{2(n-x_1)}{m-1}}\frac{m-1}{2(n-x_1)}x_2dx_2dx_1=\frac{n}{m}</script>。</p><p>即<script type="math/tex">E_2=p*E_1</script>。</p><p>因为与k无关，之后的过程是一样的，所以答案为<script type="math/tex">\frac{n}{m}</script>。</p><h3 id="POJ2096"><a href="#POJ2096" class="headerlink" title="POJ2096"></a>POJ2096</h3><p><strong>题意：</strong></p><p>有A物品数量为a，B物品数量为b，一个人每天可以得到一个A物品和一个B物品，问得到所有物品的天数期望是多少。</p><p><strong>思路：</strong></p><p><script type="math/tex">E(i,j)</script>：已经得到了i个A物品和j个B物品要得到所有物品的天数期望。</p><p>E(n,s)=0，要求E(0,0)。</p><p>有四种情况的转移：没发现任何新的bug和子组件；发现一个新的bug；发现一个新的子组件；同时发现一个新的bug和子组件。</p><p>可以列出式子：</p><p><script type="math/tex">E(i,j)=\frac{ij}{ns}E(i,j)+\frac{(n-i)j}{ns}E(i+1,j)+\frac{i(s-j)}{ns}E(i,j+1)+\frac{(n-i)(s-j)}{ns}E(i+1,j+1)</script>。</p><p>把E(i,j)移项到左边，就可以得到E(i,j)的表达式。</p><p>然后递推一下就可以了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一句话题解</title>
    <link href="/2018/10/25/%E4%B8%80%E5%8F%A5%E8%AF%9D%E9%A2%98%E8%A7%A3/"/>
    <url>/2018/10/25/%E4%B8%80%E5%8F%A5%E8%AF%9D%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="NAQC2017D"><a href="#NAQC2017D" class="headerlink" title="NAQC2017D"></a>NAQC2017D</h3><p><strong>题意：</strong></p><p>有一只猫去捉n(n&lt;=15)只老鼠，猫的初始位置在(0,0)，给出n只老鼠的x,y,s，分别表示所在位置和s秒后会钻入地下，猫每捉到一只老鼠速度会*m(m&lt;1)，问猫的初速度至少为多少才能捉到所有老鼠。</p><p><strong>思路：</strong></p><p>看数据范围很容易想到要状压dp，可是发现每个状态要记录的有两个量，时间和初速度，如果把其中一个加一维，就开不下了。</p><p>其实对于类似记录的有两个量的题目，还可以用二分+dp的思路。</p><p>这里二分初速度，然后dp记录下到该状态的最小时间就可以了。</p><p>这里我状压的两重循环写反了…结果debug了好久啊（甚至下了数据…</p><h3 id="NAQC2016D"><a href="#NAQC2016D" class="headerlink" title="NAQC2016D"></a>NAQC2016D</h3><p><strong>题意：</strong></p><p>给出一个括号序列，可以选择翻转一个区间，问能否匹配。其中len&lt;=5000。</p><p><strong>思路：</strong></p><p>如果把’(‘记为1，把’)’记为-1。匹配的条件为每个前缀和都&gt;=0而且总的前缀和为0。</p><p>根据数据范围可以看出可以dp。</p><p>没想到要怎么dp…其实可以先考虑一下这如果要搜索要怎么写，然后记忆化一下。</p><p>这里可以设计状态<script type="math/tex">dp[pos][pre][sta]</script>，其中sta表示没有翻转，翻转过且连续，翻转过且没有连续。</p><p>然后转移一下就可以了。</p><h3 id="Codeforces1073C"><a href="#Codeforces1073C" class="headerlink" title="Codeforces1073C"></a>Codeforces1073C</h3><p><strong>题意：</strong></p><p>给出一个包含’L’,’R’,’U’,’D’的序列，要到达(x,y)，而且可以改变一些字符，把改变的长度定义为改的最后一个字符和改的第一个字符的距离。问这个改变的长度最小为多少。如果无论怎么改都不能到达(x,y)，则输出-1。</p><p><strong>思路：</strong></p><p>可以对答案进行二分。</p><p>确定好改变的长度后，枚举改变的区间，这个区间里面的值都是可以改的，所以统计一下除了这个区间以外的走得到的所在的位置，因为区间里面的都是可以改的，所以只要当前位置到最终位置的曼哈顿距离小于等于区间长度就说明是可行的，否则就不可行。</p><h3 id="Codeforces1073D"><a href="#Codeforces1073D" class="headerlink" title="Codeforces1073D"></a>Codeforces1073D</h3><p><strong>题意：</strong></p><p>有n个店家形成一个环，初始有T元钱，每个店家可以买<script type="math/tex">a_1,a_2,...,a_n</script>元的东西，当前的钱可以买的时候就一定要买，问最终能买多少东西。</p><p><strong>思路：</strong></p><p>可以模拟。</p><p>对于n个店家，按顺序看能买哪些店家。</p><p>然后对这些可以买的店家计算可以买几次，钱也相应更新就可以了。</p><h3 id="Codeforces1076D"><a href="#Codeforces1076D" class="headerlink" title="Codeforces1076D"></a>Codeforces1076D</h3><p><strong>题意：</strong></p><p>给出n个点m条边，把从1到i的最短路记为<script type="math/tex">d_i</script>，问在最多剩下k条边的情况下，使<script type="math/tex">d_i</script>不变的个数最多。求这些剩下的边。</p><p><strong>思路：</strong></p><p>要剩下的肯定是在所有最短路中经过最多次数的边。</p><p>这里怎么处理呢。可以在求最短路的过程中记录下每个顶点的前驱<script type="math/tex">fa[i]</script>，然后就形成一棵最短路径树。因为要的是经过最多次数的边，所以bfs就可以了。</p><h3 id="Codeforces1076E"><a href="#Codeforces1076E" class="headerlink" title="Codeforces1076E"></a>Codeforces1076E</h3><p><strong>题意：</strong></p><p>给出一棵有n个结点的树，每个结点的权值初始都为0。给出m组操作，在v的子树中与它的距离小于等于d的结点的权值都增加x。问在这些操作之后，结点的权值分别为多少。</p><p><strong>思路：</strong></p><p>这里是区间修改单点查询。</p><p>因为<u>每个结点的权值变化只与祖先的操作有关系</u>，所以就可以直接把每个深度当成区间。在dfs的过程中进入一个有操作的结点，对深度的区间进行修改，这样它的子树就会受到影响。然后单点查询就可以。出这个结点要把区间修改回来，因为从该结点出来之后访问的就不是它的子树了，它的操作对那些结点不会有影响。</p><h3 id="Codeforces1077F2"><a href="#Codeforces1077F2" class="headerlink" title="Codeforces1077F2"></a>Codeforces1077F2</h3><p><strong>题意：</strong></p><p>给出n个数，在每k个数里至少选一个，总共选x个，问最大值为多少。</p><p><strong>思路：</strong></p><p>可以想到是dp+单调队列。</p><p>刚开始想的是这么设计状态<script type="math/tex">dp[i][j]</script>：到第i个总共选了j个的最大值，然后分选和不选来转移，这样子是不行的，因为你得确定知道转移过来的这个到底有没有被选。</p><p>所以要这么设计状态<script type="math/tex">dp[i][j]</script>：选了第i个总共选了j个的最大值。</p><h3 id="Codeforces1054D"><a href="#Codeforces1054D" class="headerlink" title="Codeforces1054D"></a>Codeforces1054D</h3><p><strong>题意：</strong></p><p>给出n个数，每个数都可以<script type="math/tex">\oplus(2^k-1)</script>，在所有区间中，让区间异或为0的区间最少。问在这种情况下，异或不为0的区间有多少个。</p><p><strong>思路：</strong></p><p>首先异或是可以前缀和的，xor[l,r]=pre[r]-pre[l-1]。</p><p>所以要使异或和相同的最少。因为在一个区间中如果两个数都取反就相当于没变，所以每个异或只有两种情况。</p><p>所以就贪心取不同的前缀和然后计算一下就可以了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现実という名の怪物と戦う者たち</title>
    <link href="/2018/10/22/%E7%8E%B0%E5%AE%9F%E3%81%A8%E3%81%84%E3%81%86%E5%90%8D%E3%81%AE%E6%80%AA%E7%89%A9%E3%81%A8%E6%88%A6%E3%81%86%E8%80%85%E3%81%9F%E3%81%A1/"/>
    <url>/2018/10/22/%E7%8E%B0%E5%AE%9F%E3%81%A8%E3%81%84%E3%81%86%E5%90%8D%E3%81%AE%E6%80%AA%E7%89%A9%E3%81%A8%E6%88%A6%E3%81%86%E8%80%85%E3%81%9F%E3%81%A1/</url>
    
    <content type="html"><![CDATA[<p>どうして仆だけがこんなに辛いのかといつも思ってた</p><p>周りの人ばかり幸せそうに见えた</p><p>最近总是忙忙碌碌。说是忙忙碌碌只不过在应付各种各样的作业。</p><p>生活依然被一种莫名的空虚所笼罩。</p><p>总是在想未来的事情。对未来感到害怕，感到担忧。</p><p>明明当下的生活都过得乱七八糟。</p><p>明明是年轻人却始终无法元气满满。</p><p>觉得以前自己可能是缺少别人对自己的认可而那么自卑，然而现在呢。</p><p>明明有爱着自己的人却依然感到压抑。</p><p>觉得自己配不上吧。</p><p>别人对自己一点点的否定都能看得很重，总是要证明自己才是对的。</p><p>争强好胜的背后是自卑在作祟。</p><p>无论什么样的人都能发现他们的闪光点。</p><p>对于自己却无法忍受一点的不完美。觉得自己一无是处。什么都做不好。</p><p>我真的很羡慕别人啊。很羡慕能开心地过着每一天的人啊。</p><p>爸妈对我的要求其实也不高吧。只要有一份稳定的工作早点结婚就好了。</p><p>但这并不是我想要的啊。</p><p>总是雄心勃勃，到头来却发现自己只不过是个连个目标都实现不了的废柴而已。</p><p>真的。好像从来没有达成过自己的定下的目标。</p><p>这背后的原因有很多自己也心知肚明。</p><p>总是负能量满满。不知道在别人面前的自己是不是这样呢。</p><p>对学习感到疲惫。对人与人的交往感到疲惫。</p><p>但又无法放下。</p><p>也许这就是獣になれない私たち。</p><p>每次在各种社交工具表达出自己的难过的时候，还是会有人来安慰的。</p><p>真的感谢。</p><p>不过我是真的不值得这些关心啊。</p><p>upd:发现豆瓣有篇文章说得不错。有点醍醐灌顶的感觉。</p><blockquote><p>昨天和一个姑娘聊天，她说，好羡慕有目标有热情的人。<br>她说，我对什么事情都有热情，但是都坚持不下来，我对很多事都感兴趣，但是啊，做做就没有兴趣了。有的时候做一件事，还没有开始做，就因为惧怕收入不高，不安定就放弃了。但是我又想做自己喜欢的事情。<br>当时她说完这句话的时候，我瞬间有一种，我和她说话是在浪费时间么，这样的想法。<br>被保护的太好了，喜新厌旧，任性，还有这样那样的惰性。<br>因为从来不曾为自己喜欢的事情战斗过，才有这样的结果。</p><p>【我想做自己喜欢的事情】<br>一味逃避的话，就会轻松很多。</p><p>所以，一定要向那些与名为现实的怪物战斗着的人们，献上诚挚的敬意。</p></blockquote><p>所以不要总是畏惧那样这样的事情。要为自己的喜欢的事情而战斗啊。</p><p>即使觉得现在的自己做不好有些事情，努力去做，花更多的时间不就好了。不要害怕没有结果，不去做就更没有结果了啊。</p><p>不要以为自己已经很努力了，不要总是看别人在颓废就想想自己要不也颓废一会儿。别人是别人，我是我。因为我想要的和别人是不一样的啊。</p><p>总要有实现过的目标的是吧。</p><p>换首歌吧。还是是能让我充满力量的那首歌。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=482636058&auto=1&height=66"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>随感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大素数判定 &amp;&amp; 大整数拆分</title>
    <link href="/2018/10/21/%E5%A4%A7%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A-%E5%A4%A7%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"/>
    <url>/2018/10/21/%E5%A4%A7%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A-%E5%A4%A7%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 10000</span>LL factor[maxn];<span class="hljs-keyword">int</span> tot;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> S=<span class="hljs-number">20</span>;<span class="hljs-function">LL <span class="hljs-title">muti_mod</span><span class="hljs-params">(LL a,LL b,LL c)</span></span>&#123;    <span class="hljs-comment">//返回(a*b) mod c,a,b,c&lt;2^63</span>    a%=c;    b%=c;    LL ret=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (b)&#123;        <span class="hljs-keyword">if</span> (b&amp;<span class="hljs-number">1</span>)&#123;            ret+=a;            <span class="hljs-keyword">if</span> (ret&gt;=c) ret-=c;        &#125;        a&lt;&lt;=<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (a&gt;=c) a-=c;        b&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function">LL <span class="hljs-title">pow_mod</span><span class="hljs-params">(LL x,LL n,LL mod)</span></span>&#123;  <span class="hljs-comment">//返回x^n mod c ,非递归版</span>    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x%mod;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">bit</span>[<span class="hljs-number">90</span>],k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (n)&#123;        <span class="hljs-built_in">bit</span>[k++]=n&amp;<span class="hljs-number">1</span>;        n&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    LL ret=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (k=k<span class="hljs-number">-1</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;        ret=muti_mod(ret,ret,mod);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bit</span>[k]==<span class="hljs-number">1</span>) ret=muti_mod(ret,x,mod);    &#125;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(LL a,LL n,LL x,LL t)</span></span>&#123;   <span class="hljs-comment">//以a为基，n-1=x*2^t，检验n是不是合数</span>    LL ret=pow_mod(a,x,n),last=ret;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;        ret=muti_mod(ret,ret,n);        <span class="hljs-keyword">if</span> (ret==<span class="hljs-number">1</span> &amp;&amp; last!=<span class="hljs-number">1</span> &amp;&amp; last!=n<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        last=ret;    &#125;    <span class="hljs-keyword">if</span> (ret!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Miller_Rabin</span><span class="hljs-params">(LL n)</span></span>&#123;    LL x=n<span class="hljs-number">-1</span>,t=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> ((x&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>) x&gt;&gt;=<span class="hljs-number">1</span>,t++;    <span class="hljs-keyword">bool</span> flag=<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (t&gt;=<span class="hljs-number">1</span> &amp;&amp; (x&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;S;k++)&#123;            LL a=rand()%(n<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span> (check(a,n,x,t)) &#123;flag=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;            flag=<span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span> (!flag || n==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function">LL <span class="hljs-title">gcd</span><span class="hljs-params">(LL a,LL b)</span></span>&#123;    <span class="hljs-keyword">if</span> (a==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (a&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> gcd(-a,b);    <span class="hljs-keyword">while</span> (b)&#123;        LL t=a%b; a=b; b=t;    &#125;    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function">LL <span class="hljs-title">Pollard_rho</span><span class="hljs-params">(LL x,LL c)</span></span>&#123;    LL i=<span class="hljs-number">1</span>,x0=rand()%x,y=x0,k=<span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;        i++;        x0=(muti_mod(x0,x0,x)+c)%x;        LL d=gcd(y-x0,x);        <span class="hljs-keyword">if</span> (d!=<span class="hljs-number">1</span> &amp;&amp; d!=x)&#123;            <span class="hljs-keyword">return</span> d;        &#125;        <span class="hljs-keyword">if</span> (y==x0) <span class="hljs-keyword">return</span> x;        <span class="hljs-keyword">if</span> (i==k)&#123;            y=x0;            k+=k;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findfac</span><span class="hljs-params">(LL n)</span></span>&#123;           <span class="hljs-comment">//递归进行质因数分解N</span>    <span class="hljs-keyword">if</span> (!Miller_Rabin(n))&#123;        factor[tot++] = n;        <span class="hljs-keyword">return</span>;    &#125;    LL p=n;    <span class="hljs-keyword">while</span> (p&gt;=n) p=Pollard_rho(p,rand() % (n<span class="hljs-number">-1</span>) +<span class="hljs-number">1</span>);    findfac(p);    findfac(n/p);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//srand(time(NULL));//POJ上G++要去掉这句话</span>    <span class="hljs-keyword">int</span> T;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;    <span class="hljs-keyword">while</span>(T--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n);        <span class="hljs-keyword">if</span> (!Miller_Rabin(n)) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Prime\n"</span>); <span class="hljs-keyword">continue</span>; &#125;        tot = <span class="hljs-number">0</span>;        findfac(n);        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=factor[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;tot;i++)            <span class="hljs-keyword">if</span>(factor[i]&gt;ans)ans=factor[i];        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>曼哈顿距离与切比雪夫距离</title>
    <link href="/2018/10/21/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%E4%B8%8E%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB/"/>
    <url>/2018/10/21/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%E4%B8%8E%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p>将一个点<script type="math/tex">(x,y)</script>的坐标变为<script type="math/tex">(x+y,x−y)</script>后,原坐标系中的曼哈顿距离=新坐标系中的切比雪夫距离；</p><p>将一个点<script type="math/tex">(x,y)</script>的坐标变为<script type="math/tex">(\frac{x+y}{2},\frac{x−y}{2})</script>后,原坐标系中的切比雪夫距离=新坐标系中的曼哈顿距离。</p><p>切比雪夫距离在计算的时候需要取max，往往不是很好优化，对于一个点，计算其他点到该的距离的复杂度为<script type="math/tex">O(n)</script>。</p><p>而曼哈顿距离只有求和以及取绝对值两种运算，我们把坐标排序后可以去掉绝对值的影响，进而用前缀和优化，可以把复杂度降为<script type="math/tex">O(1)</script>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>差分序列</title>
    <link href="/2018/10/15/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/"/>
    <url>/2018/10/15/%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>设<script type="math/tex">h_0,h_1,h_2,...,h_n,...</script>是一个序列，我们定义的一阶差分序列为：<script type="math/tex">Δh_0,Δh_1,...,Δh_n,...,Δh_n=h_{n+1}-h_n</script>。</p><p>差分表：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwaipr5np5j308l03p3yd.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="定理一"><a href="#定理一" class="headerlink" title="定理一"></a>定理一</h3><p>设序列的通项时n的p次多项式，即：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwait38y1bj30fe019wec.jpg" srcset="/img/loading.gif" alt=""><br>则对所有的<img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwaitf2p1fj305q015we9.jpg" srcset="/img/loading.gif" alt="">。</p><h3 id="定理二"><a href="#定理二" class="headerlink" title="定理二"></a>定理二</h3><p>差分表的第0条对角线等于 <script type="math/tex">c_0，c_1，c_2，…，c_p，0，0，0，…</script>，这样序列的通项满足： <img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwaiwcto39j30el02s747.jpg" srcset="/img/loading.gif" alt=""></p><p>例：</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>  <span class="hljs-number">3</span>   <span class="hljs-number">17</span>  <span class="hljs-number">49</span>  <span class="hljs-number">2</span>  <span class="hljs-number">14</span>  <span class="hljs-number">32</span>   <span class="hljs-number">12</span>  <span class="hljs-number">18</span>     <span class="hljs-number">6</span></code></pre><p>差分表的第0条对角线就是：1，2，12，6，0，0，… </p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwg2oyzfdzj30cg02fmx2.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="定理三"><a href="#定理三" class="headerlink" title="定理三"></a>定理三</h3><p>一个序列：<script type="math/tex">h_0，h_1，h_2，h_3，...，h_n，...</script>的第0条差分表的第0条对角线 <script type="math/tex">c_0，c_1，c_2，c_3，...，c_p，0，0，...</script>，则</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwg2t8tac9j30od02f74b.jpg" srcset="/img/loading.gif" alt=""></p><p>例：</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">16</span>   <span class="hljs-number">81</span>   <span class="hljs-number">256</span>  <span class="hljs-number">1</span>   <span class="hljs-number">15</span>  <span class="hljs-number">65</span>   <span class="hljs-number">175</span>    <span class="hljs-number">14</span>  <span class="hljs-number">50</span>  <span class="hljs-number">110</span>      <span class="hljs-number">36</span>  <span class="hljs-number">60</span>        <span class="hljs-number">24</span></code></pre><p>则第0条对角线就是：0，1，14，36，24，0，0，…<br>那么我们就有式子： </p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwg2uo9atej30ma07taah.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0-1BFS</title>
    <link href="/2018/10/14/01-bfs/"/>
    <url>/2018/10/14/01-bfs/</url>
    
    <content type="html"><![CDATA[<p>0-1BFS可以在O(E+V)求出边权只有0/1的最短路。</p><p>维护一个双端队列，如当前可以进行松弛那么就进行更新，更新完后判断一下，若边权为1，则在队尾加入下一个点，否则在队首加入下一个点。松弛操作有点类似于dijkstra…</p><p><strong>由于松弛操作的存在，0-1BFS可以去掉vis数组，而且速度会更快。</strong></p><h3 id="SPOJ-KATHTHI"><a href="#SPOJ-KATHTHI" class="headerlink" title="SPOJ - KATHTHI"></a>SPOJ - KATHTHI</h3><p>题意：</p><p>给出一个n×m的网格，每个位置有一个小写字母，初始在(1,1)，每次可以向上下左右走，问走到(n,m)的最小花费。若当前位置与下一位置的字符相同，则移动花费为0，否则为1。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> m,n;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> x,y,c;&#125;;<span class="hljs-keyword">char</span> mp[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onezerobfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">deque</span>&lt;node&gt;q;    dis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    q.push_back(node&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        node temp=q.front();        q.pop_front();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)        &#123;            <span class="hljs-keyword">int</span> xx=temp.x+dx[i],yy=temp.y+dy[i];            <span class="hljs-keyword">if</span>(xx&gt;=<span class="hljs-number">0</span>&amp;&amp;xx&lt;m&amp;&amp;yy&gt;=<span class="hljs-number">0</span>&amp;&amp;yy&lt;n)            &#123;                <span class="hljs-keyword">int</span> cost=mp[temp.x][temp.y]==mp[xx][yy]?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span>(dis[temp.x][temp.y]+cost&lt;dis[xx][yy])                &#123;                    dis[xx][yy]=dis[temp.x][temp.y]+cost;                    <span class="hljs-keyword">if</span>(cost==<span class="hljs-number">1</span>)q.push_back(node&#123;xx,yy,dis[xx][yy]&#125;);                    <span class="hljs-keyword">else</span> q.push_front(node&#123;xx,yy,dis[xx][yy]&#125;);                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x7f</span>,<span class="hljs-keyword">sizeof</span>(dis));        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;m,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,mp[i]);        onezerobfs();        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dis[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BM算法</title>
    <link href="/2018/09/27/BM%E7%AE%97%E6%B3%95/"/>
    <url>/2018/09/27/BM%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">2005</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-8</span>;<span class="hljs-keyword">int</span> cnt, fail[MAXN];<span class="hljs-keyword">double</span> val[MAXN], delta[MAXN];<span class="hljs-built_in">vector</span> &lt;<span class="hljs-keyword">double</span>&gt; ans[MAXN];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf"</span>, &amp;val[i]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        <span class="hljs-keyword">double</span> tmp = val[i];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> j = <span class="hljs-number">0</span>; j &lt; ans[cnt].<span class="hljs-built_in">size</span>(); j++)            tmp -= ans[cnt][j] * val[i - j - <span class="hljs-number">1</span>];        delta[i] = tmp;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(tmp) &lt;= eps) <span class="hljs-keyword">continue</span>;        fail[cnt] = i;        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;            ans[++cnt].resize(i);            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">double</span> mul = delta[i] / delta[fail[cnt - <span class="hljs-number">1</span>]];        cnt++; ans[cnt].resize(i - fail[cnt - <span class="hljs-number">2</span>] - <span class="hljs-number">1</span>);        ans[cnt].push_back(mul);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> j = <span class="hljs-number">0</span>; j &lt; ans[cnt - <span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>(); j++)            ans[cnt].push_back(ans[cnt - <span class="hljs-number">2</span>][j] * -mul);        <span class="hljs-keyword">if</span> (ans[cnt].<span class="hljs-built_in">size</span>() &lt; ans[cnt - <span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()) ans[cnt].resize(ans[cnt - <span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>());        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> j = <span class="hljs-number">0</span>; j &lt; ans[cnt - <span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>(); j++)            ans[cnt][j] += ans[cnt - <span class="hljs-number">1</span>][j];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; ans[cnt].<span class="hljs-built_in">size</span>(); i++)        <span class="hljs-built_in">cout</span> &lt;&lt; ans[cnt][i] &lt;&lt; <span class="hljs-string">' '</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>杜教BM递推模板</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,a,n) for (long long i=a;i&lt;n;i++)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> per(i,a,n) for (long long i=n-1;i&gt;=a;i--)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pb push_back</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mp make_pair</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> all(x) (x).begin(),(x).end()</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fi first</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> se second</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SZ(x) ((long long)(x).size())</span><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; VI;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; PII;<span class="hljs-keyword">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-function">ll <span class="hljs-title">powmod</span><span class="hljs-params">(ll a,ll b)</span> </span>&#123;ll res=<span class="hljs-number">1</span>;a%=mod; assert(b&gt;=<span class="hljs-number">0</span>); <span class="hljs-keyword">for</span>(;b;b&gt;&gt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// head</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> _,n;<span class="hljs-keyword">namespace</span> linear_seq&#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> N=<span class="hljs-number">10010</span>;    ll res[N],base[N],_c[N],_md[N];     <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; Md;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(ll *a,ll *b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k)</span></span><span class="hljs-function">    </span>&#123;        rep(i,<span class="hljs-number">0</span>,k+k) _c[i]=<span class="hljs-number">0</span>;        rep(i,<span class="hljs-number">0</span>,k) <span class="hljs-keyword">if</span> (a[i]) rep(j,<span class="hljs-number">0</span>,k)            _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=k+k<span class="hljs-number">-1</span>;i&gt;=k;i--) <span class="hljs-keyword">if</span> (_c[i])            rep(j,<span class="hljs-number">0</span>,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;        rep(i,<span class="hljs-number">0</span>,k) a[i]=_c[i];    &#125;    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(ll n,VI a,VI b)</span></span><span class="hljs-function">    </span>&#123; <span class="hljs-comment">// a 系数 b 初值 b[n+1]=a[0]*b[n]+...</span><span class="hljs-comment">//        printf("%d\n",SZ(b));</span>        ll ans=<span class="hljs-number">0</span>,pnt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k=SZ(a);        assert(SZ(a)==SZ(b));        rep(i,<span class="hljs-number">0</span>,k) _md[k<span class="hljs-number">-1</span>-i]=-a[i];_md[k]=<span class="hljs-number">1</span>;        Md.<span class="hljs-built_in">clear</span>();        rep(i,<span class="hljs-number">0</span>,k) <span class="hljs-keyword">if</span> (_md[i]!=<span class="hljs-number">0</span>) Md.push_back(i);        rep(i,<span class="hljs-number">0</span>,k) res[i]=base[i]=<span class="hljs-number">0</span>;        res[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> ((<span class="hljs-number">1l</span>l&lt;&lt;pnt)&lt;=n) pnt++;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p=pnt;p&gt;=<span class="hljs-number">0</span>;p--)        &#123;            mul(res,res,k);            <span class="hljs-keyword">if</span> ((n&gt;&gt;p)&amp;<span class="hljs-number">1</span>)            &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) res[i+<span class="hljs-number">1</span>]=res[i];res[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;                rep(j,<span class="hljs-number">0</span>,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;            &#125;        &#125;        rep(i,<span class="hljs-number">0</span>,k) ans=(ans+res[i]*b[i])%mod;        <span class="hljs-keyword">if</span> (ans&lt;<span class="hljs-number">0</span>) ans+=mod;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function">VI <span class="hljs-title">BM</span><span class="hljs-params">(VI s)</span></span><span class="hljs-function">    </span>&#123;        VI C(1,1),B(1,1);        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> L=<span class="hljs-number">0</span>,m=<span class="hljs-number">1</span>,b=<span class="hljs-number">1</span>;        rep(n,<span class="hljs-number">0</span>,SZ(s))        &#123;            ll d=<span class="hljs-number">0</span>;            rep(i,<span class="hljs-number">0</span>,L+<span class="hljs-number">1</span>) d=(d+(ll)C[i]*s[n-i])%mod;            <span class="hljs-keyword">if</span> (d==<span class="hljs-number">0</span>) ++m;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span>*L&lt;=n)            &#123;                VI T=C;                ll c=mod-d*powmod(b,mod<span class="hljs-number">-2</span>)%mod;                <span class="hljs-keyword">while</span> (SZ(C)&lt;SZ(B)+m) C.pb(<span class="hljs-number">0</span>);                rep(i,<span class="hljs-number">0</span>,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;                L=n+<span class="hljs-number">1</span>-L; B=T; b=d; m=<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>            &#123;                ll c=mod-d*powmod(b,mod<span class="hljs-number">-2</span>)%mod;                <span class="hljs-keyword">while</span> (SZ(C)&lt;SZ(B)+m) C.pb(<span class="hljs-number">0</span>);                rep(i,<span class="hljs-number">0</span>,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;                ++m;            &#125;        &#125;        <span class="hljs-keyword">return</span> C;    &#125;    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">gao</span><span class="hljs-params">(VI a,ll n)</span></span><span class="hljs-function">    </span>&#123;        VI c=BM(a);        c.erase(c.<span class="hljs-built_in">begin</span>());        rep(i,<span class="hljs-number">0</span>,SZ(c)) c[i]=(mod-c[i])%mod;        <span class="hljs-keyword">return</span> solve(n,c,VI(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">begin</span>()+SZ(c)));    &#125;&#125;; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%I64d"</span>, &amp;n))    &#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%I64d\n"</span>,linear_seq::gao(VI&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">11</span>,<span class="hljs-number">36</span>,<span class="hljs-number">95</span>,<span class="hljs-number">281</span>,<span class="hljs-number">781</span>,<span class="hljs-number">2245</span>,<span class="hljs-number">6336</span>,<span class="hljs-number">18061</span>, <span class="hljs-number">51205</span>&#125;,n<span class="hljs-number">-1</span>));    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造</title>
    <link href="/2018/09/25/%E6%9E%84%E9%80%A0/"/>
    <url>/2018/09/25/%E6%9E%84%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="Codeforces-1058D"><a href="#Codeforces-1058D" class="headerlink" title="Codeforces 1058D"></a>Codeforces 1058D</h4><p><strong>构造出两个数x,y，使得<script type="math/tex">x*y=\frac{2mn}{k}</script>，并且<script type="math/tex">x\le m,y\le n</script>。</strong></p><p>2m和k尽可能地约分，考虑2m与k有共同因子的情况，即<script type="math/tex">gcd(2m,k)!=1</script>，此时经过约分可以得到<script type="math/tex">x=\frac{2m}{gcd(2m,k)},y=\frac{gcd(2m,k)*m}{k}</script>，容易看出x,y都满足要求。如果<script type="math/tex">gcd(2m,k)=1</script>，可以知道<script type="math/tex">gcd(n,k)!=1</script>，就是一样的做法了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上下界网络流</title>
    <link href="/2018/09/08/%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <url>/2018/09/08/%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>上下界网络流即对边的流量有限制，必须在[down,up]的范围内。</p><h3 id="无源汇有上下界可行流"><a href="#无源汇有上下界可行流" class="headerlink" title="无源汇有上下界可行流"></a>无源汇有上下界可行流</h3><p><strong>模型：</strong></p><p>一个网络，求出一个流，使得每条边的流量为<script type="math/tex">[L_i,H_i]</script>，除了源点和汇点，每个点必须满足总流入量=总流出量（流量守恒）（这个流的特点是循环往复，无始无终）。</p><p><strong>建图：</strong></p><p>首先建立一个源ss和一个汇tt，一般称为附加源和附加汇。</p><p>对于图中的每条弧<script type="math/tex"><u,v></script>，假设它容量上界为c，下界b，那么把这条边拆为三条只有上界的弧。</p><p>一条为<script type="math/tex"><ss,v></script>，容量为b；</p><p>一条为<script type="math/tex"><u,tt></script>，容量为b；</p><p>一条为<script type="math/tex"><u,v></script>，容量为c−b。</p><p>其中前两条弧一般称为附加弧。</p><p>然后对这张图跑最大流，以ss为源，以tt为汇，如果所有的附加弧都满流，则原图有可行流。</p><p>这时，每条非附加弧的流量加上它的容量下界，就是原图中这条弧应该有的流量。</p><p><strong>模板：</strong></p><p>LOJ115</p><p>n个点，m条边，每条边e有一个流量下界lower(e)和流量上界upper(e)，求一种可行方案使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。</p><p>如果无解，输出一行NO。</p><p>否则第一行输出YES，之后m行每行一个整数，表示每条边的流量。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> s,e;<span class="hljs-comment">//源点、汇点</span><span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    ll cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">200010</span>];<span class="hljs-comment">//邻接表要开边数的两倍</span><span class="hljs-keyword">int</span> head[<span class="hljs-number">10010</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">10010</span>];<span class="hljs-comment">//当前弧优化</span><span class="hljs-keyword">int</span> dis[<span class="hljs-number">10010</span>];<span class="hljs-comment">//分层图中每个点的层数（即到原点的最短距离）</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,ll z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,ll cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    ll res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">ll <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-keyword">int</span> m,x,y,l,r;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        s=<span class="hljs-number">0</span>;e=n+<span class="hljs-number">1</span>;        top=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));        <span class="hljs-keyword">while</span>(m--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;x,&amp;y,&amp;l,&amp;r);            add(x,y,r-l);add(y,x,<span class="hljs-number">0</span>);            add(x,e,l);add(e,x,<span class="hljs-number">0</span>);            add(s,y,l);add(y,s,<span class="hljs-number">0</span>);        &#125;        dinic();        <span class="hljs-keyword">bool</span> sign=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[s];i!=<span class="hljs-number">-1</span>&amp;&amp;sign;i=eg[i].next)            <span class="hljs-keyword">if</span>(eg[i].cap!=<span class="hljs-number">0</span>)sign=<span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span>(!sign)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;top;i+=<span class="hljs-number">6</span>)                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,eg[i].cap+eg[i+<span class="hljs-number">1</span>].cap+eg[i+<span class="hljs-number">2</span>].cap);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="有源汇有上下界可行流"><a href="#有源汇有上下界可行流" class="headerlink" title="有源汇有上下界可行流"></a>有源汇有上下界可行流</h3><p><strong>模型：</strong></p><p>网络有一个源点s和汇点t，求出一个流使得源点的总流出量等于汇点的总流入量，其他的点满足流量守恒，而且每条边的流量满足上界和下界限制。</p><p><strong>建图：</strong></p><p>建立弧<script type="math/tex"><t,s></script>，容量下界为0，上界为∞。</p><p>然后对这个新图（实际上只是比原图多了一条边）按照无源汇可行流的方法建模，如果所有附加弧满流，则存在可行流。</p><p>求原图中每条边对应的实际流量的方法，同无源汇可行流，只是忽略掉弧<script type="math/tex"><t,s></script>就好。</p><p>而且这时候弧<script type="math/tex"><t,s></script>的流量就是原图的总流量。</p><h3 id="有源汇有上下界最大流"><a href="#有源汇有上下界最大流" class="headerlink" title="有源汇有上下界最大流"></a>有源汇有上下界最大流</h3><p><strong>模型：</strong></p><p>网络有一个源点s和汇点t，求出一个流使得源点的总流出量等于汇点的总流入量，其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。在这些前提下要求总流量最大。</p><p><strong>建图：</strong></p><p>首先按照有源汇可行流的方法建模。</p><p>如果存在可行流，那么在运行过有源汇可行流的图上（就是已经存在流量的那张图，流量不要清零），跑一遍从s到t的最大流（这里的s和t是原图的源和汇，不是附加源和附加汇），就是原图的最大流。</p><p><strong>模板：</strong></p><p>n个点，m条边，每条边e有一个流量下界lower(e)和流量上界upper(e)，给定源点s与汇点t，求源点到汇点的最大流。</p><p>如果无解，输出一行 please go home to sleep。</p><p>否则输出最大流。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bitset&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ull unsigned long long</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> s,e;<span class="hljs-comment">//源点、汇点</span><span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    ll cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">200010</span>];<span class="hljs-comment">//邻接表要开边数的两倍</span><span class="hljs-keyword">int</span> head[<span class="hljs-number">10010</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">10010</span>];<span class="hljs-comment">//当前弧优化</span><span class="hljs-keyword">int</span> dis[<span class="hljs-number">10010</span>];<span class="hljs-comment">//分层图中每个点的层数（即到原点的最短距离）</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,ll z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,ll cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    ll res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">ll <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())<span class="hljs-comment">//建立分层图</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,x,y,l,r;    <span class="hljs-keyword">int</span> curs,cure;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;curs,&amp;cure);    s=<span class="hljs-number">0</span>;e=n+<span class="hljs-number">1</span>;    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;x,&amp;y,&amp;l,&amp;r);        add(x,y,r-l);add(y,x,<span class="hljs-number">0</span>);        add(x,e,l);add(e,x,<span class="hljs-number">0</span>);        add(s,y,l);add(y,s,<span class="hljs-number">0</span>);    &#125;    add(s,curs,INF);add(curs,s,<span class="hljs-number">0</span>);    add(cure,e,INF);add(e,cure,<span class="hljs-number">0</span>);    ll maxflow=dinic();    <span class="hljs-keyword">bool</span> sign=<span class="hljs-literal">true</span>;    ll flow=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=eg[head[s]].next;i!=<span class="hljs-number">-1</span>&amp;&amp;sign;i=eg[i].next)    &#123;        <span class="hljs-keyword">if</span>(eg[i].cap!=<span class="hljs-number">0</span>)sign=<span class="hljs-literal">false</span>;        flow+=eg[i^<span class="hljs-number">1</span>].cap;    &#125;    <span class="hljs-keyword">if</span>(!sign)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"please go home to sleep\n"</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,maxflow-flow);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="有源汇有上下界最小流"><a href="#有源汇有上下界最小流" class="headerlink" title="有源汇有上下界最小流"></a>有源汇有上下界最小流</h3><p><strong>模型：</strong></p><p>模型:现在的网络有一个源点s和汇点t，求出一个流使得源点的总流出量等于汇点的总流入量，其他的点满足流量守恒，而且每条边的流量满足上界和下界限制。在这些前提下要求总流量最小。</p><p><strong>建图：</strong></p><p>首先按照有源汇可行流的方法建模，但是不要建立<script type="math/tex"><t,s></script>这条弧。</p><p>然后在这个图上，跑从附加源ss到附加汇tt的最大流。</p><p>这时候再添加弧<script type="math/tex"><t,s></script>，下界为0，上界为∞。</p><p>在现在的这张图上，从ss到tt的最大流，就是原图的最小流。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU5514 容斥原理/欧拉函数的应用</title>
    <link href="/2018/09/07/HDU5514-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2018/09/07/HDU5514-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n只青蛙，有m块石头，编号为0～m-1，第i只青蛙每次可以跳<script type="math/tex">a_i</script>步，刚开始都在0，问青蛙总共可以跳到的石头之和为多少。其中<script type="math/tex">t≤20</script>，<script type="math/tex">1≤n≤10^4</script>，<script type="math/tex">1≤m≤10^9</script>，<script type="math/tex">1≤a_i≤10^9</script>。</p><p><strong>思路：</strong></p><p>根据裴蜀定理知，对于一个有n个点的环，每个循环节的长度为n/gcd(n, k)，k为每次走的步数。所以青蛙可以达到的石头编号肯定是<script type="math/tex">gcd(m,a_i)</script>的倍数。相当于真正步长为<script type="math/tex">gcd(m,a_i)</script>。</p><p>很容易就知道要容斥搞一搞，看到n这么大，就没有然后了…</p><p>看了题解知道原来容斥是可以搞的。</p><p>法一：容斥原理</p><p>要求<script type="math/tex">gcd(m,a_1)</script>,<script type="math/tex">gcd(m,a_2)</script>,<script type="math/tex">gcd(m,a_3)</script>…<script type="math/tex">gcd(m,a_n)</script>的倍数之和，可以利用<script type="math/tex">gcd(m,a_i)</script>是m的因子这个特点。</p><p>所以处理出m的因子，然后算贡献。</p><p>首先对于m以内的<script type="math/tex">gcd(m,a_i)</script>的倍数，标记为1，说明这些数的倍数都有可能算进答案里。然后从小到大，如果某个数的贡献（该数的倍数之和）算入了答案，那么它的倍数应该少算一次贡献，那么就把标记减1。然后每次算的时候就是标记*贡献。贡献用等差数列求和算一下就可以了。</p><p>复杂度为<script type="math/tex">O(t*1000*n)</script>。</p><p>一直在想这些数的lcm要怎么处理，还计数搞了好久…然而正确的思路总是明了的思想啊…</p><p>法二：欧拉函数的应用</p><p>因为可能有多只青蛙占领同一个石头的情况，所以有消除重复的办法。</p><p>比如样例一，m=12，<script type="math/tex">a_1=9</script>，<script type="math/tex">a_2=10</script>，<script type="math/tex">gcd(m,a_1)=3</script>，<script type="math/tex">gcd(m,a_1)=2</script>。可以规定每个石头i只能被步长为<script type="math/tex">gcd(m,i)</script>的青蛙占领。</p><p>2，10只能由步长为2的来占领；</p><p>3，9只能由步长为3的来占领；</p><p>4，8只能由步长为4的来占领；</p><p>6只能由步长为6的来占领。</p><p>算一下和，</p><p>2+10=2*(1+5)；</p><p>3+9=3*(1+3);</p><p>4+8=4*(1+2);</p><p>6=6*1。</p><p>所以如果步长为x，可以占领的石头的编号和为x*(与<script type="math/tex">\frac{m}{x}</script>互质的数之和)。</p><p>因为有结论小于n，且与n互质的所有数字的和是<script type="math/tex">\frac{φ(n)∗n}{2}</script>。</p><p>所以就可以做了。</p><p>这个方法比较难想到，特别是消除重复和m/x得到的地方。这么消除重复的方式可以学习一下。</p><p><strong>代码：</strong></p><p>法一：</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> a[<span class="hljs-number">10010</span>],b[<span class="hljs-number">10010</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v;<span class="hljs-keyword">int</span> num[<span class="hljs-number">10010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a&lt;b)&#123;<span class="hljs-keyword">int</span> temp;temp=a;a=b;b=temp;&#125;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">while</span>(a%b)&#123;<span class="hljs-keyword">int</span> r=a%b;a=b;b=r;&#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-function">ll <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1l</span>l*x/<span class="hljs-number">2</span>*(x+<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">1l</span>l*(x+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>*x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            b[i]=gcd(m,a[i]);        v.<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i*i&lt;=m;i++)        &#123;            <span class="hljs-keyword">if</span>(m%i==<span class="hljs-number">0</span>)            &#123;                v.push_back(i);                <span class="hljs-keyword">if</span>(i!=m/i)v.push_back(m/i);            &#125;        &#125;        sort(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());        <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(num));        <span class="hljs-keyword">int</span> len=v.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)            &#123;                <span class="hljs-keyword">if</span>(v[i]%b[j]==<span class="hljs-number">0</span>)                    num[i]=<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-comment">/*for(int i=0;i&lt;len;i++)</span><span class="hljs-comment">            printf("%d ",v[i]);</span><span class="hljs-comment">        printf("\n");</span><span class="hljs-comment">        for(int i=0;i&lt;len;i++)</span><span class="hljs-comment">            printf("%d ",num[i]);</span><span class="hljs-comment">        printf("\n");*/</span>        ll tot=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        &#123;            <span class="hljs-keyword">if</span>(num[i]==<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">int</span> temp=(m<span class="hljs-number">-1</span>)/v[i];            tot+=num[i]*calc(temp)*v[i];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;len;j++)            &#123;                <span class="hljs-keyword">if</span>(v[j]%v[i]==<span class="hljs-number">0</span>)                    num[j]-=num[i];            &#125;            <span class="hljs-comment">/*for(int j=0;j&lt;len;j++)</span><span class="hljs-comment">                printf("%d ",num[j]);</span><span class="hljs-comment">            printf("\n");*/</span>        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case #%d: %lld\n"</span>,kase,tot);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>法二：</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> a[<span class="hljs-number">10010</span>],b[<span class="hljs-number">10010</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v;<span class="hljs-keyword">int</span> num[<span class="hljs-number">10010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a&lt;b)&#123;<span class="hljs-keyword">int</span> temp;temp=a;a=b;b=temp;&#125;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">while</span>(a%b)&#123;<span class="hljs-keyword">int</span> r=a%b;a=b;b=r;&#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-function">ll <span class="hljs-title">euler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    ll res=<span class="hljs-number">1l</span>l*n;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)        &#123;            res=res/i*(i<span class="hljs-number">-1</span>);            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)                n=n/i;        &#125;    &#125;    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)res=res/n*(n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            b[i]=gcd(m,a[i]);        v.<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i*i&lt;=m;i++)        &#123;            <span class="hljs-keyword">if</span>(m%i==<span class="hljs-number">0</span>)            &#123;                v.push_back(i);                <span class="hljs-keyword">if</span>(i!=m/i)v.push_back(m/i);            &#125;        &#125;        <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(num));        ll tot=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len=v.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)                <span class="hljs-keyword">if</span>(v[j]%b[i]==<span class="hljs-number">0</span>)                    num[j]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        &#123;            <span class="hljs-keyword">if</span>(num[i]&amp;&amp;v[i]!=m)            &#123;                ll temp=euler(m/v[i])*m/<span class="hljs-number">2</span>;                tot+=temp;                <span class="hljs-comment">//printf("%d %lld\n",v[i],temp);</span>            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case #%d: %lld\n"</span>,kase,tot);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6430 树上启发式合并/线段树合并</title>
    <link href="/2018/09/05/HDU6430-%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    <url>/2018/09/05/HDU6430-%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有一棵以结点1为根的n个结点的树，每个结点有一个权值v[i]，对于每个结点求出以它为LCA的两个结点的GCD的最大值。其中<script type="math/tex">n<=100000</script>,<script type="math/tex">f[i]<v[i]<=100000</script>。</p><p><strong>思路：</strong></p><p>因为v[i]很小，首先预处理出1～100000的所有因子存在vector里。</p><p>法一：树上启发式合并</p><p>对于一个结点，它作为LCA就相当于求这个结点的子树中相同的因子，这么说有点难理解，比如这样子一张图，</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuz0kzcu3gj306w06paa3.jpg" srcset="/img/loading.gif" alt="QQ20180905-0"></p><p>可以这么计算：先从结点1搜下去，把结点2的的因子合并到1上面并同时更新结点1的答案，再访问结点3，因为结点3还有儿子结点4，继续往下搜，将结点4的因子合并到结点3上。然后对于结点本身的因子也要放到容器里，更新答案。再把结点3合并到结点1，相同的因子说明可能是GCD，更新答案，并把1本身的因子放到容器。</p><p>因子可以放在set里，这里的启发式就体现在，当某个结点向上合并时，总是小的合并到大的。</p><p><strong>代码：</strong></p><p>set+启发式合并：</p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;fact[<span class="hljs-number">100010</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> w[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> ans[<span class="hljs-number">100010</span>];<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;s[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100000</span>;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=<span class="hljs-number">100000</span>;j+=i)            fact[j].push_back(i);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(s[x].<span class="hljs-built_in">size</span>()&lt;s[y].<span class="hljs-built_in">size</span>())        swap(s[x],s[y]);    <span class="hljs-keyword">int</span> res=<span class="hljs-number">-1</span>;    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;    <span class="hljs-keyword">for</span>(it=s[y].<span class="hljs-built_in">begin</span>();it!=s[y].<span class="hljs-built_in">end</span>();it++)    &#123;        <span class="hljs-keyword">if</span>(s[x].count(*it))            res=<span class="hljs-built_in">max</span>(res,*it);        <span class="hljs-keyword">else</span>            s[x].insert(*it);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[id][i];        dfs(temp);        ans[id]=<span class="hljs-built_in">max</span>(ans[id],merge(id,temp));<span class="hljs-comment">//每个结点和子树合并</span>    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;fact[w[id]].<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//将自己加入到s里</span>    &#123;        <span class="hljs-keyword">int</span> temp=fact[w[id]][i];        <span class="hljs-keyword">if</span>(s[id].count(temp))            ans[id]=<span class="hljs-built_in">max</span>(ans[id],temp);        <span class="hljs-keyword">else</span>            s[id].insert(temp);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    init();    <span class="hljs-keyword">int</span> n,x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        v[x].push_back(i);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;w[i]);    <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(ans));    dfs(<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自适应辛普森法</title>
    <link href="/2018/09/04/%E8%87%AA%E9%80%82%E5%BA%94%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%B3%95/"/>
    <url>/2018/09/04/%E8%87%AA%E9%80%82%E5%BA%94%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>存个模板。</p><h5 id="luogu4525"><a href="#luogu4525" class="headerlink" title="luogu4525"></a>luogu4525</h5><p>计算积分<script type="math/tex">\int_{L}^{R}\frac{cx+d}{ax+b}dx</script>。结果保留至小数点后6位。</p><pre><code class="hljs c++"><span class="hljs-keyword">double</span> a,b,c,d,l,r;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span>     <span class="hljs-comment">//原函数</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> (c*x+d)/(a*x+b);&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">simpson</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l,<span class="hljs-keyword">double</span> r)</span>     <span class="hljs-comment">//Simpson公式</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> mid=(l+r)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">return</span> (f(l)+<span class="hljs-number">4</span>*f(mid)+f(r))*(r-l)/<span class="hljs-number">6</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">asr</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l,<span class="hljs-keyword">double</span> r,<span class="hljs-keyword">double</span> eps,<span class="hljs-keyword">double</span> ans)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> mid=(l+r)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">double</span> l_=simpson(l,mid),r_=simpson(mid,r);    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(l_+r_-ans)&lt;=<span class="hljs-number">15</span>*eps) <span class="hljs-keyword">return</span> l_+r_+(l_+r_-ans)/<span class="hljs-number">15</span>;     <span class="hljs-comment">//确认精度</span>    <span class="hljs-keyword">return</span> asr(l,mid,eps/<span class="hljs-number">2</span>,l_)+asr(mid,r,eps/<span class="hljs-number">2</span>,r_);     <span class="hljs-comment">//精度不够则递归调用</span>&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">asr</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l,<span class="hljs-keyword">double</span> r,<span class="hljs-keyword">double</span> eps)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> asr(l,r,eps,simpson(l,r));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf%lf%lf%lf%lf"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;l,&amp;r);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.6lf"</span>,asr(l,r,<span class="hljs-number">1e-6</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇技淫巧</title>
    <link href="/2018/09/04/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    <url>/2018/09/04/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>1.打表看dp规律。</p><p>2.用excel求回归方程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pb_ds库</title>
    <link href="/2018/09/03/pb-ds%E5%BA%93/"/>
    <url>/2018/09/03/pb-ds%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h5 id="rope"><a href="#rope" class="headerlink" title="rope"></a>rope</h5><p>头文件与命名空间：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ext/rope&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_cxx;</code></pre><p>大概可以称作可持久化平衡树，因为rope适用于大量、冗长的串操作，而不适合单个字符操作。rope类似块状链表。复杂度为<script type="math/tex">O\sqrt n</script>。</p><p>基本操作：</p><p>1）运算符：rope支持operator += -= + - &lt; ==。</p><p>2）输入输出：可以用&lt;&lt;运算符由输入输出流读入或输出。</p><p>3）长度/大小：调用length()，size()都可以。</p><p>4）插入/添加等：</p><pre><code class="hljs c++">push_back(x);<span class="hljs-comment">//在末尾添加x</span>insert(pos,x);<span class="hljs-comment">//在pos插入x，自然支持整个char数组的一次插入</span>erase(pos,x);<span class="hljs-comment">//从pos开始删除x个</span>copy(pos,len,x);<span class="hljs-comment">//从pos开始到pos+len为止用x代替</span>replace(pos,x);<span class="hljs-comment">//从pos开始换成x</span>substr(pos,x);<span class="hljs-comment">//提取pos开始x个</span>at(x)/[x];<span class="hljs-comment">//访问第x个元素</span></code></pre><pre><code class="hljs c++">rope&lt;<span class="hljs-keyword">int</span>&gt;r</code></pre><p>放在主函数外面会快一点。</p><h5 id="hash-table"><a href="#hash-table" class="headerlink" title="hash table"></a>hash table</h5><p>头文件与命名空间：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ext/pb_ds/hash_policy.hpp&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;</code></pre><p>cc_hash_table是拉链法</p><p>gp_hash_table是查探法</p><p>gp_hash_table更快，一般用这个。</p><p>声明方式：</p><pre><code class="hljs c++">cc_hash_table&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">bool</span>&gt;h;gp_hash_table&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">bool</span>&gt;h;</code></pre><p>除了当数组用外，还支持clear、find和operator[]。</p><p>这个也得放在主函数外面。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京网络赛I (Manacher+哈希)/回文树</title>
    <link href="/2018/09/03/%E5%8D%97%E4%BA%AC%E7%BD%91%E7%BB%9C%E8%B5%9BI-Manacher-%E5%93%88%E5%B8%8C-%E5%9B%9E%E6%96%87%E6%A0%91/"/>
    <url>/2018/09/03/%E5%8D%97%E4%BA%AC%E7%BD%91%E7%BB%9C%E8%B5%9BI-Manacher-%E5%93%88%E5%B8%8C-%E5%9B%9E%E6%96%87%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出一个全是数字的字符串S，求其中所有回文串的总和（长得一样的算一个）。S的长度小于等于2000000。</p><p><strong>思路：</strong></p><p>法一：马拉车+哈希</p><p>字符串的各种算法是去年学的现在都忘光了…</p><p>所以先复习了一下马拉车（以前好像没有搞得很明白）。</p><p>参考博客：<a href="https://www.jianshu.com/p/799bc53d4e3d" target="_blank" rel="noopener">https://www.jianshu.com/p/799bc53d4e3d</a></p><p>这篇写得很好。</p><p>理解马拉车的原理以后可以知道扩展之前就已经把当前已知的部分回文利用起来了，所以这里已经去掉了一些重复的，但是还是有一些其他重复的。</p><p>在扩展的过程中取出新产生的子串，算出哈希值看有没有出现过，如果没有出现过就算在答案里，出现过就不算。</p><p>所以这里要预处理出哈希值，前缀和和一些次方的值。</p><p>哈希表这里我看到群里说可以用gp_hash_table…然而我用了却MLE了…我觉得可能是这个ull太大了，所以我把它取模变成int存起来就WA了…考虑到2000000的子串数量，的确是会发生冲突。</p><p>所以就只能参考网上手写了个拉链法的哈希表。</p><p>感觉做一道题好像学了挺多东西的啊hhh。</p><p>法二：回文树</p><p>留坑。</p><p><strong>代码：</strong></p><p>法一：</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-keyword">const</span> ull base=<span class="hljs-number">131</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">4000007</span>;<span class="hljs-keyword">char</span> a[<span class="hljs-number">2001000</span>];<span class="hljs-comment">//aba</span><span class="hljs-keyword">char</span> anew[<span class="hljs-number">4001000</span>];<span class="hljs-comment">//$#a#b#a#</span><span class="hljs-keyword">int</span> p[<span class="hljs-number">4001000</span>];<span class="hljs-comment">//新串中以第i个字符为对称轴的回文串的回文半径</span><span class="hljs-comment">//p[i]-1为原串中以i为对称轴的最长回文串的长度</span>ull hsh[<span class="hljs-number">4001000</span>],bas[<span class="hljs-number">4001000</span>];<span class="hljs-comment">//哈希值</span>ll pre[<span class="hljs-number">4001000</span>],tbas[<span class="hljs-number">4001000</span>];<span class="hljs-comment">//前缀和</span><span class="hljs-keyword">int</span> head[<span class="hljs-number">4001000</span>],nxt[<span class="hljs-number">4001000</span>],cnt=<span class="hljs-number">0</span>;ull val[<span class="hljs-number">4001000</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(a);    anew[<span class="hljs-number">0</span>]=<span class="hljs-string">'$'</span>;    anew[<span class="hljs-number">1</span>]=<span class="hljs-string">'#'</span>;    <span class="hljs-keyword">int</span> num=<span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)    &#123;        anew[num++]=a[i];        anew[num++]=<span class="hljs-string">'#'</span>;    &#125;    anew[num]=<span class="hljs-string">'\0'</span>;    <span class="hljs-comment">//puts(anew);</span>&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">used</span><span class="hljs-params">(ull x)</span><span class="hljs-comment">//手写拉链法哈希</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp=x%mod;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[temp];i!=<span class="hljs-number">-1</span>;i=nxt[i])        <span class="hljs-keyword">if</span>(val[i]==x)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    val[++cnt]=x;    nxt[cnt]=head[temp];    head[temp]=cnt;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    ull temp=hsh[r]-hsh[l<span class="hljs-number">-1</span>]*bas[r-l+<span class="hljs-number">1</span>];    <span class="hljs-keyword">if</span>(used(temp))<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    ll sum=<span class="hljs-number">0</span>;    sum=(pre[r]-(pre[l<span class="hljs-number">-1</span>]*tbas[(r-l)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>])%MOD+MOD)%MOD;    <span class="hljs-comment">//printf("sum=%lld\n",sum);</span>    <span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-function">ll <span class="hljs-title">Manacher</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    init();    cnt=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(anew);    <span class="hljs-comment">//printf("%d\n",len);</span>    <span class="hljs-keyword">int</span> id;<span class="hljs-comment">//mx对应的回文串的对称轴所在的位置</span>    <span class="hljs-keyword">int</span> mx=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前访问到的所有回文子串，所能触及的最右一个字符的位置</span>    hsh[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;pre[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    bas[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;tbas[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)    &#123;        hsh[i]=hsh[i<span class="hljs-number">-1</span>]*base+anew[i];        bas[i]=base*bas[i<span class="hljs-number">-1</span>];        tbas[i]=(<span class="hljs-number">10</span>*tbas[i<span class="hljs-number">-1</span>])%MOD;        <span class="hljs-keyword">if</span>(anew[i]&gt;=<span class="hljs-string">'0'</span>&amp;&amp;anew[i]&lt;=<span class="hljs-string">'9'</span>)            pre[i]=(pre[i<span class="hljs-number">-1</span>]*<span class="hljs-number">10</span>+anew[i]-<span class="hljs-string">'0'</span>)%MOD;        <span class="hljs-keyword">else</span> pre[i]=pre[i<span class="hljs-number">-1</span>];    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;len;i++)</span><span class="hljs-comment">     printf("%c ",anew[i]);</span><span class="hljs-comment">     printf("\n");</span><span class="hljs-comment">     for(int i=1;i&lt;len;i++)</span><span class="hljs-comment">     printf("%lld ",pre[i]);</span><span class="hljs-comment">     printf("\n");*/</span>    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;len; i++)    &#123;        <span class="hljs-keyword">if</span>(anew[i]!=<span class="hljs-string">'#'</span>)        &#123;            <span class="hljs-comment">//printf("[%d,%d]\n",i,i);</span>            ans=(ans+solve(i,i))%MOD;        &#125;        <span class="hljs-keyword">if</span>(i&lt;mx)            p[i]=<span class="hljs-built_in">min</span>(p[<span class="hljs-number">2</span>*id-i],mx-i);<span class="hljs-comment">//这些已经算过了就不用再算</span>        <span class="hljs-keyword">else</span>            p[i]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(anew[i-p[i]]==anew[i+p[i]])<span class="hljs-comment">//扩展</span>        &#123;            <span class="hljs-keyword">if</span>(anew[i-p[i]]!=<span class="hljs-string">'#'</span>)            &#123;                <span class="hljs-comment">//printf("[%d,%d]\n",i-p[i],i+p[i]);</span>                ans=(ans+solve(i-p[i],i+p[i]))%MOD;<span class="hljs-comment">//扩展的时候要算</span>            &#125;            p[i]++;        &#125;        <span class="hljs-keyword">if</span>(mx&lt;i+p[i])<span class="hljs-comment">//最右的字符的位置要改变</span>        &#123;            id=i;            mx=i+p[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,Manacher());    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>法二：</p><p>留坑。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵计数问题 容斥/dp</title>
    <link href="/2018/09/02/%E7%9F%A9%E9%98%B5%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98-%E5%AE%B9%E6%96%A5-dp/"/>
    <url>/2018/09/02/%E7%9F%A9%E9%98%B5%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98-%E5%AE%B9%E6%96%A5-dp/</url>
    
    <content type="html"><![CDATA[<p>有一个N*M的矩形，矩形中有K块涂黑了，给出涂黑的坐标，问完全白色的矩形有几个。</p><p>根据数据范围的不同，有多种做法。</p><h4 id="Gym101350G-容斥"><a href="#Gym101350G-容斥" class="headerlink" title="Gym101350G 容斥"></a>Gym101350G 容斥</h4><p><script type="math/tex">1 ≤ N, M≤ 10^4</script>，<script type="math/tex">1 ≤K≤20</script>。</p><p><strong>思路：</strong></p><p>因为K比较小，N，M又比较大，所以可以考虑容斥。</p><p>对于一个N*M的矩形，它的子矩形有<script type="math/tex">C_{n+1}^2\times C_{m+1}^2=\frac{n(n+1)}{2}\times \frac{m(m+1)}{2}</script>个，就相当于在横的边里任意选两条，竖着的边里任意选两条，相当于选出了矩形的边界。</p><p>根据容斥原理，那就要算出包含涂黑的矩形有几个，奇加偶减，对于包含奇数个黑块的矩形，就减，对于包含偶数个黑块的矩形，就加。</p><p>如何算出包含黑块的矩形有几个？</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fuv6fvb88qj30j20d2dgk.jpg" srcset="/img/loading.gif" alt=""></p><p>只要知道minr,minc,maxr,maxc就可以了。</p><p>就相当于选矩形的四条边，最左边的那条边有minc种选法，最右边的那条边有m-maxc+1种选法，最上边的那条边有minr种选法，最下边的那条边有n-maxr+1种选法。个数为<script type="math/tex">minc*minr*(m-maxc+1)*(n-maxr+1)</script>。</p><p>所以二进制枚举容斥一下就可以了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> r,c;&#125;p[<span class="hljs-number">25</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m,k;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;p[i].r,&amp;p[i].c);        ll tot=<span class="hljs-number">1l</span>l*n*(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>*m*(m+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-comment">//printf("%lld\n",tot);</span>        <span class="hljs-keyword">int</span> minr,minc,maxr,maxc;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;k);i++)        &#123;            minr=INF;minc=INF;maxr=-INF;maxc=-INF;            <span class="hljs-keyword">int</span> cnt=__builtin_popcount(i);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k;j++)            &#123;                <span class="hljs-keyword">if</span>(i&gt;&gt;j&amp;<span class="hljs-number">1</span>)                &#123;                    minr=<span class="hljs-built_in">min</span>(minr,p[j].r);                    minc=<span class="hljs-built_in">min</span>(minc,p[j].c);                    maxr=<span class="hljs-built_in">max</span>(maxr,p[j].r);                    maxc=<span class="hljs-built_in">max</span>(maxc,p[j].c);                &#125;            &#125;            <span class="hljs-comment">//printf("%d %d %d %d\n",minr,minc,maxr,maxc);</span>            <span class="hljs-keyword">if</span>(cnt%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)tot-=<span class="hljs-number">1l</span>l*minr*minc*(n-maxr+<span class="hljs-number">1</span>)*(m-maxc+<span class="hljs-number">1</span>);            <span class="hljs-keyword">else</span> tot+=<span class="hljs-number">1l</span>l*minr*minc*(n-maxr+<span class="hljs-number">1</span>)*(m-maxc+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case #%d: %lld\n"</span>,kase,tot);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="南京网络赛B-单调栈"><a href="#南京网络赛B-单调栈" class="headerlink" title="南京网络赛B 单调栈"></a>南京网络赛B 单调栈</h4><p><script type="math/tex">1≤N≤10^5</script>，<script type="math/tex">1≤M≤100</script>，<script type="math/tex">0≤K≤10^5</script>。</p><p><strong>思路：</strong></p><p>K的范围明显不能容斥。</p><p>首先对于矩形中的每一块可以处理出它向上可以选几条边。</p><p>固定下面那条边，枚举每一块，处理出它左右可以扩展到哪里，即左右各可以选几条边（在上面选的边都可用的情况下）。</p><p>以向左扩展为例，如果左边的高度比它高或跟它相同的话，就肯定可以继续扩展过去，但是如果出现高度比它低的情况的时候，就不能扩展了。所以相当于找它的左边第一个比它低的块，这里就可以用单调栈了。如果当前元素小于等于栈顶元素的话，就把栈顶弹掉。类似于HDU1506。</p><p>向右扩展的话，要注意高度和它相同的不能再扩展了，因为扩展的话后面的往左边扩展会算进去这种情况，会造成重复。</p><p>所以对于每个块，完全空白的矩形为<script type="math/tex">h[i][j]*(j-l[j])*(r[j]-j)</script>。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> g[<span class="hljs-number">100010</span>][<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> h[<span class="hljs-number">100010</span>][<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> l[<span class="hljs-number">110</span>],r[<span class="hljs-number">110</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m,k,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);        <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(g));        <span class="hljs-keyword">while</span>(k--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);            g[x][y]=<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)            &#123;                <span class="hljs-keyword">if</span>(g[i][j]==<span class="hljs-number">1</span>)h[i][j]=<span class="hljs-number">0</span>;                <span class="hljs-keyword">else</span> h[i][j]=h[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;            &#125;        &#125;        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;s;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)            &#123;                l[j]=<span class="hljs-number">0</span>;                <span class="hljs-keyword">while</span>(!s.empty()&amp;&amp;h[i][j]&lt;=h[i][s.top()])                    s.pop();                <span class="hljs-keyword">if</span>(!s.empty())l[j]=s.top();                s.push(j);            &#125;            <span class="hljs-keyword">while</span>(!s.empty())s.pop();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m;j&gt;=<span class="hljs-number">1</span>;j--)            &#123;                r[j]=m+<span class="hljs-number">1</span>;                <span class="hljs-keyword">while</span>(!s.empty()&amp;&amp;h[i][j]&lt;h[i][s.top()])                    s.pop();                <span class="hljs-keyword">if</span>(!s.empty())r[j]=s.top();                s.push(j);            &#125;            <span class="hljs-comment">/*for(int j=1;j&lt;=m;j++)</span><span class="hljs-comment">                printf("i=%d j=%d:[%d %d]\n",i,j,j-l[j],r[j]-j);*/</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)                ans+=<span class="hljs-number">1l</span>l*h[i][j]*(j-l[j])*(r[j]-j);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case #%d: %lld\n"</span>,kase,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu2939 分层图（拆点/dp思想）</title>
    <link href="/2018/09/02/luogu2939-%E5%88%86%E5%B1%82%E5%9B%BE%EF%BC%88%E6%8B%86%E7%82%B9-DP%E6%80%9D%E6%83%B3%EF%BC%89/"/>
    <url>/2018/09/02/luogu2939-%E5%88%86%E5%B1%82%E5%9B%BE%EF%BC%88%E6%8B%86%E7%82%B9-DP%E6%80%9D%E6%83%B3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有N个结点，由M条双向边连接，每条边有权值。可以把最多k条边的权值改为0。问从1到N的最短路为多少。其中<script type="math/tex">1 <= N <= 10000</script>，<script type="math/tex">1 <= K <= 20</script>。</p><p><strong>思路：</strong></p><p>法一：拆点。</p><p>把图分为k层，层与层之间的路权值为0，每次走上一条权值为0的边相当于在层之间走。</p><p>注意数组开的大小。</p><p>如图：</p><p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fuv126yvowj30fg0c8t8w.jpg" srcset="/img/loading.gif" alt=""></p><p>法二：DP思想。</p><p><script type="math/tex">dis[i][j]</script>：到第i个结点把j条边权值改为0的最短路。</p><p>根据松弛有<script type="math/tex">dis[p][j]=min(dis[i][j]+w(i,p))</script>，还有一种转移是层与层之间，即权值为0的情况，<script type="math/tex">dis[p][j+1]=min(dis[i][j]+0)</script>。</p><p>复杂度为<script type="math/tex">O(nklog(nk))</script>。</p><p><strong>代码：</strong></p><p>法一：</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span><span class="hljs-keyword">int</span> top;<span class="hljs-keyword">int</span> head[<span class="hljs-number">500010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    ll cost;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">5000010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,ll c)</span></span><span class="hljs-function"></span>&#123;    eg[top].cost=c;    eg[top].to=b;    eg[top].next=head[a];    head[a]=top++;&#125;<span class="hljs-keyword">typedef</span> pair&lt;ll,<span class="hljs-keyword">int</span>&gt;p;ll dis[<span class="hljs-number">500010</span>];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">fill</span>(dis+<span class="hljs-number">1</span>,dis+n+<span class="hljs-number">1</span>,INF);    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    priority_queue&lt;p,<span class="hljs-built_in">vector</span>&lt;p&gt;,greater&lt;p&gt; &gt;q;    q.push(p(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        p temp=q.top();        q.pop();        ll w=temp.first;        <span class="hljs-keyword">int</span> id=temp.second;        <span class="hljs-keyword">if</span>(w&gt;dis[id])<span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            edge &amp;e=eg[i];            <span class="hljs-keyword">if</span>(w+e.cost&lt;dis[e.to])            &#123;                dis[e.to]=w+e.cost;                q.push(p(dis[e.to],e.to));            &#125;        &#125;    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        printf("%lld ",dis[i]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,k,x,y;    ll w;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%lld"</span>,&amp;x,&amp;y,&amp;w);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;i++)        &#123;            add(x+i*n,y+i*n,w);            add(y+i*n,x+i*n,w);            <span class="hljs-keyword">if</span>(i!=k)            &#123;                add(x+i*n,y+(i+<span class="hljs-number">1</span>)*n,<span class="hljs-number">0</span>);                add(y+i*n,x+(i+<span class="hljs-number">1</span>)*n,<span class="hljs-number">0</span>);            &#125;        &#125;    &#125;    n=(k+<span class="hljs-number">1</span>)*n;    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">    &#123;</span><span class="hljs-comment">        for(int j=head[i];j!=-1;j=eg[j].next)</span><span class="hljs-comment">            printf("%d ",eg[j].to);</span><span class="hljs-comment">        printf("\n");</span><span class="hljs-comment">    &#125;*/</span>    dijkstra();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,dis[n]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>法二：</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span><span class="hljs-keyword">int</span> top;<span class="hljs-keyword">int</span> head[<span class="hljs-number">10010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    ll cost;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,ll c)</span></span><span class="hljs-function"></span>&#123;    eg[top].cost=c;    eg[top].to=b;    eg[top].next=head[a];    head[a]=top++;&#125;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; pp;<span class="hljs-keyword">typedef</span> pair&lt;ll,pp&gt;p;ll dis[<span class="hljs-number">10010</span>][<span class="hljs-number">25</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">10010</span>][<span class="hljs-number">25</span>];<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> k;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    dis[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    priority_queue&lt;p,<span class="hljs-built_in">vector</span>&lt;p&gt;,greater&lt;p&gt; &gt;q;    q.push(p(<span class="hljs-number">0</span>,pp(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)));    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        p temp=q.top();        q.pop();        ll w=temp.first;        <span class="hljs-keyword">int</span> id=temp.second.first;        <span class="hljs-keyword">int</span> cur=temp.second.second;        <span class="hljs-keyword">if</span>(vis[id][cur])<span class="hljs-keyword">continue</span>;        vis[id][cur]=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            edge &amp;e=eg[i];            <span class="hljs-keyword">if</span>(w+e.cost&lt;dis[e.to][cur])            &#123;                dis[e.to][cur]=w+e.cost;                q.push(p(dis[e.to][cur],pp(e.to,cur)));            &#125;            <span class="hljs-keyword">if</span>(cur&lt;k&amp;&amp;w&lt;dis[e.to][cur+<span class="hljs-number">1</span>])            &#123;                dis[e.to][cur+<span class="hljs-number">1</span>]=w;                q.push(p(dis[e.to][cur+<span class="hljs-number">1</span>],pp(e.to,cur+<span class="hljs-number">1</span>)));            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,x,y;    ll w;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%lld"</span>,&amp;x,&amp;y,&amp;w);        add(x,y,w);        add(y,x,w);    &#125;    dijkstra();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,dis[n][k]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京网络赛E 状压dp（反省...)</title>
    <link href="/2018/09/01/%E5%8D%97%E4%BA%AC%E7%BD%91%E7%BB%9C%E8%B5%9BE-%E7%8A%B6%E5%8E%8Bdp%EF%BC%88%E5%8F%8D%E7%9C%81/"/>
    <url>/2018/09/01/%E5%8D%97%E4%BA%AC%E7%BD%91%E7%BB%9C%E8%B5%9BE-%E7%8A%B6%E5%8E%8Bdp%EF%BC%88%E5%8F%8D%E7%9C%81/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n道题，有<script type="math/tex">a_i</script>和<script type="math/tex">b_i</script>两个值，每道题得在m道题做完之后才能做，给出了这m道题。如果第t个做出这道题目的话，得到的价值为<script type="math/tex">a_i*t+b_i</script>。问最大价值为多少。其中<script type="math/tex">0<n≤20</script>。</p><p><strong>思路：</strong></p><p>可以看出来是一道状压dp。</p><p>可是我想到了这可以画出一张图然后就走上了一条不归路…比赛的时候连二维还是一维都没有考虑好…还想好难转移…真的智障啊…</p><p>怎么就不能好好思考一下呢…</p><p>很明显这一维就够了，顺序的不同造成的结果不同就更新dp就好了。</p><p>转移也就很明显了，根据题目给的先决条件位运算判断一下是否合法就好了。</p><p>比赛的时候真的不在状态啊…可能最近太颓废了…</p><p>难受…</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span>ll a[<span class="hljs-number">25</span>],b[<span class="hljs-number">25</span>];<span class="hljs-keyword">int</span> pre[<span class="hljs-number">25</span>];ll dp[<span class="hljs-number">1100000</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)        dp[i]=-INF;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;a[i],&amp;b[i]);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)dp[<span class="hljs-number">1</span>&lt;&lt;i]=a[i]+b[i];        pre[i]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(m--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            x--;            pre[i]+=<span class="hljs-number">1</span>&lt;&lt;x;        &#125;    &#125;    <span class="hljs-comment">/*for(int i=0;i&lt;n;i++)</span><span class="hljs-comment">        printf("pre[%d]=%d\n",i,pre[i]);*/</span>    ll ans=<span class="hljs-number">0</span>;    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)        &#123;            <span class="hljs-keyword">if</span>(i&gt;&gt;j&amp;<span class="hljs-number">1</span>)            &#123;                <span class="hljs-keyword">int</span> temp=i-(<span class="hljs-number">1</span>&lt;&lt;j);                <span class="hljs-keyword">if</span>((temp&amp;pre[j])==pre[j])                &#123;                    <span class="hljs-keyword">int</span> cnt=__builtin_popcount(temp);                    <span class="hljs-comment">//printf("i=%d temp=%d cnt=%d\n",i,temp,cnt);</span>                    dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[temp]+a[j]*(cnt+<span class="hljs-number">1</span>)+b[j]);                    <span class="hljs-comment">//printf("dp[%d]=%lld\n",i,dp[i]);</span>                    ans=<span class="hljs-built_in">max</span>(ans,dp[i]);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bzoj2002 分块 &amp; HDU6394</title>
    <link href="/2018/09/01/bzoj2002-%E5%88%86%E5%9D%97-HDU6394/"/>
    <url>/2018/09/01/bzoj2002-%E5%88%86%E5%9D%97-HDU6394/</url>
    
    <content type="html"><![CDATA[<h5 id="bzoj2002"><a href="#bzoj2002" class="headerlink" title="bzoj2002"></a>bzoj2002</h5><p><strong>题意：</strong></p><p>一条直线上有n个装置，每个装置设定初始弹力系数<script type="math/tex">k_i</script>，当达到第i个装置时，它会往后弹<script type="math/tex">k_i</script>步，达到第<script type="math/tex">i+k_i</script>个装置，若不存在第<script type="math/tex">i+k_i</script>个装置，则绵羊被弹飞。</p><p>有两种操作：</p><p>1 x：当它从第i个装置起步时，被弹几次后会被弹飞。</p><p>2 x y：修改第x个弹力装置的弹力系数为y。</p><p><strong>思路：</strong></p><p>因为直接暴力的话一步一步弹太慢了，是<script type="math/tex">O(n)</script>的，可以考虑分块提前把弹几步处理出来，这样就可以把弹的复杂度变成<script type="math/tex">O(\sqrt n)</script>。</p><p>所以要处理出来每一个装置到下一块的落点和步数。</p><p>分为三种情况：</p><p>1.下一步直接弹出：pos=-1,step=1；</p><p>2.下一步弹到块内：pos=pos[Next[i]],step=step[Next[i]]+1；</p><p>3.下一步弹到后面的块内：pos=Next[i],step=1。</p><p>对于查询，循环求出步数。</p><p>对于修改，因为一个装置的修改会影响到块内装置的信息，所以从后往前更新块内装置的信息即可。</p><p>复杂度为<script type="math/tex">O(m*\sqrt n)</script>。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> num;<span class="hljs-comment">//分块的个数</span><span class="hljs-keyword">int</span> belong[<span class="hljs-number">200010</span>];<span class="hljs-comment">//每个数属于哪个分块</span><span class="hljs-keyword">int</span> block;<span class="hljs-comment">//每个块的大小</span><span class="hljs-keyword">int</span> lef[<span class="hljs-number">200010</span>],rig[<span class="hljs-number">200010</span>];<span class="hljs-comment">//该块的左/右端点位置</span><span class="hljs-keyword">int</span> pos[<span class="hljs-number">200010</span>],<span class="hljs-built_in">step</span>[<span class="hljs-number">200010</span>];<span class="hljs-comment">//到下一块的落地位置/最小步数</span><span class="hljs-keyword">int</span> Next[<span class="hljs-number">200010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    block=<span class="hljs-built_in">sqrt</span>(n);    num=n/block;<span class="hljs-keyword">if</span>(n%block)num++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        belong[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)    &#123;        lef[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>;        rig[i]=i*block;    &#125;    rig[num]=n;<span class="hljs-comment">//最后一块不满的情况</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    build();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;Next[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)    &#123;        <span class="hljs-keyword">if</span>(i+Next[i]&gt;n)<span class="hljs-comment">//直接弹出</span>        &#123;            pos[i]=<span class="hljs-number">-1</span>;            <span class="hljs-built_in">step</span>[i]=<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i+Next[i]&lt;=rig[belong[i]])<span class="hljs-comment">//在同一块内</span>        &#123;            pos[i]=pos[i+Next[i]];            <span class="hljs-built_in">step</span>[i]=<span class="hljs-built_in">step</span>[i+Next[i]]+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span><span class="hljs-comment">//弹出当前块</span>        &#123;            pos[i]=i+Next[i];            <span class="hljs-built_in">step</span>[i]=<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">int</span> m,op;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;op);        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)   <span class="hljs-comment">//查询</span>        &#123;            <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>,cur;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;cur);            cur++;            <span class="hljs-keyword">while</span>(cur!=<span class="hljs-number">-1</span>)            &#123;                ans+=<span class="hljs-built_in">step</span>[cur];                cur=pos[cur];            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">int</span> x,y;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);<span class="hljs-comment">//把x装置变为系数变为y</span>            x++;            Next[x]=y;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&gt;=lef[belong[x]];i--)            &#123;                <span class="hljs-keyword">if</span>(i+Next[i]&gt;n)<span class="hljs-comment">//直接弹出</span>                &#123;                    pos[i]=<span class="hljs-number">-1</span>;                    <span class="hljs-built_in">step</span>[i]=<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i+Next[i]&lt;=rig[belong[i]])<span class="hljs-comment">//在同一块内</span>                &#123;                    pos[i]=pos[i+Next[i]];                    <span class="hljs-built_in">step</span>[i]=<span class="hljs-built_in">step</span>[i+Next[i]]+<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">else</span><span class="hljs-comment">//弹出当前块</span>                &#123;                    pos[i]=i+Next[i];                    <span class="hljs-built_in">step</span>[i]=<span class="hljs-number">1</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="HDU6394"><a href="#HDU6394" class="headerlink" title="HDU6394"></a>HDU6394</h5><p>update…</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>__builtin_系列函数</title>
    <link href="/2018/08/31/builtin-%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0/"/>
    <url>/2018/08/31/builtin-%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>1.<strong>__builtin_popcount(unsigned int n)</strong>：返回x的二进制下1的个数。</p><p>2.<strong>__builtin_parity(unsigned int n)</strong>：返回x二进制下1的个数的奇偶性（偶数个输出0，奇数个输出1）。</p><p>3.<strong>__builtin_ffs(unsigned int n)</strong>：返回x的最后一位1的是从后向前第几位 （从1开始）。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>;<span class="hljs-comment">//1</span><span class="hljs-keyword">int</span> m = <span class="hljs-number">8</span>;<span class="hljs-comment">//1000</span><span class="hljs-built_in">cout</span>&lt;&lt;__builtin_ffs(n)&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出1</span><span class="hljs-built_in">cout</span>&lt;&lt;__builtin_ffs(m)&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出4</span></code></pre><p>4.<strong>__builtin_clz (unsigned int x)</strong>：返回x二进制下最高有效位到最高位的1上一位的长度（即最高位开始连续0的个数）。</p><p>5.<strong>__builtin_ctz(unsigned int n)</strong>：返回x的二进制下最低位开始连续0的个数（即__builtin_ffs(x)-1）。</p><p>以上的返回类型都是unsigned int，只要在函数名后面加上ll，即可返回unsigned longlong，e.g.:__builtinbuiltin_popcountll(x)。</p><p>其他：用如下指令可以将__builtin_popcount被编译器识别为一条指令，加快运行速度。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> GCC target (<span class="hljs-meta-string">"popcnt"</span>)</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU5527 逆向思维+贪心+dfs</title>
    <link href="/2018/08/30/HDU5527-%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4-%E8%B4%AA%E5%BF%83-%E6%90%9C%E7%B4%A2/"/>
    <url>/2018/08/30/HDU5527-%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4-%E8%B4%AA%E5%BF%83-%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出一个价格n和一些零钱的数量<script type="math/tex">c_1,c_5,c_{10},c_{20},c_{50},c_{100},c_{200},c_{500},c_{1000},c_{2000}</script>。求最多用多少零钱凑出这个n。</p><p><strong>思路：</strong></p><p>用最少的零钱凑会比用最多的零钱凑好考虑。</p><p>如果零钱是1,5,10,50,100,200,1000,2000的话，就可以从大到小直接贪心取，就是每个零钱都是后面一个的约数的时候就可以直接贪心取。但是题目这种情况就不能这么做了，比如20,20,20,50,50，要取110，如果用这种策略的话，是凑不到110的，实际上是可以20+20+20+50的，50要少取一张。所以搜索一下两种情况，取满和取满-1。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> ll INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;ll val[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">500</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">2000</span>&#125;;ll num[<span class="hljs-number">10</span>];ll ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,ll sum,ll cnt)</span><span class="hljs-comment">//当前种类/钱数/张数</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>)    &#123;        <span class="hljs-comment">//printf("cnt=%lld\n",cnt);</span>        ans=<span class="hljs-built_in">min</span>(ans,cnt);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(id==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span>;    ll temp=<span class="hljs-built_in">min</span>(num[id],sum/val[id]);    <span class="hljs-comment">//printf("id=%d sum=%lld temp=%lld\n",id,sum,temp);</span>    dfs(id<span class="hljs-number">-1</span>,sum-temp*val[id],cnt+temp);    <span class="hljs-keyword">if</span>(temp&gt;<span class="hljs-number">0</span>)dfs(id<span class="hljs-number">-1</span>,sum-(temp<span class="hljs-number">-1</span>)*val[id],cnt+temp<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    ll sum;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;sum);        ll tot=<span class="hljs-number">0</span>;<span class="hljs-comment">//总钱数</span>        ll cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//总张数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;num[i]);            tot+=val[i]*num[i];            cnt+=num[i];        &#125;        sum=tot-sum;        <span class="hljs-keyword">if</span>(sum&lt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-comment">//printf("sum=%lld cnt=%lld\n",sum,cnt);</span>        ans=INF;        dfs(<span class="hljs-number">9</span>,sum,<span class="hljs-number">0</span>);        <span class="hljs-comment">//printf("ans=%lld\n",ans);</span>        <span class="hljs-keyword">if</span>(ans==INF)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,cnt-ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6444 循环节+单调队列优化dp</title>
    <link href="/2018/08/29/HDU6444-%E5%BE%AA%E7%8E%AF%E8%8A%82-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp/"/>
    <url>/2018/08/29/HDU6444-%E5%BE%AA%E7%8E%AF%E8%8A%82-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n个数形成一个环，问走最多走m次，每次k步，可以从任意位置开始，问得到的最大价值为多少。</p><p><strong>思路：</strong></p><p>对于一个环，固定步数下是有循环节的。不同循环节内的节点各不相同，根据裴蜀定理可得每个循环节的长度为n/gcd(n, k)。</p><p>所以暴力求出所有循环节。对于每个循环节，可以走k步，可知圈数num和圈数外的c，所以有两种情况：</p><ol><li><p>走num圈，并且对于不够整个循环节的c，求这个循环节的长度不超过c的最大子段和。</p></li><li><p>有时候走num-1圈，然后取循环节的长度不超过len的最大子段和会更优。</p><p>如这组数据：</p><blockquote><p>1<br>5 100 12 1<br>-10 1 2 3 5</p><p>ans：1 2 3 5 -10 1 2 3 5</p><p>max = 12</p></blockquote></li></ol><p>这里要注意有负环的情况，这时候圈数就不用走了，直接走其他的就行（见注释处）。</p><p>求不超过某个长度的最大子段和用单调队列优化的dp就可以了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span>ll a[<span class="hljs-number">10010</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">10010</span>];<span class="hljs-built_in">vector</span>&lt;ll&gt;v[<span class="hljs-number">10010</span>];<span class="hljs-comment">//循环节</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> pos;    ll val;&#125;;ll cur[<span class="hljs-number">20010</span>];ll pre[<span class="hljs-number">20010</span>];ll dp[<span class="hljs-number">20010</span>];<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n=v[id].<span class="hljs-built_in">size</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        cur[i]=v[id][i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;i++)        cur[i]=v[id][i-n<span class="hljs-number">-1</span>];    n*=<span class="hljs-number">2</span>;    pre[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        pre[i]=pre[i<span class="hljs-number">-1</span>]+cur[i];    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        printf("%lld ",pre[i]);</span><span class="hljs-comment">    printf("\n");*/</span>    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">deque</span>&lt;node&gt;q;    node temp;    temp.pos=<span class="hljs-number">0</span>;temp.val=<span class="hljs-number">0</span>;    q.push_back(temp);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        dp[i]=cur[i];        <span class="hljs-keyword">while</span>(!q.empty()&amp;&amp;(i-q.front().pos)&gt;c)            q.pop_front();        <span class="hljs-keyword">if</span>(!q.empty())            dp[i]=<span class="hljs-built_in">max</span>(dp[i],pre[i]-q.front().val);        ans=<span class="hljs-built_in">max</span>(ans,dp[i]);        temp.pos=i;temp.val=pre[i];        <span class="hljs-keyword">while</span>(!q.empty()&amp;&amp;temp.val&lt;=q.back().val)            q.pop_back();        q.push_back(temp);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m,k;    ll s;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%lld%d%d"</span>,&amp;n,&amp;s,&amp;m,&amp;k);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-keyword">if</span>(!vis[i])            &#123;                cnt++;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;!vis[j];j=(j+k)%n)                &#123;                    v[cnt].push_back(a[j]);                    vis[j]=<span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-comment">/*for(int i=1;i&lt;=cnt;i++)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            for(int j=0;j&lt;v[i].size();j++)</span><span class="hljs-comment">                printf("%lld ",v[i][j]);</span><span class="hljs-comment">            printf("\n");</span><span class="hljs-comment">        &#125;*/</span>        ll tot=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)        &#123;            <span class="hljs-keyword">int</span> len=v[i].<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">int</span> num=m/len;<span class="hljs-comment">//圈数</span>            <span class="hljs-keyword">int</span> c=m%len;<span class="hljs-comment">//多的</span>            ll sum=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;v[i].<span class="hljs-built_in">size</span>();j++)                sum+=v[i][j];            <span class="hljs-comment">//printf("num=%d c=%d sum=%lld\n",num,c,sum);</span>            ll temp1=solve(i,c);            ll temp2=solve(i,len);            ll ans1=<span class="hljs-built_in">max</span>(<span class="hljs-number">0l</span>l,sum)*num+temp1;<span class="hljs-comment">//负环也有可能选几个成立</span>            ll ans2=<span class="hljs-built_in">max</span>(<span class="hljs-number">0l</span>l,sum)*<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,num<span class="hljs-number">-1</span>)+temp2;            tot=<span class="hljs-built_in">max</span>(tot,<span class="hljs-built_in">max</span>(ans1,ans2));        &#125;        <span class="hljs-comment">//printf("tot=%lld\n",tot);</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case #%d: "</span>,kase);        <span class="hljs-keyword">if</span>(tot&gt;=s)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,s-tot);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)            v[i].<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces1011E 裴蜀定理</title>
    <link href="/2018/08/27/CodeForces1011-%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"/>
    <url>/2018/08/27/CodeForces1011-%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有一个计数器，计数器的初始值为0，每次操作你可以把计数器的值加上<script type="math/tex">a_1,a_2,...,a_n</script>中的任意一个整数，操作次数不限（可以为0次），问计数器的值对m取模后有几种可能，并输出这些可能。</p><p><strong>思路：</strong></p><p>裴蜀定理：</p><p>对任何整数a、b和它们的最大公约数d，关于未知数x和y的<script type="math/tex">ax+by=m</script>有整数解时当且仅当m是d的倍数。</p><p>特别地，<script type="math/tex">ax+by=1</script>有整数解当且仅当整数a和b互质。</p><p>设<script type="math/tex">a_1,a_2,a_3......a_n</script>为n个整数，d是它们的最大公约数，那么存在整数<script type="math/tex">x_1...x_n</script>使得<script type="math/tex">x_1*a_1+x_2*a_2+...+x_n*a_n=d</script>。</p><p>对于这道题，有<script type="math/tex">(k_1*a_1+k_2*a_2+...+k_n*a_n)\%m=x</script>，则有<script type="math/tex">k_1*a_1+k_2*a_2+...+k_n*a_n-k_m*m=x</script>，则当x为<script type="math/tex">gcd(a_1,a_2,...,m)</script>的倍数时该方程有整数解。</p><p>另，对于一个环，每个循环节的长度为n/gcd(n, k)，k为每次走的步数。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a&lt;b)&#123;ll temp;temp=a;a=b;b=temp;&#125;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">while</span>(a%b)&#123;ll r=a%b;a=b;b=r;&#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    ll m,x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%lld"</span>,&amp;n,&amp;m);    ll g=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;x);        g=gcd(g,x);    &#125;    g=gcd(g,m);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,m/g);    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>;i&lt;m;i+=g)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld "</span>,i);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6438 贪心+优先队列</title>
    <link href="/2018/08/26/HDU6438-%E8%B4%AA%E5%BF%83-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2018/08/26/HDU6438-%E8%B4%AA%E5%BF%83-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出n天，每天可以买进或者卖出或者不买不卖，价格是这一天的权值，问最多利润是多少，如果利润相同的有多种，取操作数最小的那种。输出最多利润与操作数。</p><p><strong>思路：</strong></p><p>这道题队友似乎最后想出来了啊？可是来不及写了…</p><p>用小顶堆维护。</p><p>如果当前输入为x，当堆为空或者堆顶元素大于等于x时，把x放入堆中（因为如果利润相同要操作数最小，所以等于也要放入堆中，而不是买卖）。</p><p>否则删除堆顶元素，将x在堆中放两遍，</p><ul><li>抵消这一次的卖出，用后面更大的数来换掉它；</li><li>把这一次当成买入。</li></ul><p>如何统计操作数呢？</p><p>因为会出现抵消的情况，那么抵消这里应该不能算，所以开个vis数组标记一下。</p><p>又因为要使操作数最小，所以抵消的时候如果有相同数值，就随便抵消哪一个，而不是一定要上一个出现卖的那个地方。所以数组下标是权值。</p><p>手动模拟一下就会发现很有道理。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-built_in">map</span>&lt;ll,<span class="hljs-keyword">int</span>&gt;vis;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n;    ll x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        priority_queue&lt;ll,<span class="hljs-built_in">vector</span>&lt;ll&gt;,greater&lt;ll&gt; &gt;q;        vis.<span class="hljs-built_in">clear</span>();        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;x);            <span class="hljs-keyword">if</span>(q.empty()||q.top()&gt;=x)                q.push(x);            <span class="hljs-keyword">else</span>            &#123;                ans+=x-q.top();                <span class="hljs-keyword">if</span>(vis[q.top()])                    vis[q.top()]--;                <span class="hljs-keyword">else</span> num+=<span class="hljs-number">2</span>;                q.pop();                vis[x]++;                q.push(x);                q.push(x);            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld %d\n"</span>,ans,num);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树上启发式合并 Dsu on tree</title>
    <link href="/2018/08/24/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6-Dsu-on-tree/"/>
    <url>/2018/08/24/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6-Dsu-on-tree/</url>
    
    <content type="html"><![CDATA[<p>树上启发式合并可以用于解决子树的问题，但是不可以带修改。</p><p>来看一道例题：</p><h5 id="CodeForces600C"><a href="#CodeForces600C" class="headerlink" title="CodeForces600C"></a>CodeForces600C</h5><p><strong>题意：</strong></p><p>给出一棵树，每个结点有一种颜色，求每个结点的子树中出现次数最多的颜色，如果有多个出现次数最多的颜色，则将它们相加。</p><p><strong>思路：</strong></p><p>如果只是求子树的种类数的话似乎用dfs序+莫队也可以做？</p><p>考虑最暴力的<script type="math/tex">O(n^2)</script>做法，枚举每个点，暴力访问子树中的点，统计完以后将统计的num数组清空。</p><p>其实num数组清空是浪费的，因为对于它的父亲结点，也会用到它的子树的信息。</p><p>启发式就体现在这里，对于一个结点，让大的子树不清空，所以先树剖出它的重儿子，重儿子就保留子树上的信息。</p><p>所以步骤是这样的：</p><p>1.树剖出重儿子；</p><p>2.DFS遍历子树，先遍历轻儿子，再遍历重儿子；</p><p>3.如果当前根结点是重儿子，就不将信息清空，否则就清空。</p><p>时间复杂度为<script type="math/tex">O(nlogn*x)</script>，<script type="math/tex">x</script>为外部维护的时间。</p><p>时间复杂度的证明：</p><blockquote><p>只有dfs到轻边时，才会将轻边的子树中合并到上一级的重链，树链剖分将一棵树分割成了不超过<script type="math/tex">logn</script>条重链。每一个节点最多向上合并<script type="math/tex">logn</script>次，单次修改复杂度<script type="math/tex">O(1)</script>。所以整体复杂度是<script type="math/tex">O(nlogn)</script>的。</p></blockquote><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">200010</span>];<span class="hljs-keyword">int</span> val[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> head[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> top;<span class="hljs-keyword">int</span> par[<span class="hljs-number">100010</span>],son[<span class="hljs-number">100010</span>],tot[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> num[<span class="hljs-number">100010</span>];<span class="hljs-comment">//颜色出现的次数</span><span class="hljs-keyword">int</span> cnt;<span class="hljs-comment">//当前出现最多的颜色出现的次数</span>ll sum;<span class="hljs-comment">//当前答案</span>ll ans[<span class="hljs-number">100010</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> fa)</span><span class="hljs-comment">//处理出重儿子</span></span><span class="hljs-function"></span>&#123;    par[id]=fa;tot[id]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>;    son[id]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(temp==fa)<span class="hljs-keyword">continue</span>;        tot[id]+=dfs1(temp,id);        <span class="hljs-keyword">if</span>(tot[temp]&gt;maxson)        &#123;            son[id]=temp;            maxson=tot[temp];        &#125;    &#125;    <span class="hljs-keyword">return</span> tot[id];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> f)</span></span><span class="hljs-function"></span>&#123;    num[val[id]]+=f;    <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>&amp;&amp;num[val[id]]==cnt)sum+=<span class="hljs-number">1l</span>l*val[id];    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>&amp;&amp;num[val[id]]&gt;cnt)    &#123;        cnt=num[val[id]];        sum=<span class="hljs-number">1l</span>l*val[id];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(temp!=par[id]&amp;&amp;!vis[temp])<span class="hljs-comment">//重儿子不用访问，这里不用son[id]来判断的原因是轻儿子的重儿子仍然是要访问的</span>            calc(temp,f);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">bool</span> tp)</span><span class="hljs-comment">//tp:是否是重儿子</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(temp!=par[id]&amp;&amp;temp!=son[id])            dfs2(temp,<span class="hljs-literal">false</span>);    &#125;    <span class="hljs-keyword">if</span>(son[id])    &#123;        dfs2(son[id],<span class="hljs-literal">true</span>);        vis[son[id]]=<span class="hljs-literal">true</span>;    &#125;    calc(id,<span class="hljs-number">1</span>);ans[id]=sum;    <span class="hljs-keyword">if</span>(son[id])vis[son[id]]=<span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span>(!tp)    &#123;        calc(id,<span class="hljs-number">-1</span>);        cnt=<span class="hljs-number">0</span>;sum=<span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;val[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        add(x,y);add(y,x);    &#125;    dfs1(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    sum=cnt=<span class="hljs-number">0</span>;    dfs2(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld "</span>,ans[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6435 k维最远曼哈顿距离</title>
    <link href="/2018/08/22/HDU6435-k%E7%BB%B4%E6%9C%80%E8%BF%9C%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/"/>
    <url>/2018/08/22/HDU6435-k%E7%BB%B4%E6%9C%80%E8%BF%9C%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出一堆n个东西和另一堆m个东西，每个东西有一个分数S和k个属性值。让你在n个东西和m个东西里各选一件，使<script type="math/tex">S_{nw}+S_{mw}+\sum_{i=1}^k|x_{nw}[i]-x_{mw}[i]|</script>最大。其中<script type="math/tex">K<=5, \sum(n+m)<=300000</script>。</p><p><strong>思路：</strong></p><p>想到了多维曼哈顿距离…然而想到了之前做过的一道从一堆点里选一个点让其他点到它的曼哈顿距离最短的那道题…怎么会想到那道题呢…明显是不同的东西啊…</p><p>S的部分是好处理的，考虑绝对值求和部分。</p><p>考虑最简单的情况，k=2：</p><p><script type="math/tex">|x_1-x_2|+|y_1-y_2|</script>把绝对值去掉，有四种情况：</p><p><script type="math/tex">x_1-x_2+y_1-y_2，x_1-x_2-y_1+y_2，-x_1+x_2+y_1-y_2,-x_1+x_2-y_1+y_2</script>，</p><p>把<script type="math/tex">(x_1,y_1)，(x_2,y_2)</script>提出来，有</p><p><script type="math/tex">(x_1+y_1)-(x_2+y_2)，(x_1-y_1)-(x_2-y_2)，(-x_1+y_1)-(-x_2+y_2)，(-x_1-y_1)-(-x_2-y_2)</script>。</p><p>所以只要二进制枚举符号，n个东西里取S+k维曼哈顿距离最大的，m个东西里取-S+k维曼哈顿距离最小的，相减来更新答案就可以了。复杂度为<script type="math/tex">O(2^k*k*n)</script>。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span>ll ns[<span class="hljs-number">100010</span>];ll nx[<span class="hljs-number">100010</span>][<span class="hljs-number">10</span>];ll ms[<span class="hljs-number">100010</span>];ll mx[<span class="hljs-number">100010</span>][<span class="hljs-number">10</span>];ll nn[<span class="hljs-number">100010</span>],mm[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m,num;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;num);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;ns[i]);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;num;j++)                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;nx[i][j]);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;ms[i]);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;num;j++)                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;mx[i][j]);        &#125;        ll ans=-INF;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;num);i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)                nn[j]=ns[j];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)                mm[j]=-ms[j];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;num;j++)            &#123;                <span class="hljs-comment">//printf("%d",i&gt;&gt;j&amp;1);</span>                <span class="hljs-keyword">if</span>((i&gt;&gt;j&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)<span class="hljs-comment">//+</span>                &#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)                        nn[k]+=nx[k][j];                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;m;k++)                        mm[k]+=mx[k][j];                &#125;                <span class="hljs-keyword">else</span>                &#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)                        nn[k]-=nx[k][j];                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;m;k++)                        mm[k]-=mx[k][j];                &#125;            &#125;            <span class="hljs-comment">//printf("\n");</span>            ll MAX=-INF,MIN=INF;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)                MAX=<span class="hljs-built_in">max</span>(MAX,nn[j]);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)                MIN=<span class="hljs-built_in">min</span>(MIN,mm[j]);            ans=<span class="hljs-built_in">max</span>(ans,MAX-MIN);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树链剖分</title>
    <link href="/2018/08/22/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    <url>/2018/08/22/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>参考博客：</p><p><a href="http://www.cnblogs.com/zwfymqz/p/8094500.html" target="_blank" rel="noopener">http://www.cnblogs.com/zwfymqz/p/8094500.html</a></p><p><a href="https://www.cnblogs.com/ivanovcraft/p/9019090.html" target="_blank" rel="noopener">https://www.cnblogs.com/ivanovcraft/p/9019090.html</a> </p><p><a href="http://www.cnblogs.com/chinhhh/p/7965433.html" target="_blank" rel="noopener">http://www.cnblogs.com/chinhhh/p/7965433.html</a></p><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p><strong>重儿子</strong>：父亲节点的所有儿子中子树结点数目最多（size最大）的结点；</p><p><strong>轻儿子</strong>：父亲节点中除了重儿子以外的儿子； </p><p><strong>重边</strong>：父亲结点和重儿子连成的边；</p><p><strong>轻边</strong>：父亲节点和轻儿子连成的边；</p><p><strong>重链</strong>：由多条重边连接而成的路径；</p><ul><li>对于叶子节点，若其为轻儿子，则有一条以自己为起点的长度为1的链</li><li>每一条重链以轻儿子为起点</li></ul><p><strong>轻链</strong>：由多条轻边连接而成的路径；</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuitu9hywkj30o00cn74s.jpg" srcset="/img/loading.gif" alt=""></p><p>如何对这些链进行维护？</p><p>首先，要对这些链进行维护，就要确保每个链上的节点都是连续的，因此我们需要对整棵树进行<strong>重新编号</strong>，然后利用dfs序的思想，用线段树或树状数组等进行维护。</p><p>对于一棵最基本的树：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fuituwzk28j30db0cv0so.jpg" srcset="/img/loading.gif" alt=""></p><p>给他标记重儿子：</p><p> <img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuitv5izbcj30cr0cqjrd.jpg" srcset="/img/loading.gif" alt=""></p><p>蓝色为重儿子，红色为重边。</p><p>然后对树进行重新编号：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fuitvffpavj30br0cmmx5.jpg" srcset="/img/loading.gif" alt=""></p><p>橙色表示的是该节点重新编号后的序号。</p><p>不难看出重链内的节点编号是连续的。</p><p>有一个性质：<strong>以i为根的子树的树在线段树上的编号为[i,i+子树节点数−1]</strong> 。</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>1.对整棵树dfs一遍，找出每个节点的重儿子。处理出每个节点的深度，以及他们的父亲节点。</p><p>处理出这些：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> par[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点的父亲，用来往上跳</span><span class="hljs-keyword">int</span> dep[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点的深度，用来往上跳</span><span class="hljs-keyword">int</span> tot[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点子树的结点个数，用来更新权值和</span><span class="hljs-keyword">int</span> son[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点的重儿子编号</span></code></pre><p>2.对整棵树进行重新编号。</p><p>处理出这些：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> idx[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点重新编号后的编号</span><span class="hljs-keyword">int</span> topp[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点所在链的顶端结点</span><span class="hljs-keyword">int</span> aval[<span class="hljs-number">100010</span>];<span class="hljs-comment">//重新编号后该结点的权值</span></code></pre><p>3.根据重新编完号的树，把这棵树的上每个点映射到线段树上。并写出线段树的基本操作函数。</p><p>4.实现对于树上的操作，</p><p>树链剖分的思想是:<strong>对于两个不在同一重链内的节点,让他们不断地跳,使得他们处于同一重链上</strong>。</p><p>那么如何”跳”呢？</p><p>用到top数组么？</p><p>有一个显然的结论：x到top[x]中的节点在线段树上是连续的。</p><p>结合deep数组，</p><p>假设两个节点为x,y，</p><p>我们每次让deep[top[x]]与deep[top[y]]中大的(在下面的)往上跳(有点类似于树上倍增)，</p><p>让x节点直接跳到top[x]，然后在线段树上更新，</p><p>最后两个节点一定是处于同一条重链的，前面我们提到过重链上的节点都是连续的，直接在线段树上进行一次查询就好。</p><p>结合一个例子说明：</p><p>还是上面那张图，假设我们要查询3.6这两个节点的之间的点权合，为了方便理解我们假设每个点的点权都是1，</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fuitvu4u5wj30aq0bk0sp.jpg" srcset="/img/loading.gif" alt=""></p><p>刚开始时</p><p>top[3]=2,top[6]=1，</p><p>deep[top[3]]=2,deep[top[6]]=1，</p><p>我们会让3向上跳,跳到top[3]的爸爸,也就是1号节点</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuitw3q82dj30a40bc749.jpg" srcset="/img/loading.gif" alt=""></p><p>这是1号节点和6号节点已经在同一条重链内,所以直接对线段树进行一次查询即可。</p><p>对于子树的操作，利用性质直接query或update。</p><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p><script type="math/tex">O(log_2n)^2</script>。</p><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><p>已知一棵包含N个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：</p><p>1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z；</p><p>2 x y 表示求树从x到y结点最短路径上所有节点的值之和；</p><p>3 x z 表示将以x为根节点的子树内所有节点值都加上z；</p><p>4 x 表示求以x为根节点的子树内所有节点值之和。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> val[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点的权值</span><span class="hljs-keyword">int</span> top;<span class="hljs-keyword">int</span> head[<span class="hljs-number">100010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">200010</span>];<span class="hljs-keyword">int</span> par[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点的父亲</span><span class="hljs-keyword">int</span> dep[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点的深度</span><span class="hljs-keyword">int</span> tot[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点子树的结点个数</span><span class="hljs-keyword">int</span> son[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点的重儿子编号</span><span class="hljs-keyword">int</span> idx[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点重新编号后的编号</span><span class="hljs-keyword">int</span> topp[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该结点所在链的顶端结点</span><span class="hljs-keyword">int</span> aval[<span class="hljs-number">100010</span>];<span class="hljs-comment">//重新编号后该结点的权值</span><span class="hljs-keyword">int</span> cnt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> left,right;    <span class="hljs-keyword">int</span> sum;    <span class="hljs-keyword">int</span> f;&#125;node[<span class="hljs-number">100010</span>&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    eg[top].to=b;    eg[top].next=head[a];    head[a]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span></span><span class="hljs-function"></span>&#123;    par[id]=fa;dep[id]=depth;    tot[id]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>;    son[id]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(temp==fa)<span class="hljs-keyword">continue</span>;        tot[id]+=dfs1(temp,id,depth+<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(tot[temp]&gt;maxson)        &#123;            son[id]=temp;            maxson=tot[temp];        &#125;    &#125;    <span class="hljs-keyword">return</span> tot[id];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> topf)</span></span><span class="hljs-function"></span>&#123;    idx[id]=++cnt;    aval[cnt]=val[id];    topp[id]=topf;    <span class="hljs-keyword">if</span>(son[id]==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;     <span class="hljs-comment">//子节点的son为0</span>    dfs2(son[id],topf);     <span class="hljs-comment">//优先标记重儿子</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(idx[temp]==<span class="hljs-number">0</span>)            dfs2(temp,temp);     <span class="hljs-comment">//每一条链以轻儿子为起点</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    node[id].left=l;node[id].right=r;    node[id].f=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(l==r)    &#123;        node[id].sum=aval[l];        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    build(l,m,id&lt;&lt;<span class="hljs-number">1</span>);    build(m+<span class="hljs-number">1</span>,r,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    node[id].sum=node[id&lt;&lt;<span class="hljs-number">1</span>].sum+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l1=node[id&lt;&lt;<span class="hljs-number">1</span>].left,r1=node[id&lt;&lt;<span class="hljs-number">1</span>].right;    <span class="hljs-keyword">int</span> l2=node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].left,r2=node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].right;    node[id&lt;&lt;<span class="hljs-number">1</span>].f=node[id&lt;&lt;<span class="hljs-number">1</span>].f+node[id].f;    node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].f=node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].f+node[id].f;    node[id&lt;&lt;<span class="hljs-number">1</span>].sum=node[id&lt;&lt;<span class="hljs-number">1</span>].sum+node[id].f*(r1-l1+<span class="hljs-number">1</span>);    node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum=node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum+node[id].f*(r2-l2+<span class="hljs-number">1</span>);    node[id].f=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left,r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        node[id].sum=node[id].sum+c*(r-l+<span class="hljs-number">1</span>);        node[id].f=node[id].f+c;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f)pushdown(id);    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)update(L,R,c,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)update(L,R,c,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    node[id].sum=node[id&lt;&lt;<span class="hljs-number">1</span>].sum+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left,r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        ans=ans+node[id].sum;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f)pushdown(id);    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)query(L,R,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)query(L,R,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(topp[x]!=topp[y])    &#123;        <span class="hljs-keyword">if</span>(dep[topp[x]]&lt;dep[topp[y]])swap(x,y);     <span class="hljs-comment">//谁的top低谁就往上走</span>        update(idx[topp[x]],idx[x],c,<span class="hljs-number">1</span>);     <span class="hljs-comment">//改变x~top[x]这条链的权值</span>        x=par[topp[x]];    &#125;    <span class="hljs-keyword">if</span>(dep[x]&gt;dep[y])swap(x,y);    update(idx[x],idx[y],c,<span class="hljs-number">1</span>);     <span class="hljs-comment">//改变x~top[x]这条链的权值</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    update(idx[id],idx[id]+tot[id]<span class="hljs-number">-1</span>,c,<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ask1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(topp[x]!=topp[y])    &#123;        <span class="hljs-keyword">if</span>(dep[topp[x]]&lt;dep[topp[y]])swap(x,y);   <span class="hljs-comment">//谁的top低谁就往上走</span>        ans=<span class="hljs-number">0</span>;        query(idx[topp[x]],idx[x],<span class="hljs-number">1</span>);     <span class="hljs-comment">//查询x~top[x]这条链的权值</span>        res=res+ans;        x=par[topp[x]];    &#125;    <span class="hljs-keyword">if</span>(dep[x]&gt;dep[y])swap(x,y);    ans=<span class="hljs-number">0</span>;    query(idx[x],idx[y],<span class="hljs-number">1</span>);     <span class="hljs-comment">//查询x~top[x]这条链的权值</span>    res=res+ans;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ask2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    ans=<span class="hljs-number">0</span>;    query(idx[id],idx[id]+tot[id]<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,r,op,x,y,z;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;r);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;val[i]);        head[i]=<span class="hljs-number">-1</span>;        idx[i]=<span class="hljs-number">0</span>;    &#125;    top=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        add(x,y);add(y,x);    &#125;    dfs1(r,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    cnt=<span class="hljs-number">0</span>;    dfs2(r,r);    build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;op);        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);            change1(x,y,z);     <span class="hljs-comment">//将树从x到y结点最短路径上所有节点的值都加上z</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ask1(x,y));     <span class="hljs-comment">//求树从x到y结点最短路径上所有节点的值之和</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">3</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;z);            change2(x,z);     <span class="hljs-comment">//将以x为根节点的子树内所有节点值都加上z</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">4</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ask2(x));     <span class="hljs-comment">//求以x为根节点的子树内所有节点值之和</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTU2017D 哈希+乱搞</title>
    <link href="/2018/08/21/CTU2017D-%E5%93%88%E5%B8%8C-%E4%B9%B1%E6%90%9E/"/>
    <url>/2018/08/21/CTU2017D-%E5%93%88%E5%B8%8C-%E4%B9%B1%E6%90%9E/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出N个点，可以选其中四个点组成正方形，输出最大边长。其中<script type="math/tex">1≤N≤100000</script>。</p><p><strong>思路：</strong></p><p>容易想到如果知道两个点这个正方形就可以确定，但是N*N明显不行，这里又可以有一个剪枝，只需要枚举同行或者同列的点。</p><p>对于每个点哈希一下存在unordered_set里。</p><p>两重循环，外层枚举一个点，内层枚举跟它同行或同列的点，然后确定边长，在unordered_set找另外两个点存不存在。这里还是有很多重复计算，比如</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuhq9im27nj306004odfl.jpg" srcset="/img/loading.gif" alt=""></p><p>1和2算的时候其实已经算了1和3的情况了，所以可以选同行同列中size小的那个。</p><p>还可以加个最优解剪枝。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> ll base=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> x,y;&#125;p[<span class="hljs-number">100010</span>];<span class="hljs-built_in">unordered_set</span>&lt;ll&gt;s;<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt;mpx,mpy;<span class="hljs-keyword">int</span> ans;<span class="hljs-function">ll <span class="hljs-title">gethash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x*base+y;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">judge1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span>  z)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> d=<span class="hljs-built_in">abs</span>(y-z);    <span class="hljs-keyword">if</span>(d&lt;=ans)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//if(s.count(gethash(x-d,y))&amp;&amp;s.count(gethash(x-d,z)))</span>        <span class="hljs-comment">//return d; 不用写否则会重复</span>    <span class="hljs-keyword">if</span>(s.count(gethash(x+d,y))&amp;&amp;s.count(gethash(x+d,z)))        <span class="hljs-keyword">return</span> d;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">judge2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> d=<span class="hljs-built_in">abs</span>(y-z);    <span class="hljs-keyword">if</span>(d&lt;=ans)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//if(s.count(gethash(y,x-d))&amp;&amp;s.count(gethash(z,x-d)))</span>        <span class="hljs-comment">//return d;</span>    <span class="hljs-keyword">if</span>(s.count(gethash(y,x+d))&amp;&amp;s.count(gethash(z,x+d)))        <span class="hljs-keyword">return</span> d;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        s.<span class="hljs-built_in">clear</span>();mpx.<span class="hljs-built_in">clear</span>();mpy.<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;p[i].x,&amp;p[i].y);            mpx[p[i].x].push_back(p[i].y);            mpy[p[i].y].push_back(p[i].x);            s.insert(gethash(p[i].x,p[i].y));        &#125;        ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">int</span> len1=mpx[p[i].x].<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">int</span> len2=mpy[p[i].y].<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">if</span>(len1&lt;len2)            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len1;j++)                ans=<span class="hljs-built_in">max</span>(ans,judge1(p[i].x,p[i].y,mpx[p[i].x][j]));            &#125;            <span class="hljs-keyword">else</span>            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len2;j++)                ans=<span class="hljs-built_in">max</span>(ans,judge2(p[i].y,p[i].x,mpy[p[i].y][j]));            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6415 推导/DP</title>
    <link href="/2018/08/20/HDU6415-DP/"/>
    <url>/2018/08/20/HDU6415-DP/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>当矩阵中的(x,y)为所在行和所在列中最大的，该(x,y)被称为纳什均衡点。</p><p>问n*m的全排列矩阵最多只有一个纳什均衡点的方案有几种，对p取模。</p><p>其中<script type="math/tex">1≤t≤20,1≤n,m≤80,1≤p≤10^9</script>。</p><p><strong>思路：</strong></p><p>因为矩阵中最多只能有一个纳什均衡点，所以肯定是最大值的点。所以当放了最大值之后，第二大的值只能放在和它同行或同列的地方，同理，对于一个放完的点，下一个点只能放在和之前的点同行或同列的地方。</p><p>比赛的时候队友oeis搞过去了…搞出来的公式也是有点道理的，<script type="math/tex">A_{mn}^{mn-m-n+1}*m!*n!</script>，因为如果有行都放满或者列都放满（并不仅仅是单纯一整行或一整列，对角线的情况也是）的的情况后，剩下的数就可以都随便放了，所以算有行或列放满的情况就是<script type="math/tex">m!*n!</script>（就相当于对行标号，对列标号，标号相同的填上从小到大的数字），剩下的数就进行排列（后来想想好像也不太对，需要update）。</p><p>用上面的结论也是可以dp的。</p><p><script type="math/tex">dp[i][j][k]</script>：放完第k个点之后有i行j列被占的方案数。</p><p>有三种转移：</p><p>k放的位置列被放过，行没有被放过：</p><p>在放过的列里面选一列，在没放过的行里选一行。</p><p><script type="math/tex">dp[i][j][k]+=dp[i-1][j][k-1]*j*(n-i+1)</script>。</p><p>k放的位置行被放过，列没有被放过：</p><p><script type="math/tex">dp[i][j][k]+=dp[i][j-1][k-1]*i*(m-j+1)</script>。</p><p>k放的位置行和列都被放过：</p><p>放过的行和列中共有i*j个位置，放在没有放过的位置。</p><p><script type="math/tex">dp[i][j][k]+=dp[i][j][k-1]*(i*j-k+1)</script>。</p><p>初始条件为<script type="math/tex">dp[1][1][1]=n*m</script>。</p><p>这就可以写了，但是这个数据有点大，这里需要剪掉一些，所以要把i和j放在外层，k的范围为2～i*j。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span>ll dp[<span class="hljs-number">85</span>][<span class="hljs-number">85</span>][<span class="hljs-number">6500</span>];<span class="hljs-comment">//放置k后有i行j列被占了</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m;    ll p;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%lld"</span>,&amp;n,&amp;m,&amp;p);        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1l</span>l*m*n;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=(i==<span class="hljs-number">1</span>?<span class="hljs-number">2</span>:<span class="hljs-number">1</span>);j&lt;=m;j++)                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">2</span>;k&lt;=i*j;k++)                &#123;                    ll temp1=<span class="hljs-number">0</span>,temp2=<span class="hljs-number">0</span>,temp3=<span class="hljs-number">0</span>;                    temp1=dp[i<span class="hljs-number">-1</span>][j][k<span class="hljs-number">-1</span>]*j*(n-i+<span class="hljs-number">1</span>)%p;                    temp2=dp[i][j<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>]*i*(m-j+<span class="hljs-number">1</span>)%p;                    <span class="hljs-keyword">if</span>(i*j-k+<span class="hljs-number">1</span>&gt;<span class="hljs-number">0</span>)                        temp3=dp[i][j][k<span class="hljs-number">-1</span>]*(i*j-k+<span class="hljs-number">1</span>)%p;                    dp[i][j][k]=(temp1+temp2+temp3)%p;                    <span class="hljs-comment">//printf("%d %d %d:%lld\n",i,j,k,dp[i][j][k]);</span>                &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,dp[n][m][n*m]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZOJ4009 &amp; 上海大都会赛H 循环节+线段树</title>
    <link href="/2018/08/19/ZOJ4009-%E4%B8%8A%E6%B5%B7%E5%A4%A7%E9%83%BD%E4%BC%9A%E8%B5%9BH-%E5%BE%AA%E7%8E%AF%E8%8A%82-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2018/08/19/ZOJ4009-%E4%B8%8A%E6%B5%B7%E5%A4%A7%E9%83%BD%E4%BC%9A%E8%B5%9BH-%E5%BE%AA%E7%8E%AF%E8%8A%82-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h5 id="ZOJ4009"><a href="#ZOJ4009" class="headerlink" title="ZOJ4009"></a>ZOJ4009</h5><p><strong>题意：</strong></p><p>给出n个数字，有两种操作：</p><p><script type="math/tex">1\ l\ r</script>：将<script type="math/tex">a_l, a_{l+1}, \dots, a_r</script>变成<script type="math/tex">a_l^3, a_{l+1}^3, \dots, a_r^3</script>；</p><p><script type="math/tex">2\ l \ r</script>：求<script type="math/tex">\displaystyle\sum_{i=l}^r a_i</script>模99971的结果。</p><p><strong>思路：</strong></p><p>打表可以发现，在该模数下，每48个数字会有循环节。所以开48棵线段树，在v[0]里放当前值。</p><p>对于修改操作，进行左移就可以了。</p><p>不清楚的话可以自己模拟一下。</p><p>因为刚开始<script type="math/tex">0 \le a_i \le 10^9</script>，所以一开始就要模99971。</p><p>这题有点卡常，虽然跑过了但是太慢了，用个读入挂比较好。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 99971</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> left,right;    <span class="hljs-keyword">int</span> f;    ll v[<span class="hljs-number">50</span>];&#125;node[<span class="hljs-number">100010</span>&lt;&lt;<span class="hljs-number">2</span>];ll temp1[<span class="hljs-number">50</span>],temp2[<span class="hljs-number">50</span>];ll ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">48</span>;i++)        node[id].v[i]=(node[id&lt;&lt;<span class="hljs-number">1</span>].v[i]+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].v[i])%MOD;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    node[id].left=l;node[id].right=r;    node[id].f=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(l==r)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;node[id].v[<span class="hljs-number">0</span>]);        node[id].v[<span class="hljs-number">0</span>]%=MOD;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">48</span>;i++)            node[id].v[i]=node[id].v[i<span class="hljs-number">-1</span>]*node[id].v[i<span class="hljs-number">-1</span>]*node[id].v[i<span class="hljs-number">-1</span>]%MOD;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    build(l,m,id&lt;&lt;<span class="hljs-number">1</span>);    build(m+<span class="hljs-number">1</span>,r,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    pushup(id);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> c=node[id].f;    node[id&lt;&lt;<span class="hljs-number">1</span>].f=(node[id&lt;&lt;<span class="hljs-number">1</span>].f+c)%<span class="hljs-number">48</span>;    node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].f=(node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].f+c)%<span class="hljs-number">48</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">48</span>;i++)    &#123;        temp1[i]=node[id&lt;&lt;<span class="hljs-number">1</span>].v[i];        temp2[i]=node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].v[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">48</span>;i++)    &#123;        node[id&lt;&lt;<span class="hljs-number">1</span>].v[i]=temp1[(i+c)%<span class="hljs-number">48</span>];        node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].v[i]=temp2[(i+c)%<span class="hljs-number">48</span>];    &#125;    node[id].f=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left,r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        node[id].f=(node[id].f+<span class="hljs-number">1</span>)%<span class="hljs-number">48</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">48</span>;i++)            temp1[i]=node[id].v[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">48</span>;i++)            node[id].v[i]=temp1[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">48</span>];        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f)pushdown(id);    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)update(L,R,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)update(L,R,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    pushup(id);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left,r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        ans=(ans+node[id].v[<span class="hljs-number">0</span>])%MOD;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f)pushdown(id);    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)query(L,R,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)query(L,R,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,q,op,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;q);        build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);        <span class="hljs-keyword">while</span>(q--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;op,&amp;x,&amp;y);            <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)                update(x,y,<span class="hljs-number">1</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)            &#123;                ans=<span class="hljs-number">0</span>;                query(x,y,<span class="hljs-number">1</span>);                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="上海大都会赛H"><a href="#上海大都会赛H" class="headerlink" title="上海大都会赛H"></a>上海大都会赛H</h5><p><strong>题意：</strong></p><p>给出n个数字，有两种操作：</p><p><script type="math/tex">C\ l\ r</script>：将<script type="math/tex">a_l, a_{l+1}, \dots, a_r</script>变成<script type="math/tex">(a_l^2)\%2018,(a_{l+1}^3)\%2018, (\dots, a_r^3)\%2018</script>；</p><p><script type="math/tex">Q\ l\ r</script>：求<script type="math/tex">\displaystyle\sum_{i=l}^r a_i</script>的结果（不用取模）。</p><p><strong>思路：</strong></p><p>打表可知循环节大概是在变换4次以后，且每个循环节的长度为6。</p><p>所以这里就需要一个标记circle来记录该区间是否进入了循环节，如果进入了循环节，就像上题那样的做法，如果没有进入，则单点更新，并且判断更新后是否进入循环节。</p><p>上传标记的时候，只有左儿子和右儿子都在区间内的时候，将6个v[i]更新，否则就只更新v[0]。</p><p>我query的时候标记没有下放…debug了好久…一写长的代码就要debug好久…</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> left,right;    <span class="hljs-keyword">bool</span> cir;    <span class="hljs-keyword">int</span> f;    <span class="hljs-keyword">int</span> v[<span class="hljs-number">10</span>];&#125;node[<span class="hljs-number">50010</span>&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> temp1[<span class="hljs-number">10</span>],temp2[<span class="hljs-number">10</span>];ll ans;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x=cur;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)    &#123;        x=x*x%<span class="hljs-number">2018</span>;        <span class="hljs-keyword">if</span>(x==cur)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    node[id].left=l;node[id].right=r;    node[id].cir=<span class="hljs-literal">false</span>;node[id].f=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(l==r)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;node[id].v[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    build(l,m,id&lt;&lt;<span class="hljs-number">1</span>);    build(m+<span class="hljs-number">1</span>,r,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    node[id].v[<span class="hljs-number">0</span>]=(node[id&lt;&lt;<span class="hljs-number">1</span>].v[<span class="hljs-number">0</span>]+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].v[<span class="hljs-number">0</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> c=node[id].f;    node[id&lt;&lt;<span class="hljs-number">1</span>].f=(node[id&lt;&lt;<span class="hljs-number">1</span>].f+c)%<span class="hljs-number">6</span>;    node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].f=(node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].f+c)%<span class="hljs-number">6</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)    &#123;        temp1[i]=node[id&lt;&lt;<span class="hljs-number">1</span>].v[i];        temp2[i]=node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].v[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)    &#123;        node[id&lt;&lt;<span class="hljs-number">1</span>].v[i]=temp1[(i+c)%<span class="hljs-number">6</span>];        node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].v[i]=temp2[(i+c)%<span class="hljs-number">6</span>];    &#125;    node[id].f=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left,r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R&amp;&amp;node[id].cir)<span class="hljs-comment">//循环内</span>    &#123;        node[id].f=(node[id].f+<span class="hljs-number">1</span>)%<span class="hljs-number">6</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)            temp1[i]=node[id].v[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)            node[id].v[i]=temp1[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">6</span>];        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(l==r)<span class="hljs-comment">//循环外</span>    &#123;        node[id].v[<span class="hljs-number">0</span>]=node[id].v[<span class="hljs-number">0</span>]*node[id].v[<span class="hljs-number">0</span>]%<span class="hljs-number">2018</span>;        <span class="hljs-keyword">if</span>(judge(node[id].v[<span class="hljs-number">0</span>]))        &#123;            node[id].cir=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">6</span>;i++)            node[id].v[i]=node[id].v[i<span class="hljs-number">-1</span>]*node[id].v[i<span class="hljs-number">-1</span>]%<span class="hljs-number">2018</span>;        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f)pushdown(id);    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)update(L,R,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)update(L,R,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(node[id&lt;&lt;<span class="hljs-number">1</span>].cir&amp;&amp;node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].cir)    &#123;        node[id].cir=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)            node[id].v[i]=node[id&lt;&lt;<span class="hljs-number">1</span>].v[i]+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].v[i];    &#125;    <span class="hljs-keyword">else</span>    &#123;        node[id].cir=<span class="hljs-literal">false</span>;        node[id].v[<span class="hljs-number">0</span>]=node[id&lt;&lt;<span class="hljs-number">1</span>].v[<span class="hljs-number">0</span>]+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].v[<span class="hljs-number">0</span>];    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left,r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        ans+=<span class="hljs-number">1l</span>l*node[id].v[<span class="hljs-number">0</span>];        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f)pushdown(id);<span class="hljs-comment">//不要忘了下放</span>    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)query(L,R,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)query(L,R,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,q,x,y;    <span class="hljs-keyword">char</span> s[<span class="hljs-number">5</span>];    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case #%d:\n"</span>,kase);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);        <span class="hljs-keyword">while</span>(q--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%d%d"</span>,s,&amp;x,&amp;y);            <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">'C'</span>)                update(x,y,<span class="hljs-number">1</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">'Q'</span>)            &#123;                ans=<span class="hljs-number">0</span>;                query(x,y,<span class="hljs-number">1</span>);                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU5884 二分+多叉哈夫曼树+单调队列</title>
    <link href="/2018/08/18/HDU5884-%E4%BA%8C%E5%88%86-%E5%A4%9A%E5%8F%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2018/08/18/HDU5884-%E4%BA%8C%E5%88%86-%E5%A4%9A%E5%8F%89%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出n个数字，要求合并这些数字的代价不超过T，每次可以合并不超过k个数字，每次合并的代价为这些数字的和。问最小的k可以是多少。其中<script type="math/tex">2≤N≤100000</script>。</p><p><strong>思路：</strong></p><p>容易想到二分这个k。</p><p>但是这里合并的时候有个问题，不能直接取当前最小的几个合并，因为可能会出现最后一次合并剩下的不是k的情况，这样子就不能最优了。比如这个例子1 2 3 4 5 6，k=3的时候，如果直接取的话代价为6+15+21，事实上要先取两个最小的，代价为3+10+21，所以有个结论：</p><p>对于k叉树，设m为叶子数 , 若<script type="math/tex">( m - 1 ) \% ( k - 1 ) != 0</script>, 要增加虚(子叶)结点。第一次构造用<script type="math/tex">( m - 1 ) \% ( k - 1 ) + 1</script>个结点，之后都用k个结点构造k叉树。</p><p>这里又有个问题，如果直接用优先队列，总的复杂度为<script type="math/tex">O(n*logn*logn)</script>，还有t组，网上说可以卡过去，然而我并没有卡过去。</p><p>所以这里可以用单调队列，把产生的新的和放入队列，数列从小到大排列，每次取最小的数字的时候，把队首元素和数组里的数字进行比较可以了。这样保证队列中队首元素总是最小的。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll a[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> n;ll MAX;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//printf("x=%d\n",x);</span>    <span class="hljs-built_in">queue</span>&lt;ll&gt;q;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">1</span>;    ll tot=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>((n<span class="hljs-number">-1</span>)%(x<span class="hljs-number">-1</span>)!=<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">int</span> temp=(n<span class="hljs-number">-1</span>)%(x<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>;        ll sum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;temp; i++)        &#123;            sum+=a[pos];            pos++;        &#125;        q.push(sum);        tot+=sum;    &#125;    <span class="hljs-comment">//printf("tot=%lld pos=%d\n",tot,pos);</span>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)    &#123;        ll sum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;x; i++)        &#123;            <span class="hljs-keyword">if</span>(pos==n+<span class="hljs-number">1</span>||(!q.empty()&amp;&amp;q.front()&lt;a[pos]))            &#123;                sum+=q.front();                <span class="hljs-comment">//printf("%lld ",q.front());</span>                q.pop();            &#125;            <span class="hljs-keyword">else</span>            &#123;                sum+=a[pos];                <span class="hljs-comment">//printf("%lld ",a[pos]);</span>                pos++;            &#125;        &#125;        <span class="hljs-comment">//printf("\n");</span>        q.push(sum);        <span class="hljs-comment">//printf("%d %lld\n",pos,sum);</span>        tot+=sum;        <span class="hljs-keyword">if</span>(pos==n+<span class="hljs-number">1</span>&amp;&amp;q.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-comment">//printf("%lld\n",tot);</span>    <span class="hljs-keyword">if</span>(tot&lt;=MAX)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%lld"</span>,&amp;n,&amp;MAX);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);<span class="hljs-keyword">continue</span>;&#125;        sort(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n);        <span class="hljs-keyword">int</span> l=<span class="hljs-number">2</span>,r=n,ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(l&lt;=r)        &#123;            <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(judge(mid))ans=mid,r=mid<span class="hljs-number">-1</span>;            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6390 公式推导+容斥</title>
    <link href="/2018/08/16/HDU6390-%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC-%E5%AE%B9%E6%96%A5/"/>
    <url>/2018/08/16/HDU6390-%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC-%E5%AE%B9%E6%96%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有<script type="math/tex">G_u(a,b)=\frac{\varphi(ab)}{\varphi(a)\varphi(b)}</script>。给定m,n,p，求<script type="math/tex">(\sum_{a=1}^m\sum_{b=1}^nG_u(a,b))\ mod\ p</script>。其中<script type="math/tex">1≤m,n≤1000000</script>，<script type="math/tex">max(m,n)<p≤1000000007</script>，p为质数。</p><p><strong>思路：</strong></p><p>可以推导出<script type="math/tex">\frac{\varphi(ab)}{\varphi(a)\varphi(b)}=\frac{gcd(a,b)}{\varphi(gcd(a,b))}</script>。</p><p>举个例子形象一点，</p><p>因为有欧拉公式<script type="math/tex">φ(n) = n *(1-\frac{1}{x})* (1-\frac{1}{y})</script>，其中x,y为n的质因子。</p><script type="math/tex; mode=display">\frac{\varphi(72)}{\varphi(6)\varphi(12)}=\frac{72*(1-\frac{1}{2})*(1-\frac{1}{3})}{6*(1-\frac{1}{2})*(1-\frac{1}{3})*12*(1-\frac{1}{2})*(1-\frac{1}{3})}=\frac{1}{(1-\frac{1}{2})*(1-\frac{1}{3})}</script><p>化简后分母只剩下<script type="math/tex">gcd</script>的质因子的部分，上下同乘<script type="math/tex">gcd</script>，得</p><script type="math/tex; mode=display">\frac{6}{(6-3)*(1-\frac{1}{3})}=\frac{6}{6-2-3+1}</script><p>这里分子就是<script type="math/tex">gcd(6,12)</script>，分母则是<script type="math/tex">gcd(6,12)</script>中减去2的倍数的个数，减去3的倍数的个数，加上6的倍数的个数，这个容斥就是求出了比<script type="math/tex">gcd(6,12)</script>小的数中与它互质的数的个数，即<script type="math/tex">\varphi(gcd(6,12))</script>。</p><p>所以问题就转化为了求<script type="math/tex">(\sum_{a=1}^m\sum_{b=1}^n\frac{gcd(a,b)}{\varphi(gcd(a,b))})\ mod\ p</script>。这里用到了容斥。</p><p>枚举<script type="math/tex">gcd(a,b)</script>。设f[i]:gcd为i的倍数的(a,b)对数，g[i]:gcd为i的(a,b)对数。</p><p>以a=6,b=8为例，</p><script type="math/tex; mode=display">f[1]=6*8=48,f[2]=3*4=12,f[3]=2*2=4,</script><script type="math/tex; mode=display">f[4]=1*2=2,f[5]=1*1=1,f[6]=1*1=1$$。$$g[6]=f[6]=1,g[5]=f[5]=1,g[4]=f[4]=2,g[3]=f[3]-g[6]=4-1=3,</script><script type="math/tex; mode=display">g[2]=f[2]-g[4]-g[6]=12-2-1=9,</script><p><script type="math/tex">g[1]=f[1]-g[2]-g[3]-g[4]-g[5]-g[6]=48-9-3-2-1-1=32​</script>。</p><p>所以就可以求出g[i]了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 1000000</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll eu[MAXN+<span class="hljs-number">10</span>];ll pri[MAXN+<span class="hljs-number">10</span>];<span class="hljs-keyword">bool</span> vis[MAXN+<span class="hljs-number">10</span>];ll f[MAXN+<span class="hljs-number">10</span>];<span class="hljs-comment">//gcd为i的倍数的对数</span>ll g[MAXN+<span class="hljs-number">10</span>];<span class="hljs-comment">//gcd为i的对数</span>ll inv[MAXN+<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    eu[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    ll cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;=MAXN;i++)    &#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;pri[cnt++]=i;eu[i]=i<span class="hljs-number">-1</span>;&#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=cnt&amp;&amp;pri[j]*i&lt;=MAXN;j++)        &#123;            vis[i*pri[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%pri[j]==<span class="hljs-number">0</span>)            &#123;                eu[i*pri[j]]=eu[i]*pri[j];                <span class="hljs-keyword">break</span>;            &#125;            eu[i*pri[j]]=eu[i]*(pri[j]<span class="hljs-number">-1</span>);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">PowerMod</span><span class="hljs-params">(ll a,ll b,ll c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k;    k=a;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)        ans=(ans*k)%c;        b=b/<span class="hljs-number">2</span>;        k=(k*k)%c;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    ll m,n,p;    init();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld"</span>,&amp;m,&amp;n,&amp;p);        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(m,n);i++)            f[i]=(m/i)*(n/i);        ll tot=<span class="hljs-built_in">min</span>(m,n);        inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;=tot;i++)           inv[i]=(p-(p/i))*inv[p%i]%p;        <span class="hljs-keyword">for</span>(ll i=tot;i&gt;=<span class="hljs-number">1</span>;i--)        &#123;            g[i]=f[i];            <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">2</span>;i*j&lt;=tot;j++)                g[i]=(g[i]-g[i*j]+p)%p;            ll temp=g[i];            temp=((temp*i)%p*inv[eu[i]])%p;            ans=(ans+temp)%p;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Atcoder2069 拆点+最短路/并查集+bfs</title>
    <link href="/2018/08/16/Atcoder2069-%E6%8B%86%E7%82%B9-%E6%9C%80%E7%9F%AD%E8%B7%AF-%E5%B9%B6%E6%9F%A5%E9%9B%86-bfs/"/>
    <url>/2018/08/16/Atcoder2069-%E6%8B%86%E7%82%B9-%E6%9C%80%E7%9F%AD%E8%B7%AF-%E5%B9%B6%E6%9F%A5%E9%9B%86-bfs/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n个点，有m条边，每条边上有一个权值。当你从u到v时，如果这条边和上一条边的权值不同，代价就加1。问从结点1到结点n的最小代价。</p><p><strong>思路：</strong></p><p>有两种做法。</p><p>做法一（拆点）：</p><p><img src="https://ws4.sinaimg.cn/large/0069RVTdly1fubtaf4anwj30kp080t8s.jpg" srcset="/img/loading.gif" alt=""></p><p>原来的图是左边这样的，可以拆成右边这样，可以知道这样任意两点之间的代价就是走过的权值和加上1。</p><p>为了方便存图，可以这样拆点：</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdly1fubtbhn32ej30fl0atwee.jpg" srcset="/img/loading.gif" alt=""></p><p>这样子的代价也是相同的。</p><p>跑一下最短路/2就可以了。</p><p>做法二（并查集）：</p><p>把权值相同的边拿出来，如果在同一个连通块内的话，互相到达肯定是不要代价的，但是如果不在同一个连通块内，互相到达仍然是要钱的，所以把每个点和它的父结点连边，把这个父节点当成一个新的结点。然后bfs一下就可以了。</p><p>如数据：</p><p>6 7</p><p>5 4 7</p><p>4 2 5</p><p>4 3 4</p><p>6 3 7</p><p>3 1 1</p><p>2 6 5</p><p>5 2 5</p><p>建图是这样的：</p><p><img src="https://ws2.sinaimg.cn/large/0069RVTdly1fubtawi7pwj30iy0b8dft.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>代码：</strong></p><p>做法一：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> cnt;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;p;<span class="hljs-built_in">map</span>&lt;p,<span class="hljs-keyword">int</span>&gt;mp;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to,cost;&#125;;<span class="hljs-built_in">vector</span>&lt;edge&gt;v[<span class="hljs-number">100010</span>*<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    p pp=make_pair(x,y);    <span class="hljs-keyword">if</span>(mp.count(pp))<span class="hljs-keyword">return</span> mp[pp];    mp[pp]=++cnt;    <span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-keyword">int</span> dis[<span class="hljs-number">100010</span>*<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">fill</span>(dis+<span class="hljs-number">1</span>,dis+cnt+<span class="hljs-number">1</span>,INF);    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    priority_queue&lt;p,<span class="hljs-built_in">vector</span>&lt;p&gt;,greater&lt;p&gt; &gt;q;    q.push(p(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        p temp=q.top();        q.pop();        <span class="hljs-keyword">int</span> w=temp.first;<span class="hljs-keyword">int</span> id=temp.second;        <span class="hljs-keyword">if</span>(w&gt;dis[id])<span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)        &#123;            edge &amp;e=v[id][i];            <span class="hljs-keyword">if</span>(w+e.cost&lt;dis[e.to])            &#123;                dis[e.to]=w+e.cost;                q.push(p(dis[e.to],e.to));            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,x,y,z;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    cnt=n;    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);        <span class="hljs-keyword">int</span> temp1,temp2;        temp1=getid(x,z);temp2=getid(y,z);        v[x].push_back(edge&#123;temp1,<span class="hljs-number">1</span>&#125;);        v[temp1].push_back(edge&#123;x,<span class="hljs-number">1</span>&#125;);        v[temp1].push_back(edge&#123;temp2,<span class="hljs-number">0</span>&#125;);        v[temp2].push_back(edge&#123;temp1,<span class="hljs-number">0</span>&#125;);        v[temp2].push_back(edge&#123;y,<span class="hljs-number">1</span>&#125;);        v[y].push_back(edge&#123;temp2,<span class="hljs-number">1</span>&#125;);    &#125;    dijkstra();    <span class="hljs-keyword">if</span>(dis[n]==INF)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dis[n]/<span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>做法二（需update）：</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; p;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> tot;<span class="hljs-keyword">int</span> par[MAXN];<span class="hljs-keyword">int</span> id[MAXN];<span class="hljs-keyword">bool</span> used[MAXN];<span class="hljs-built_in">vector</span>&lt;p&gt;c[MAXN];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[MAXN];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> idd,<span class="hljs-built_in">step</span>;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> par[x]=Find(par[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    x=Find(x);y=Find(y);    par[x]=y;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,x,y,z;    <span class="hljs-keyword">int</span> MAX=<span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);        c[z].push_back(make_pair(x,y));        MAX=<span class="hljs-built_in">max</span>(MAX,z);    &#125;    tot=n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=MAX;i++)    &#123;        <span class="hljs-keyword">int</span> len=c[i].<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)        &#123;            x=c[i][j].first,y=c[i][j].second;            par[x]=x;par[y]=y;            id[x]=id[y]=<span class="hljs-number">0</span>;used[x]=used[y]=<span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)            unite(c[i][j].first,c[i][j].second);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)        &#123;            x=c[i][j].first,y=c[i][j].second;            <span class="hljs-keyword">int</span> fx=Find(x),fy=Find(y);            <span class="hljs-keyword">if</span>(id[fx]==<span class="hljs-number">0</span>)id[fx]=++tot;            <span class="hljs-keyword">if</span>(id[fy]==<span class="hljs-number">0</span>)id[fy]=++tot;            <span class="hljs-keyword">if</span>(!used[x])            &#123;                used[x]=<span class="hljs-literal">true</span>;                v[x].push_back(id[fx]);                v[id[fx]].push_back(x);            &#125;            <span class="hljs-keyword">if</span>(!used[y])            &#123;                used[y]=<span class="hljs-literal">true</span>;                v[y].push_back(id[fy]);                v[id[fy]].push_back(y);            &#125;        &#125;    &#125;    <span class="hljs-built_in">memset</span>(used,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(used));    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">-2</span>;    <span class="hljs-built_in">queue</span>&lt;node&gt;q;    q.push(node&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;);    used[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q.empty()&amp;&amp;sign==<span class="hljs-number">0</span>)    &#123;        node temp=q.front();        q.pop();        x=temp.idd;y=temp.<span class="hljs-built_in">step</span>;        <span class="hljs-keyword">int</span> len=v[x].<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len&amp;&amp;sign==<span class="hljs-number">0</span>;i++)        &#123;            <span class="hljs-keyword">if</span>(!used[v[x][i]])            &#123;                <span class="hljs-keyword">if</span>(v[x][i]==n)                &#123;                    ans=y+<span class="hljs-number">1</span>;                    sign++;                &#125;                used[v[x][i]]=<span class="hljs-literal">true</span>;                q.push(node&#123;v[x][i],y+<span class="hljs-number">1</span>&#125;);            &#125;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans/<span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些思想</title>
    <link href="/2018/08/16/%E4%B8%80%E4%BA%9B%E6%80%9D%E6%83%B3/"/>
    <url>/2018/08/16/%E4%B8%80%E4%BA%9B%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>题意：</strong></p><p>给出n个数字，有q个询问，去掉三个数字，在剩下的数字里面选10个，问和能否刚好为87。其中<script type="math/tex">t \leq5,n \leq 50,q \leq 100000</script>。</p><p><strong>思路：</strong></p><p><script type="math/tex">O(t*n^3*n*10)</script>的bitset优化的dp居然可以水过…不科学啊…</p><p>有另一种做法：</p><p>因为删除3个数字，所以对于中间的那个数，<script type="math/tex">pre[i][j][k]</script>表示前i个中选了j个没有选k的和的情况，<script type="math/tex">suf[i][j][k]</script>表示后i个中选j个没有选k的和的情况，对于和的情况仍然用bitset优化。</p><p>特殊处理一下当3个数字有相同的情况。</p><p>询问的时候把前后拼起来就好了。</p><p>预处理复杂度为<script type="math/tex">O(t*10*n^2)</script>，询问的复杂度为<script type="math/tex">O(t*87*10*q)</script>。这复杂度也不科学。</p><p>但是可以学习一下这种思想。</p><p>ps.三个好像经常可以做文章啊？</p><p><a href="http://pattle.xyz/2018/07/10/BAPC2014-finalE-线段树/" target="_blank" rel="noopener">http://pattle.xyz/2018/07/10/BAPC2014-finalE-线段树/</a></p><p>是可以最开始搞定一项，然后维护两项。</p><p>这里是枚举中间一项，预处理出前后两项的情况。</p><hr><p>遇到类似9&amp;9+9&amp;4+9&amp;3求值，可以按位来算，因为9为1001，所以只有第一位和第四位有贡献，所以对于9和4和3看这两位有没有1，统计一下这些位的1加起来就可以了。</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU5887 超大背包+状态保存（数据随机下的玄学做法？）</title>
    <link href="/2018/08/15/HDU5887-%E8%B6%85%E5%A4%A7%E8%83%8C%E5%8C%85-%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%EF%BC%88%E6%95%B0%E6%8D%AE%E9%9A%8F%E6%9C%BA%E4%B8%8B%E7%9A%84%E7%8E%84%E5%AD%A6%E5%81%9A%E6%B3%95%EF%BC%9F%EF%BC%89/"/>
    <url>/2018/08/15/HDU5887-%E8%B6%85%E5%A4%A7%E8%83%8C%E5%8C%85-%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%EF%BC%88%E6%95%B0%E6%8D%AE%E9%9A%8F%E6%9C%BA%E4%B8%8B%E7%9A%84%E7%8E%84%E5%AD%A6%E5%81%9A%E6%B3%95%EF%BC%9F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n件物品，每件物品有体积<script type="math/tex">v_i</script>和价值<script type="math/tex">w_i</script>，问体积为m的背包最多可以装下多大价值的物品。其中<script type="math/tex">n \leq 100</script> ，其他数据均匀随机并且不超过<script type="math/tex">10^9</script>。</p><p><strong>思路：</strong></p><p>很典型的背包问题，然而背包的大小变成了<script type="math/tex">10^9</script>，最简单的01背包的做法不行，交换两维状态（前i件物品价值为j占用的最小体积）的做法也不行。<script type="math/tex">n \leq 100</script>，折半枚举也不行。</p><p>那怎么办呢？所以看了题解…</p><p>这又是数据随机下的玄学做法。因为数据均匀随机，所以事实上状态数是很少的。所以把状态放进容器，每次dp的时候遍历一下。这里有些状态是可以删掉的，如果价值小花费的体积反而多，就可以删掉。所以根据价值从大到小排序，然后把这些状态删去就好了。</p><p>这里还有一个搜索+剪枝的做法，不知是数据水还是什么原因，剪枝就是按性价比排序，然后进行后缀优化，如果背包全部放当前性价比的东西价值却没有超过当前的最大值就剪掉，当然体积如果大于m也剪掉。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    ll cost,val;&#125;a[<span class="hljs-number">110</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;ll,ll&gt; x,pair&lt;ll,ll&gt; y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x.second!=y.second)<span class="hljs-keyword">return</span> x.second&gt;y.second;    <span class="hljs-keyword">return</span> x.first&lt;y.first;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    ll m;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%lld"</span>,&amp;n,&amp;m)!=EOF)    &#123;        <span class="hljs-built_in">vector</span>&lt;pair&lt;ll,ll&gt; &gt;v[<span class="hljs-number">110</span>];<span class="hljs-comment">//cost,val</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;a[i].cost,&amp;a[i].val);        pair&lt;ll,ll&gt;p;        p.first=<span class="hljs-number">0</span>;p.first=<span class="hljs-number">0</span>;        v[<span class="hljs-number">0</span>].push_back(p);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">int</span> len=v[i<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)            &#123;                v[i].push_back(v[i<span class="hljs-number">-1</span>][j]);                p=v[i<span class="hljs-number">-1</span>][j];                <span class="hljs-keyword">if</span>(p.first+a[i].cost&lt;=m)                &#123;                    p.first+=a[i].cost;p.second+=a[i].val;                    v[i].push_back(p);                &#125;            &#125;            sort(v[i].<span class="hljs-built_in">begin</span>(),v[i].<span class="hljs-built_in">end</span>(),cmp);<span class="hljs-comment">//把时间多价值却小的删掉</span>            <span class="hljs-keyword">int</span> ls=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;v[i].<span class="hljs-built_in">size</span>();j++)            &#123;                <span class="hljs-keyword">if</span>(v[i][j].first&gt;=v[i][ls].first)                    v[i].erase(v[i].<span class="hljs-built_in">begin</span>()+j);                <span class="hljs-keyword">else</span> ls=j;            &#125;            <span class="hljs-comment">/*for(int j=0;j&lt;v[i].size();j++)</span><span class="hljs-comment">                printf("(%lld,%lld)",v[i][j].first,v[i][j].second);</span><span class="hljs-comment">            printf("\n");*/</span>        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,v[n][<span class="hljs-number">0</span>].second);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最近公共祖先</title>
    <link href="/2018/08/15/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2018/08/15/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h4 id="tarjan离线："><a href="#tarjan离线：" class="headerlink" title="tarjan离线："></a>tarjan离线：</h4><p><strong>参考博客：</strong></p><p><a href="https://www.dreamwings.cn/lca/4874.html" target="_blank" rel="noopener">https://www.dreamwings.cn/lca/4874.html</a></p><p><a href="https://www.cnblogs.com/JVxie/p/4854719.html" target="_blank" rel="noopener">https://www.cnblogs.com/JVxie/p/4854719.html</a></p><p><strong>复杂度：</strong></p><p><script type="math/tex">O(m+n)</script>，m是询问数，n是节点数。</p><p><strong>伪代码：</strong></p><pre><code class="hljs c++">Tarjan(u)   <span class="hljs-comment">// merge和find为并查集合并函数和查找函数</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">for</span> <span class="hljs-title">each</span><span class="hljs-params">(u,v)</span>       <span class="hljs-comment">// 遍历u的所有子节点v</span></span><span class="hljs-function">    </span>&#123;        Tarjan(v);      <span class="hljs-comment">// 继续往下遍历</span>        merge(u,v);     <span class="hljs-comment">// 合并v到u这一集合</span>        标记 v 已被访问过;    &#125;    <span class="hljs-function"><span class="hljs-keyword">for</span> <span class="hljs-title">each</span><span class="hljs-params">(u,e)</span>       <span class="hljs-comment">// 遍历所有与u有查询关系的e</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span> (e 被访问过)            u, e 的最近公共祖先为 <span class="hljs-built_in">find</span>(e);    &#125;&#125;</code></pre><p><strong>模板：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> top,qtop;<span class="hljs-keyword">int</span> head[<span class="hljs-number">500010</span>];<span class="hljs-keyword">int</span> qhead[<span class="hljs-number">500010</span>];<span class="hljs-keyword">int</span> par[<span class="hljs-number">500010</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">500010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">500010</span>*<span class="hljs-number">2</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">query</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">int</span> next;&#125;qu[<span class="hljs-number">500010</span>*<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> ans[<span class="hljs-number">500010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    eg[top].to=b;    eg[top].next=head[a];    head[a]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    qu[qtop].to=b;    qu[qtop].id=c;    qu[qtop].next=qhead[a];    qhead[a]=qtop++;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> par[x]=Find(par[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    vis[id]=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> v=eg[i].to;        <span class="hljs-keyword">if</span>(!vis[v])        &#123;            tarjan(v);            par[v]=id;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=qhead[id];i!=<span class="hljs-number">-1</span>;i=qu[i].next)    &#123;        <span class="hljs-keyword">int</span> v=qu[i].to;        <span class="hljs-keyword">if</span>(vis[v])            ans[qu[i].id]=Find(v);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,s,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;s);    top=<span class="hljs-number">0</span>;qtop=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        head[i]=<span class="hljs-number">-1</span>;qhead[i]=<span class="hljs-number">-1</span>;        vis[i]=<span class="hljs-literal">false</span>;par[i]=i;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        add(x,y);add(y,x);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        addq(x,y,i);addq(y,x,i);    &#125;    tarjan(s);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="倍增："><a href="#倍增：" class="headerlink" title="倍增："></a>倍增：</h4><p><strong>参考博客：</strong></p><p><a href="https://blog.csdn.net/qq_42790311/article/details/81486742" target="_blank" rel="noopener">https://blog.csdn.net/qq_42790311/article/details/81486742</a></p><p><a href="https://www.cnblogs.com/xqmmcqs/p/5954097.html" target="_blank" rel="noopener">https://www.cnblogs.com/xqmmcqs/p/5954097.html</a></p><p><a href="https://www.luogu.org/blog/34188/solution-p3379" target="_blank" rel="noopener">https://www.luogu.org/blog/34188/solution-p3379</a></p><p><strong>复杂度：</strong></p><p><script type="math/tex">O(nlog_2n)</script>。</p><p><strong>模板：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> top;<span class="hljs-keyword">int</span> head[<span class="hljs-number">500010</span>];<span class="hljs-keyword">int</span> par[<span class="hljs-number">500010</span>][<span class="hljs-number">25</span>];<span class="hljs-comment">//编号为i的结点的第2^j个祖先</span><span class="hljs-keyword">int</span> dep[<span class="hljs-number">500010</span>];<span class="hljs-keyword">int</span> lg[<span class="hljs-number">500010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">500010</span>*<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    eg[top].to=b;    eg[top].next=head[a];    head[a]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span></span><span class="hljs-function"></span>&#123;    dep[id]=depth;    par[id][<span class="hljs-number">0</span>]=fa;    <span class="hljs-comment">//i的第2^j个祖先相当于i的第2^(j-1)个祖先的第2^(j-1)个祖先</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[id];i++)        par[id][i]=par[par[id][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        <span class="hljs-keyword">if</span>(eg[i].to!=fa)            dfs(eg[i].to,id,depth+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(dep[x]&lt;dep[y])swap(x,y);<span class="hljs-comment">//保证x的深度大于等于y</span>    <span class="hljs-keyword">while</span>(dep[x]&gt;dep[y])        x=par[x][lg[dep[x]-dep[y]]<span class="hljs-number">-1</span>];<span class="hljs-comment">//让深的往上跳</span>    <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span> x;    <span class="hljs-comment">//一起向上跳</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lg[dep[x]]<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)        <span class="hljs-keyword">if</span>(par[x][i]!=par[y][i])            x=par[x][i],y=par[y][i];    <span class="hljs-keyword">return</span> par[x][<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,r,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;r);    lg[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        lg[i]=lg[i<span class="hljs-number">-1</span>]+(<span class="hljs-number">1</span>&lt;&lt;lg[i<span class="hljs-number">-1</span>]==i);<span class="hljs-comment">//预处理出log2(i)+1</span>    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        add(x,y);add(y,x);    &#125;    dfs(r,r,<span class="hljs-number">1</span>);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,lca(x,y));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="树链剖分："><a href="#树链剖分：" class="headerlink" title="树链剖分："></a>树链剖分：</h4><p>对于两个不在同一重链内的节点，让他们不断地跳，使得他们处于同一重链上。往上跳之后两点在同一条重链上，LCA就是两点中深度更小的那个。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> top;<span class="hljs-keyword">int</span> head[<span class="hljs-number">500010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">1000010</span>];<span class="hljs-keyword">int</span> par[<span class="hljs-number">500010</span>];<span class="hljs-comment">//该结点的父亲</span><span class="hljs-keyword">int</span> dep[<span class="hljs-number">500010</span>];<span class="hljs-comment">//该结点的深度</span><span class="hljs-keyword">int</span> tot[<span class="hljs-number">500010</span>];<span class="hljs-comment">//该结点子树的结点个数</span><span class="hljs-keyword">int</span> son[<span class="hljs-number">500010</span>];<span class="hljs-comment">//该结点的重儿子编号</span><span class="hljs-keyword">int</span> idx[<span class="hljs-number">500010</span>];<span class="hljs-comment">//该结点重新编号后的编号</span><span class="hljs-keyword">int</span> topp[<span class="hljs-number">500010</span>];<span class="hljs-comment">//该结点所在链的顶端结点</span><span class="hljs-keyword">int</span> cnt;<span class="hljs-keyword">int</span> ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    eg[top].to=b;    eg[top].next=head[a];    head[a]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> depth)</span></span><span class="hljs-function"></span>&#123;    par[id]=fa;dep[id]=depth;    tot[id]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> maxson=<span class="hljs-number">-1</span>;    son[id]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(temp==fa)<span class="hljs-keyword">continue</span>;        tot[id]+=dfs1(temp,id,depth+<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(tot[temp]&gt;maxson)        &#123;            son[id]=temp;            maxson=tot[temp];        &#125;    &#125;    <span class="hljs-keyword">return</span> tot[id];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> topf)</span></span><span class="hljs-function"></span>&#123;    idx[id]=++cnt;    topp[id]=topf;    <span class="hljs-keyword">if</span>(son[id]==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;     <span class="hljs-comment">//子节点的son为0</span>    dfs2(son[id],topf);     <span class="hljs-comment">//优先标记重儿子</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(idx[temp]==<span class="hljs-number">0</span>)            dfs2(temp,temp);     <span class="hljs-comment">//每一条链以轻儿子为起点</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(topp[x]!=topp[y])    &#123;        <span class="hljs-keyword">if</span>(dep[topp[x]]&lt;dep[topp[y]])swap(x,y);     <span class="hljs-comment">//谁的top低谁就往上走</span>        x=par[topp[x]];    &#125;    <span class="hljs-keyword">if</span>(dep[x]&gt;dep[y])swap(x,y);    <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,r,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;r);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        head[i]=<span class="hljs-number">-1</span>;        idx[i]=<span class="hljs-number">0</span>;    &#125;    top=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        add(x,y);add(y,x);    &#125;    dfs1(r,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    cnt=<span class="hljs-number">0</span>;    dfs2(r,r);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,lca(x,y));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6391 思维+读入挂</title>
    <link href="/2018/08/14/HDU6391-%E6%80%9D%E7%BB%B4-%E8%AF%BB%E5%85%A5%E6%8C%82/"/>
    <url>/2018/08/14/HDU6391-%E6%80%9D%E7%BB%B4-%E8%AF%BB%E5%85%A5%E6%8C%82/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出k种属性，一个人的k种属性有初始值为<script type="math/tex">v_1,v_2,...,v_k</script>，他要去打n个怪兽，第i个怪兽也有k种属性<script type="math/tex">a_{i,1},a_{i,2},...,a_{i,k}</script>，如果当前的<script type="math/tex">v_1\geq a_{i,1},v_2\geq a_{i,2},...,v_k\geq a_{i,k}</script>，这个人就可以打第i个怪兽，并且每个属性得到怪兽的加成<script type="math/tex">b_{i,1},b_{i,2},...,b_{i,k}</script>。问你这个人最多可以打几个怪兽，并输出这个人最后的属性值。</p><p><strong>思路：</strong></p><p>贪心思路是要打的就打，从a小的开始打，所以先对怪兽的每种属性从小到大排序，拿k个指针去扫，对满足被打条件的属性的怪兽进行标记，当某个怪兽的所有属性都被标记了，就将b加给人，指针向后移动。</p><p>这里要用到读入挂。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ori[<span class="hljs-number">10</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> cost,id;&#125;;<span class="hljs-built_in">vector</span>&lt;node&gt;v[<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> cnt[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> val[<span class="hljs-number">100010</span>][<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> pos[<span class="hljs-number">10</span>];<span class="hljs-keyword">namespace</span> IO &#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MX = <span class="hljs-number">4e7</span>;    <span class="hljs-keyword">char</span> buf[MX]; <span class="hljs-keyword">int</span> c, sz;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123;        c = <span class="hljs-number">0</span>;        sz = fread(buf, <span class="hljs-number">1</span>, MX, <span class="hljs-built_in">stdin</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;t)</span> </span>&#123;        <span class="hljs-keyword">while</span>(c &lt; sz &amp;&amp; buf[c] != <span class="hljs-string">'-'</span> &amp;&amp; (buf[c] &lt; <span class="hljs-string">'0'</span> || buf[c] &gt; <span class="hljs-string">'9'</span>)) c++;        <span class="hljs-keyword">if</span>(c &gt;= sz) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">0</span>; <span class="hljs-keyword">if</span>(buf[c] == <span class="hljs-string">'-'</span>) flag = <span class="hljs-number">1</span>, c++;        <span class="hljs-keyword">for</span>(t = <span class="hljs-number">0</span>; c &lt; sz &amp;&amp; <span class="hljs-string">'0'</span> &lt;= buf[c] &amp;&amp; buf[c] &lt;= <span class="hljs-string">'9'</span>; c++) t = t * <span class="hljs-number">10</span> + buf[c] - <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span>(flag) t = -t;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x.cost&lt;y.cost;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    IO::<span class="hljs-built_in">begin</span>();    <span class="hljs-keyword">int</span> t,n,k,x;    <span class="hljs-comment">//scanf("%d",&amp;t);</span>    IO::<span class="hljs-built_in">read</span>(t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-comment">//scanf("%d%d",&amp;n,&amp;k);</span>        IO::<span class="hljs-built_in">read</span>(n);IO::<span class="hljs-built_in">read</span>(k);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)        &#123;            <span class="hljs-comment">//scanf("%d",&amp;ori[i]);</span>            IO::<span class="hljs-built_in">read</span>(ori[i]);            v[i].resize(n+<span class="hljs-number">1</span>);            pos[i]=<span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            cnt[i]=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)            &#123;                <span class="hljs-comment">//scanf("%d",&amp;x);</span>                IO::<span class="hljs-built_in">read</span>(x);                v[j][i]=node&#123;x,i&#125;;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)                <span class="hljs-comment">//scanf("%d",&amp;val[i][j]);</span>                IO::<span class="hljs-built_in">read</span>(val[i][j]);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)            sort(v[i].<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,v[i].<span class="hljs-built_in">begin</span>()+n+<span class="hljs-number">1</span>,cmp);        <span class="hljs-comment">/*for(int i=1;i&lt;=k;i++)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            for(int j=1;j&lt;=n;j++)</span><span class="hljs-comment">                printf("(%d,%d)",v[i][j].cost,v[i][j].id);</span><span class="hljs-comment">            printf("\n");</span><span class="hljs-comment">        &#125;*/</span>        <span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=pos[i]+<span class="hljs-number">1</span>;j&lt;=n;j++)                &#123;                    <span class="hljs-keyword">if</span>(v[i][j].cost&lt;=ori[i])                    &#123;                        sign++;                        cnt[v[i][j].id]++;                        <span class="hljs-keyword">if</span>(cnt[v[i][j].id]==k)                        &#123;                            tot++;                            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l&lt;=k;l++)                                ori[l]+=val[v[i][j].id][l];                        &#125;                        pos[i]=j;                    &#125;                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span>(sign==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,tot);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;k;i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,ori[i]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ori[k]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6376 思维+dp</title>
    <link href="/2018/08/12/HDU6376-%E6%80%9D%E7%BB%B4-dp/"/>
    <url>/2018/08/12/HDU6376-%E6%80%9D%E7%BB%B4-dp/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>一张纸条上依次写着N个数字，数字只可能是0或者1。在纸条上剪K刀，这样就形成了K+1段，再把这K+1段按一定的顺序重新拼起来。问前缀 1 的数量最多能是多少。</p><p><strong>思路：</strong></p><p>分类讨论不会啊…太菜了啊QAQ</p><p>看了题解有一种dp的做法，这比较好理解。</p><p>要把这个01串原本的前缀1剪下来只要剪1次，把原本的后缀1剪下来也要剪1次，中间的一串1剪下来要剪2次，所以这就是一个背包问题了，但是比如1101110011，如果这种策略的话要使前缀最大至少要5次，事实上只要4次，因为11100只要剪一次，放在最后面就可以了，所以事实上可以剪k+1次。</p><p>这里注意要特判全是1和k为0的情况。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">char</span> a[<span class="hljs-number">10010</span>];<span class="hljs-keyword">int</span> w[<span class="hljs-number">10010</span>];<span class="hljs-keyword">int</span> v[<span class="hljs-number">10010</span>];<span class="hljs-keyword">int</span> dp[<span class="hljs-number">10010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,k;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k)!=EOF)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);        <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(a);        <span class="hljs-keyword">int</span> s,e;        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len&amp;&amp;sign==<span class="hljs-number">0</span>;i++)            <span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-string">'1'</span>)sign++;        <span class="hljs-keyword">if</span>(sign==<span class="hljs-number">0</span>)        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,len);            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        &#123;            <span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-string">'1'</span>)            &#123;                s=i;                <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)                &#123;                    v[++cnt]=i;                    w[cnt]=<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,v[cnt]);<span class="hljs-keyword">continue</span>;&#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)        &#123;            <span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-string">'1'</span>)            &#123;                e=i;                <span class="hljs-keyword">if</span>(i!=len<span class="hljs-number">-1</span>)                &#123;                    v[++cnt]=len<span class="hljs-number">-1</span>-i;                    w[cnt]=<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s;i&lt;=e;i++)        &#123;            <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">'0'</span>)            &#123;                <span class="hljs-keyword">if</span>(l!=<span class="hljs-number">0</span>)                &#123;                    v[++cnt]=l;                    w[cnt]=<span class="hljs-number">2</span>;                &#125;                l=<span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> l++;        &#125;        <span class="hljs-comment">//for(int i=1;i&lt;=cnt;i++)</span>            <span class="hljs-comment">//printf("%d %d\n",w[i],v[i]);</span>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=k+<span class="hljs-number">1</span>;j&gt;=w[i];j--)            &#123;                dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[k+<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The North American Invitational Programming Contest 2018 H 构造</title>
    <link href="/2018/08/12/The-North-American-Invitational-Programming-Contest-2018-H-%E6%9E%84%E9%80%A0/"/>
    <url>/2018/08/12/The-North-American-Invitational-Programming-Contest-2018-H-%E6%9E%84%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有一个n*m的矩阵，对于每一行，如果行中有奇数个1，则置1，反之则置0，对于每一列也这样操作。</p><p>比如<script type="math/tex">\begin{matrix}    1 & 1 & 1 &1 \\    0 & 1 & 1 & 1 \\   0 &1 & 1&1 \\  0 & 1 & 1 & 0  \end{matrix}</script>，行为<script type="math/tex">[0,1,1,0]</script>，列为<script type="math/tex">[1,0,0,1]</script>。</p><p>给出行和列的情况，让你复原这个矩阵。</p><p>如果没有这种矩阵，则输出-1。如果有多个，1多的优先输出，如果多个矩阵有相同数量的1，则输出将每一行连在一起后字典序最小的。</p><p><strong>思路：</strong></p><p>先把矩阵填1，看行和列的情况，根据行数列数的奇偶，可以知道每一行和每一列分别至少要几个0。</p><p>如果行中需要的0与列中需要的0相同，说明是可以直接构造的；如果行中需要的0与列中需要的0相差的个数为2的倍数，说明可以通过多加几个零来实现；如果都不是，就说明不能构造，因为要保证奇偶性相同，就一定要是2的倍数。如果要加0的话，要尽可能加在高位，这样才可以保证字典序最小。</p><p>把行和列的0变成相同以后就可以直接做了。对于某一行零的个数，从左往右往每一列里可以放的地方就放，当然对于每一行，每一列只能放一个。就这样放就可以了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">char</span> r[<span class="hljs-number">55</span>],c[<span class="hljs-number">55</span>];<span class="hljs-keyword">int</span> rr[<span class="hljs-number">55</span>],cc[<span class="hljs-number">55</span>];<span class="hljs-comment">//每一行/列各有几个0</span><span class="hljs-keyword">int</span> ans[<span class="hljs-number">55</span>][<span class="hljs-number">55</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> rlen,clen;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,r);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,c);    rlen=<span class="hljs-built_in">strlen</span>(r);clen=<span class="hljs-built_in">strlen</span>(c);<span class="hljs-comment">//行数/列数</span>    <span class="hljs-keyword">int</span> r0=<span class="hljs-number">0</span>,c0=<span class="hljs-number">0</span>;<span class="hljs-comment">//行/列共有几个0</span>    <span class="hljs-comment">//printf("%d %d\n",rlen,clen);</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;rlen;i++)    &#123;        <span class="hljs-keyword">if</span>(clen%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&amp;&amp;r[i]==<span class="hljs-string">'1'</span>)        &#123;            r0++;            rr[i]++;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(clen%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>&amp;&amp;r[i]==<span class="hljs-string">'0'</span>)        &#123;            r0++;            rr[i]++;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;clen;i++)    &#123;        <span class="hljs-keyword">if</span>(rlen%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&amp;&amp;c[i]==<span class="hljs-string">'1'</span>)        &#123;            c0++;            cc[i]++;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rlen%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>&amp;&amp;c[i]==<span class="hljs-string">'0'</span>)        &#123;            c0++;            cc[i]++;        &#125;    &#125;    <span class="hljs-comment">//printf("%d %d\n",r0,c0);</span>    <span class="hljs-keyword">if</span>(r0&gt;c0&amp;&amp;(r0-c0)%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>||c0&gt;r0&amp;&amp;(c0-r0)%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">if</span>(r0&gt;c0)        &#123;            <span class="hljs-keyword">int</span> d=r0-c0;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;clen;i++)            &#123;                <span class="hljs-keyword">while</span>(cc[i]+<span class="hljs-number">2</span>&lt;=rlen)                &#123;                    cc[i]+=<span class="hljs-number">2</span>;                    d-=<span class="hljs-number">2</span>;                    <span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c0&gt;r0)        &#123;            <span class="hljs-keyword">int</span> d=c0-r0;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;rlen;i++)            &#123;                <span class="hljs-keyword">while</span>(rr[i]+<span class="hljs-number">2</span>&lt;=clen)                &#123;                    rr[i]+=<span class="hljs-number">2</span>;                    d-=<span class="hljs-number">2</span>;                    <span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//for(int i=0;i&lt;rlen;i++)</span>        <span class="hljs-comment">//printf("%d ",rr[i]);</span>    <span class="hljs-comment">//for(int j=0;j&lt;clen;j++)</span>        <span class="hljs-comment">//printf("%d ",cc[j]);</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;rlen;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;clen;j++)        ans[i][j]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;rlen;i++)    &#123;        <span class="hljs-keyword">if</span>(rr[i]==<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;clen;j++)        &#123;            <span class="hljs-keyword">if</span>(cc[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;            ans[i][j]=<span class="hljs-number">0</span>;            cc[j]--;rr[i]--;            <span class="hljs-keyword">if</span>(rr[i]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-comment">//printf("!\n");</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;rlen;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;clen;j++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,ans[i][j]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希</title>
    <link href="/2018/08/10/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2018/08/10/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<p>想学习一下字符串哈希结果发现以前自己已经脑补出来用过了啊？虽然base和mod取的不是那么好…</p><p>参考资料：<a href="https://wenku.baidu.com/view/b7d3d1c6804d2b160a4ec090" target="_blank" rel="noopener">https://wenku.baidu.com/view/b7d3d1c6804d2b160a4ec090</a></p><p>hash函数：<script type="math/tex">hash[i]=(hash[i-1]*p+idx(s[i]))\%mod</script>。</p><p>子串的hash值（下标从1开始）：<script type="math/tex">hash[l,r]=(hash[r]-hash[l-1]*p^{r-l+1})\%mod</script>。</p><p>获取哈希值的函数用inline似乎会快一点。</p><p>以求N个字符串中有多少个不同的字符串为例存个模板（这里的排序用set替代也是可以的）：</p><p><strong>自然溢出（最快）：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">const</span> ull base=<span class="hljs-number">131</span>;<span class="hljs-keyword">char</span> a[<span class="hljs-number">2000</span>];ull temp[<span class="hljs-number">10010</span>];<span class="hljs-function">ull <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(a);    ull ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        ans=ans*base+(ull)a[i];<span class="hljs-comment">//这里有时候不必要的剪枝就不要剪了啊</span>    <span class="hljs-keyword">return</span> ans&amp;<span class="hljs-number">0x7fffffff</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);        temp[i]=solve();    &#125;    sort(temp,temp+n);    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">if</span>(temp[i]!=temp[i<span class="hljs-number">-1</span>])            ans++;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>用<script type="math/tex">10^{18}</script>的大质数取模：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">const</span> ull base=<span class="hljs-number">131</span>;<span class="hljs-keyword">const</span> ull mod=<span class="hljs-number">212370440130137957l</span>l;<span class="hljs-keyword">char</span> a[<span class="hljs-number">2000</span>];ull temp[<span class="hljs-number">10010</span>];<span class="hljs-function">ull <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(a);    ull ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        ans=(ans*base+(ull)a[i])%mod;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);        temp[i]=solve();    &#125;    sort(temp,temp+n);    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">if</span>(temp[i]!=temp[i<span class="hljs-number">-1</span>])            ans++;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>双哈希（最保险）：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ull;<span class="hljs-keyword">const</span> ull base=<span class="hljs-number">131</span>;<span class="hljs-keyword">const</span> ull mod1=<span class="hljs-number">19260817</span>;<span class="hljs-keyword">const</span> ull mod2=<span class="hljs-number">19660813</span>;<span class="hljs-keyword">char</span> a[<span class="hljs-number">2000</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    ull x,y;&#125;temp[<span class="hljs-number">10010</span>];<span class="hljs-function">ull <span class="hljs-title">solve</span><span class="hljs-params">(ull p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(a);    ull ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        ans=(ans*base+(ull)a[i])%p;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node aa,node bb)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(aa.x!=bb.x)<span class="hljs-keyword">return</span> aa.x&lt;bb.x;    <span class="hljs-keyword">return</span> aa.y&lt;bb.y;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);        temp[i].x=solve(mod1);        temp[i].y=solve(mod2);    &#125;    sort(temp,temp+n,cmp);    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">if</span>(temp[i].x!=temp[i<span class="hljs-number">-1</span>].x||temp[i].y!=temp[i<span class="hljs-number">-1</span>].y)            ans++;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>手写哈希表（拉链法）：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">4000007</span>;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">used</span><span class="hljs-params">(ull x)</span><span class="hljs-comment">//手写拉链法哈希</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp=x%mod;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[temp];i!=<span class="hljs-number">-1</span>;i=nxt[i])        <span class="hljs-keyword">if</span>(val[i]==x)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    val[++cnt]=x;    nxt[cnt]=head[temp];    head[temp]=cnt;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6325 凸包</title>
    <link href="/2018/08/09/HDU6325-%E5%87%B8%E5%8C%85/"/>
    <url>/2018/08/09/HDU6325-%E5%87%B8%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n个点，每个点有个坐标，要从第一个点开始到第n个点结束。当在第i个点的时候，他下一步只能去第j个点，i,j满足<script type="math/tex">x_i<x_j</script>,从i到j需要花费<script type="math/tex">x_i*y_j-x_j* y_i</script>的能量。如果能量是负的，则表明它得到了供给。请输出从第一个点到第n个点的最小花费的路径，如果有多条具有相同的最小花费，输出字典序最小的。其中<script type="math/tex">y_1=y_n=0，0=x_1<x_2,x_3,...,x_{n−1}<x_n，0≤x_i,y_i≤10^9</script>。</p><p><strong>思路：</strong></p><p>看到<script type="math/tex">x_i*y_j-x_j*y_i</script>就想到叉积了，因为叉积的值表示的是以<script type="math/tex">\vec{a}</script>和<script type="math/tex">\vec{b}</script>为相邻边形成平行四边形的面积，由于从起点到终点肯定是沿着顺时针方向走一条路径，再从终点往起点连一条路，这样整条路径就围成了一个凸包，由于这是顺时针围成的，所以面积是负的（平常的凸包是逆时针围成的，面积是正的），因为代价要尽可能小，所以该面积就要尽可能大，所以就可以发现一定要走凸壳了。</p><p>关于面积是负的解释：</p><p>若a×b&gt;0，表示a在b的顺时针方向上；</p><p>若a×b&lt;0，表示a在b的逆时针方向上；</p><p>若a×b==0表示a和b共线，但不确定方向是否相同。</p><p>因为起点到终点是顺时针走的，所以对于i到j这两个点，i在j的逆时针方向上，所以<script type="math/tex">\vec{i}\times \vec{j}=x_i*y_j-x_j*y_i<0</script>，而这两个向量形成的面积肯定是正的，所以说面积是代价的相反数。</p><p>所以复习了一下Graham扫描法，这里有篇博客的图解挺好的：<a href="https://www.cnblogs.com/cjyyb/p/7260523.html。" target="_blank" rel="noopener">https://www.cnblogs.com/cjyyb/p/7260523.html。</a></p><p>学习到了这种思想，结合题目，就知道排序要先按照x从小到大，如果x相同按照y从大到小，如果y还是相同按照id从大到小。之后就是扫描，画一下图知道如果叉积&gt;0，应该把栈顶弹掉，或者如果共线（叉积==0），为了字典序最小，如果id比栈顶小，也把栈顶弹掉。</p><p>注意有多个星球可以具有相同坐标，而且i,j满足<script type="math/tex">x_i<x_j</script>这些条件吧。</p><p>这里x,y要开ll，因为我写的代码里有x*x，会爆int。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    ll x,y;<span class="hljs-comment">//要开ll</span>    <span class="hljs-keyword">int</span> id;&#125;a[<span class="hljs-number">200010</span>],p[<span class="hljs-number">200010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(<span class="hljs-built_in">point</span> aa,<span class="hljs-built_in">point</span> bb)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(aa.x!=bb.x)<span class="hljs-keyword">return</span> aa.x&lt;bb.x;    <span class="hljs-keyword">if</span>(aa.y!=bb.y)<span class="hljs-keyword">return</span> aa.y&lt;bb.y;    <span class="hljs-keyword">return</span> aa.id&lt;bb.id;&#125;<span class="hljs-keyword">int</span> n,top;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cross</span><span class="hljs-params">(<span class="hljs-built_in">point</span> p0,<span class="hljs-built_in">point</span> p1,<span class="hljs-built_in">point</span> p2)</span><span class="hljs-comment">//叉乘判断在左边还是右边</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>*(p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">point</span> p1,<span class="hljs-built_in">point</span> p2)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(p1.x!=p2.x)<span class="hljs-keyword">return</span> p1.x&lt;p2.x;    <span class="hljs-keyword">if</span>(p1.y!=p2.y)<span class="hljs-keyword">return</span> p1.y&gt;p2.y;    <span class="hljs-keyword">return</span> p1.id&lt;p2.id;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">graham</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    sort(a,a+n,cmp);    <span class="hljs-comment">/*for(int i=0;i&lt;n;i++)</span><span class="hljs-comment">        printf("%d %d %d\n",a[i].x,a[i].y,a[i].id);*/</span>    top=<span class="hljs-number">1</span>;    p[<span class="hljs-number">0</span>]=a[<span class="hljs-number">0</span>];    p[<span class="hljs-number">1</span>]=a[<span class="hljs-number">1</span>];<span class="hljs-comment">//0,1入栈</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">if</span>(a[i].x==a[i<span class="hljs-number">-1</span>].x)<span class="hljs-keyword">continue</span>;        <span class="hljs-comment">//栈顶和栈顶的前一个连线，如果当前点在右边的话，栈顶出栈，继续</span>        <span class="hljs-keyword">while</span>((top&amp;&amp;((cross(p[top<span class="hljs-number">-1</span>],p[top],a[i])&gt;<span class="hljs-number">0</span>)||(cross(p[top<span class="hljs-number">-1</span>],p[top],a[i])==<span class="hljs-number">0</span>&amp;&amp;a[i].id&lt;p[top].id))))            <span class="hljs-comment">//printf("%d\n",i);</span>            top--;        top++;        p[top]=a[i];    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("C:/Users/lenovo/Desktop/学习/2018HDUContest/G","r",stdin);</span>    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;a[i].x,&amp;a[i].y);            a[i].id=i+<span class="hljs-number">1</span>;        &#125;        graham();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;top;i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,p[i].id);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,p[top].id);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> 1</span><span class="hljs-comment"> 5</span><span class="hljs-comment"> 0 0</span><span class="hljs-comment"> 1 2</span><span class="hljs-comment"> 1 1</span><span class="hljs-comment"> 2 2</span><span class="hljs-comment"> 2 0</span><span class="hljs-comment"> */</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6363 公式推导+容斥定理</title>
    <link href="/2018/08/09/HDU6363-%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC-%E5%AE%B9%E6%96%A5%E5%AE%9A%E7%90%86/"/>
    <url>/2018/08/09/HDU6363-%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC-%E5%AE%B9%E6%96%A5%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>总共有N本书，要放到一个K层的书架上去。假设每一层最后放了<script type="math/tex">cnt_i</script>本书，f[i]为斐波那契数列(f[0]=0,f[1]=1)，定义第i层书架的稳定值为<script type="math/tex">stable_i=f[cnt_i]</script>，第i层书架的美观值为<script type="math/tex">beauty_i=2^{stable_i}-1</script>，定义分数为<script type="math/tex">score=gcd(beauty_1,beauty_2,...,beauty_k)</script>。问分数的期望为多少。</p><p><strong>思路：</strong></p><p>有两个公式，</p><p><script type="math/tex">gcd(a^m-1,b^n-1)=a^{gcd(m,n)}-1</script>，其中a,m,n&gt;0。</p><p><script type="math/tex">gcd(f[x],f[y])=f_{gcd(m,n)}</script>。</p><p>假设每一层放了<script type="math/tex">x_1,x_2,...,x_k</script>本书，即<script type="math/tex">x_1+x_2+...+x_k=n</script>，则分数为<script type="math/tex">gcd(2^{f[x_1]}-1,2^{f[x_2]}-1,...,2^{f[x_k]}-1)</script>，由第一个公式，有<script type="math/tex">2^{gcd(f[x_1],f[x_2],...,f[x_k])}-1</script>。由第二个公式，继续化为<script type="math/tex">2^{f_{gcd(x_1,x_2,...,x_k)}}-1</script>。</p><p>设<script type="math/tex">g=gcd(x_1,x_2,...,x_k)</script>，则有<script type="math/tex">x_1=s_1*g,x_2=s_2*g,...,x_k=s_k*g(s为系数)</script>，相加有<script type="math/tex">n=g*(s_1+s_2+...+s_k)</script>，所以g可以由枚举n的因子得到。</p><p>对于每个g，问题就转化为了将<script type="math/tex">\frac{n}{g}</script>个系数分配给k层的问题，这是可以有空位的整数拆分问题，方案数为<script type="math/tex">C_{\frac{n}{g}+k-1}^{k-1}</script>（具体可见<a href="https://wenku.baidu.com/view/6f822211dd36a32d7375816b.html）。" target="_blank" rel="noopener">https://wenku.baidu.com/view/6f822211dd36a32d7375816b.html）。</a></p><p>然而这样子是有重复的，比如n=15，k=1，那么g有1,3,5,15，如果直接算方案数应该是1+1+1+1，但是事实上都是重复的，实际只有一种情况，所以这里就要用到容斥定理了。</p><p>要把某个数倍数的情况都从这个小的数里减去（如果把大的置0是不行的，因为这个数可能是多个数的倍数，那它的其他因数的方案就还是重复的了），而且要从大到小枚举，比如上个例子，如果从小到大的话1就被减了多次，其实是不能这样的，而是得把比它大的都处理完才行。</p><p>刚开始一直想不出这里容斥原理要怎么用，后来还是看了代码理解的…举个栗子就清楚一点。</p><p>对于<script type="math/tex">2^{f_g}-1</script>的处理，因为<script type="math/tex">f_g</script>非常大，所以可以用欧拉降幂公式或者费马小定理（因为2与MOD互质）。<script type="math/tex">2^{f_g}\%p=2^{f_gmod(p-1)}\% p</script>。</p><p>要计算期望，分子为<script type="math/tex">\sum</script>分数*该分数的方案数，分母为总方案数。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll fac[<span class="hljs-number">2000010</span>];ll inv[<span class="hljs-number">2000010</span>];ll f[<span class="hljs-number">1000010</span>];ll sum[<span class="hljs-number">1000010</span>];<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">PowerMod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k;    k=a;    k=k%c;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)            ans=(ans*k)%c;        b&gt;&gt;=<span class="hljs-number">1</span>;        k=(k*k)%c;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=MAXN;i++)        fac[i]=fac[i<span class="hljs-number">-1</span>]*i%MOD;    inv[MAXN]=PowerMod(fac[MAXN],MOD<span class="hljs-number">-2</span>,MOD);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=MAXN<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)        inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%MOD;    f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">1000000</span>;i++)        f[i]=(f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>])%(MOD<span class="hljs-number">-1</span>);&#125;<span class="hljs-function">ll <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(n&lt;m)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> fac[n]*inv[m]%MOD*inv[n-m]%MOD;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,k;    init();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k);        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;ft;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//枚举g</span>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)ft.push_back(i);        <span class="hljs-keyword">int</span> len=ft.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)            sum[i]=calc(n/ft[i]+k<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>);        <span class="hljs-comment">/*for(int i=0;i&lt;len;i++)</span><span class="hljs-comment">            printf("%lld ",sum[i]);</span><span class="hljs-comment">        printf("\n");*/</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;len;j++)            <span class="hljs-keyword">if</span>(ft[j]%ft[i]==<span class="hljs-number">0</span>)                sum[i]=(sum[i]-sum[j]+MOD)%MOD;        <span class="hljs-comment">/*for(int i=0;i&lt;len;i++)</span><span class="hljs-comment">            printf("%lld ",sum[i]);</span><span class="hljs-comment">        printf("\n");*/</span>        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)            ans=(ans+(((PowerMod(<span class="hljs-number">2l</span>l,f[ft[i]]%(MOD<span class="hljs-number">-1</span>),MOD)<span class="hljs-number">-1</span>)*sum[i])%MOD))%MOD;        ll tot=calc(n+k<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>);        ans=(ans*PowerMod(tot,MOD<span class="hljs-number">-2</span>,MOD))%MOD;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6370 思维+tarjan缩点</title>
    <link href="/2018/08/08/HDU6370-%E6%80%9D%E7%BB%B4-tarjan%E7%BC%A9%E7%82%B9/"/>
    <url>/2018/08/08/HDU6370-%E6%80%9D%E7%BB%B4-tarjan%E7%BC%A9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>在狼人杀里，有三种类型的人，一种是狼人，一种是村民，还有一种是不确定身份的人。已知村民不会撒谎，狼人可能会撒谎。每个人都会说一句话，比如玩家x是狼人或者玩家x是村民，自己不会说自己。问狼人和村民各有几人。其中<script type="math/tex">1≤T≤10,1≤N≤100000</script>。</p><p><strong>思路：</strong></p><p>在比赛的时候思路在经过把本来的想法的叉掉的过程之后是对了，然而不会写…</p><p>因为无论说什么全部人都是狼的情况都肯定是成立的，所以不存在确定的村民。</p><p>考虑两个人成环的时候，只有当1说2是v，2说1是w的时候能确定1是狼人。考虑三个人成环的时候，只有当1说2是v，2说3是v，3说w的时候能确定1是狼人。所以对于每个环，当只存在一条狼边的时候，这条狼边指向的人是狼人。</p><p>说确定的狼人是村民的人肯定在说谎，所以说狼人是村民的人肯定也是狼人。</p><p>写的时候有点麻烦啊…直接写对于标记的处理有点搞不清楚…</p><p>网上搜题解有用缩点做的，用缩点来处理环的确是好写一点。</p><p>缩点后得到一些强连通分量，统计每个强连通分量的结点数和狼边的条数（遍历每个人的出边，如果是狼边，它所在的强连通分量狼边条数++），如果点数大于等于2并且狼边只有一条，说明狼边指向的就是狼人，标记为狼人，然后对于每个确定的狼人，搜说他是村民的人（反向存边），那些人也是狼人。</p><p>这样复杂度也是可以的，是<script type="math/tex">O(n+n)</script>。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to,val;&#125;v[<span class="hljs-number">100010</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;rv[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> dfn[<span class="hljs-number">100010</span>];<span class="hljs-comment">//在DFS中该节点被搜索的次序</span><span class="hljs-keyword">int</span> low[<span class="hljs-number">100010</span>];<span class="hljs-comment">//i或i的子树能够通过非树边追溯到最早的祖先节点（即DFS次序号最小）</span><span class="hljs-keyword">int</span> sccn[<span class="hljs-number">100010</span>];<span class="hljs-comment">//缩点数组，表示某个点对应的强连通分量编号</span><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">100010</span>];<span class="hljs-comment">//是否在栈中</span><span class="hljs-keyword">int</span> num[<span class="hljs-number">100010</span>];<span class="hljs-comment">//编号为i的强连通分量中点的数量</span><span class="hljs-keyword">int</span> w[<span class="hljs-number">100010</span>];<span class="hljs-comment">//编号为i的强连通分量中狼边的数量</span><span class="hljs-keyword">int</span> id[<span class="hljs-number">100010</span>];<span class="hljs-comment">//编号为i的强连通分量中狼的编号</span><span class="hljs-keyword">int</span> tp[<span class="hljs-number">100010</span>];<span class="hljs-comment">//身份</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>;<span class="hljs-keyword">int</span> cnt;<span class="hljs-comment">//强连通分量编号</span><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;s;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><span class="hljs-function"></span>&#123;    dfn[u]=low[u]=++<span class="hljs-built_in">step</span>;    vis[u]=<span class="hljs-literal">true</span>;    s.push(u);    <span class="hljs-keyword">int</span> temp=v[u].to;    <span class="hljs-keyword">if</span>(!dfn[temp])<span class="hljs-comment">//没有被访问过</span>    &#123;        tarjan(temp);        low[u]=<span class="hljs-built_in">min</span>(low[u],low[temp]);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[temp])<span class="hljs-comment">//在栈中</span>        low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[temp]);    <span class="hljs-keyword">if</span>(low[u]==dfn[u])<span class="hljs-comment">//构成强连通分量</span>    &#123;        cnt++;        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">int</span> temp=s.top();            s.pop();<span class="hljs-comment">//此点以上的点全部出栈，构成一个强连通分量</span>            vis[temp]=<span class="hljs-literal">false</span>;            sccn[temp]=cnt;<span class="hljs-comment">//cnt是强连通分量的序号</span>            <span class="hljs-keyword">if</span>(temp==u)<span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=rv[cur].<span class="hljs-built_in">size</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(tp[rv[cur][i]]==<span class="hljs-number">-1</span>)        &#123;            tp[rv[cur][i]]=<span class="hljs-number">0</span>;            dfs(rv[cur][i]);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,x;    <span class="hljs-keyword">char</span> s[<span class="hljs-number">20</span>];    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            rv[i].<span class="hljs-built_in">clear</span>();            dfn[i]=sccn[i]=num[i]=w[i]=id[i]=<span class="hljs-number">0</span>;            vis[i]=<span class="hljs-literal">false</span>;            tp[i]=<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s);            <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">'w'</span>)                v[i]=node&#123;x,<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//狼边</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">'v'</span>)            &#123;                v[i]=node&#123;x,<span class="hljs-number">1</span>&#125;;                rv[x].push_back(i);            &#125;        &#125;        <span class="hljs-built_in">step</span>=cnt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">if</span>(!dfn[i])                tarjan(i);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            num[sccn[i]]++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">if</span>(v[i].val==<span class="hljs-number">0</span>)            &#123;                w[sccn[i]]++;                id[sccn[i]]=v[i].to;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)        &#123;            <span class="hljs-keyword">if</span>(num[i]&gt;=<span class="hljs-number">2</span>&amp;&amp;w[i]==<span class="hljs-number">1</span>)            &#123;                tp[id[i]]=<span class="hljs-number">0</span>;                dfs(id[i]);            &#125;        &#125;        <span class="hljs-keyword">int</span> ans1=<span class="hljs-number">0</span>,ans2=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">if</span>(tp[i]==<span class="hljs-number">0</span>)ans2++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tp[i]==<span class="hljs-number">1</span>)ans1++;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,ans1,ans2);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU5439 找规律+预处理+二分</title>
    <link href="/2018/08/08/HDU5439-%E6%89%BE%E8%A7%84%E5%BE%8B-%E9%A2%84%E5%A4%84%E7%90%86-%E4%BA%8C%E5%88%86/"/>
    <url>/2018/08/08/HDU5439-%E6%89%BE%E8%A7%84%E5%BE%8B-%E9%A2%84%E5%A4%84%E7%90%86-%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>写下一组数，</p><p>1.先写1,2,2。</p><p>2.第三个数字是2，所以在后面写两个3。</p><p>3.第四个数字是3，所以在后面三个4。</p><p>4.像这样可以得到1,2,2,3,3,4,4,4,5,5,5,6,6,6,6。</p><p>给出一个数字n，假设这个n的最后出现的位置为p，求p最后出现的位置。其中<script type="math/tex">n≤10^9</script>。</p><p><strong>思路：</strong></p><p>可以找出规律要求的<script type="math/tex">F[n]=pre[pre[n]]</script>，其中<script type="math/tex">pre[n]</script>为原数列的前缀和，可以写几项。</p><script type="math/tex; mode=display">F[1]=pre[pre[1]]=1</script><script type="math/tex; mode=display">F[2]=pre[pre[2]]=pre[3]=1*1+2*2</script><script type="math/tex; mode=display">F[3]=pre[pre[3]]=pre[5]=1*1+2*2+3*2</script><script type="math/tex; mode=display">F[4]=pre[pre[4]]=pre[8]=1*1+2*2+3*2+4*3</script><script type="math/tex; mode=display">F[5]=pre[pre[5]]=1*1+2*2+3*2+4*3+5*3=1*1+(2+3)*2+(4+5)*3</script><script type="math/tex; mode=display">F[6]=1*1+(2+3)*2+(4*5)*3+6*4</script><script type="math/tex; mode=display">F[7]=1*1+(2+3)*2+(4*5)*3+(6+7)*4</script><script type="math/tex; mode=display">F[8]=1*1+(2+3)*2+(4*5)*3+(6+7+8)*4</script><p>由此可以知道<script type="math/tex">F[n]=\sum_{i=1}^ni*f[i]</script>，其中<script type="math/tex">f[i]</script>表示原数列。</p><p>因为原数列可以根据值分成几块，所以预处理出</p><p><script type="math/tex">f[i]</script>：原数列，</p><p><script type="math/tex">locr[i]</script>：i最后一次出现的位置，</p><p><script type="math/tex">pre[i]</script>：第<script type="math/tex">locr[i]</script>个数的<script type="math/tex">F[i]</script>。</p><p>这些东西就可以了，对于一个n其他多余的要加的东西可以在块内进行。</p><p>所以二分一下每个n在哪一块里再把前面的<script type="math/tex">pre</script>和块内的加起来就可以了。</p><p>找规律的题做法直接说出来的确有点抽象，这种东西还是要自己手推一下…</p><p>找规律的题分块的确是一种写法。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> cnt;ll f[<span class="hljs-number">1000010</span>];ll locr[<span class="hljs-number">1000010</span>];<span class="hljs-comment">//最后一次出现的位置</span>ll pre[<span class="hljs-number">1000010</span>];<span class="hljs-comment">//第locr[i]个数的值</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;f[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;f[<span class="hljs-number">3</span>]=<span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> cur=<span class="hljs-number">3</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">3</span>;cur&lt;=<span class="hljs-number">440000</span>;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;f[i];j++)            f[++cur]=i;    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=20;i++)</span><span class="hljs-comment">        printf("%lld ",f[i]);</span><span class="hljs-comment">    printf("\n");*/</span>    locr[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;;i++)    &#123;        locr[i]=locr[i<span class="hljs-number">-1</span>]+f[i];        <span class="hljs-keyword">if</span>(locr[i]&gt;<span class="hljs-number">1e9</span>)        &#123;            cnt=i<span class="hljs-number">-1</span>;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=10;i++)</span><span class="hljs-comment">        printf("%lld ",locr[i]);</span><span class="hljs-comment">    printf("\n");*/</span>    pre[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=cnt;i++)        pre[i]=(pre[i<span class="hljs-number">-1</span>]+((((locr[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>+locr[i])*(locr[i]-locr[i<span class="hljs-number">-1</span>]))%MOD*<span class="hljs-number">500000004l</span>l)%MOD*i)%MOD)%MOD;    <span class="hljs-comment">/*for(int i=1;i&lt;=10;i++)</span><span class="hljs-comment">        printf("%lld ",pre[i]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    init();    <span class="hljs-comment">//printf("%d\n",cnt);</span>    <span class="hljs-keyword">int</span> t;    ll n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n);        <span class="hljs-keyword">int</span> pos=upper_bound(locr+<span class="hljs-number">1</span>,locr+<span class="hljs-number">1</span>+cnt,n)-locr;        pos--;        <span class="hljs-comment">//printf("%d\n",pos);</span>        ll ans=<span class="hljs-number">0</span>;        ans=(ans+pre[pos])%MOD;        ans=(ans+((((locr[pos]+<span class="hljs-number">1</span>+n)*(n-locr[pos]))%MOD*<span class="hljs-number">500000004l</span>l)%MOD*(pos+<span class="hljs-number">1</span>))%MOD)%MOD;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU5446 lucas定理+中国剩余定理+快速乘</title>
    <link href="/2018/08/07/HDU5446-lucas%E5%AE%9A%E7%90%86-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-%E5%BF%AB%E9%80%9F%E4%B9%98/"/>
    <url>/2018/08/07/HDU5446-lucas%E5%AE%9A%E7%90%86-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86-%E5%BF%AB%E9%80%9F%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出n,m，还有k个质数$p_1,…,p_k$，有$M=p1·p2···p3$，求$C_n^m\%M$的值。其中$T≤20,1≤m≤n≤10^{18},1≤k≤10,M≤10^{18},pi≤10^5$。</p><p><strong>思路：</strong></p><p>这题目有点套路啊？（模板一顿乱套系列…然而比赛的时候并没有想到…完全忘记了之前学的中国剩余定理啊…</p><p>用Lucas定理处理出每个$C_n^m\%p_i$的值，可以得到一堆模质数后的值，这时候就用中国剩余定理。</p><p>Lucas定理：</p><p>适用于$n&lt;=10^{18},m&lt;=10^{18},p&lt;=10^5$且p为素数的情况。</p><p>复杂度为$O(log_p(n)*p)$，在这个数据范围下大概是是$10^7$的大小，所以是可以跑的。</p><p>中国剩余定理：</p><p>具体见这篇：<a href="http://pattle.xyz/2018/01/25/51nod-1079-中国剩余定理/" target="_blank" rel="noopener">http://pattle.xyz/2018/01/25/51nod-1079-中国剩余定理/</a></p><p>一个正整数K，给出K Mod 一些质数的结果，求符合条件的最小的K。</p><p>举个栗子，K%3=2，K%5=3，K%7=2。</p><p>a=2×5×7×inv(5×7,3) </p><p>b=3×3×7×inv(3×7,5) </p><p>c=2×3×5×inv(3×5,7)</p><p>答案就是a+b+c。</p><p>中国剩余定理这里有个地方会爆ll（见注释），所以要用到快速乘…之前没用到过，存个模板吧。</p><p>快速乘：</p><p>什么时候才用得到快速乘法呢，当两个数相乘可能超过ll范围的时候用。</p><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">PowerMulti</span><span class="hljs-params">(ll m,ll n,ll mod)</span></span><span class="hljs-function"></span>&#123;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(n)    &#123;        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)            ans+=m;        m=(m+m)%mod;        ans%=mod;        ans%=mod;        n&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll p[<span class="hljs-number">110</span>],m[<span class="hljs-number">110</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">extgcd</span><span class="hljs-params">(ll a,ll b,ll d,ll &amp;x,ll &amp;y)</span>   <span class="hljs-comment">//a,b都为正整数</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;d=a;x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;&#125;    <span class="hljs-keyword">else</span>&#123;extgcd(b,a%b,d,y,x);y=y-x*(a/b);&#125;&#125;<span class="hljs-function">ll <span class="hljs-title">inverse</span><span class="hljs-params">(ll a,ll p)</span></span><span class="hljs-function"></span>&#123;    ll d,x,y;    extgcd(a,p,d,x,y);    <span class="hljs-keyword">return</span> (x%p+p)%p;&#125;<span class="hljs-function">ll <span class="hljs-title">PowerMulti</span><span class="hljs-params">(ll m,ll n,ll mod)</span></span><span class="hljs-function"></span>&#123;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(n)    &#123;        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)            ans+=m;        m=(m+m)%mod;        ans%=mod;        ans%=mod;        n&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">PowerMod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k;    k=a;    k=k%c;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)            ans=(ans*k)%c;        b&gt;&gt;=<span class="hljs-number">1</span>;        k=(k*k)%c;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(m&gt;n)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a=(n+i-m)%p;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b=i%p;        ans=ans*(a*PowerMod(b,p<span class="hljs-number">-2</span>,p)%p)%p;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Lucas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        ll x,y;        <span class="hljs-keyword">int</span> n;        ll mul=<span class="hljs-number">1</span>;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%d"</span>,&amp;x,&amp;y,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;p[i]);            m[i]=Lucas(x,y,p[i]);            mul*=p[i];        &#125;        <span class="hljs-comment">//for(int i=0;i&lt;n;i++)</span>            <span class="hljs-comment">//printf("%lld\n",m[i]);</span>        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            ll temp=mul/p[i];            ll tp=(inverse(temp,p[i]))%mul;            temp=(temp*m[i])%mul;            ans=(ans+PowerMulti(temp,tp,mul))%mul;<span class="hljs-comment">//可能会爆ll，所以用快速乘</span>            <span class="hljs-comment">//ans=(ans+(temp*tp)%mul)%mul;</span>        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6535 倒着的ST表</title>
    <link href="/2018/08/07/HDU6535-%E5%80%92%E7%9D%80%E7%9A%84ST%E8%A1%A8/"/>
    <url>/2018/08/07/HDU6535-%E5%80%92%E7%9D%80%E7%9A%84ST%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n个数初始都为0，有m次操作，每次操作对于<script type="math/tex">[l,r]</script>，如果v大于区间的数，就把这个数变为v，即对区间的每个数取当前值和v的最大值。求这m次操作后的<script type="math/tex">⨁_{i=1}^n(i⋅a_i)</script>，<script type="math/tex">⨁</script>表示异或和，其中<script type="math/tex">1≤T≤100, 1≤n≤10^5, 1≤m≤5⋅10^6</script>。</p><p><strong>思路：</strong></p><p>因为是区间更新刚开始想到是线段树剪枝啊…然而比赛的时候写gg了…然而想想这复杂度也不可能过啊 是$O(3m+mlogn)$的啊？然而就是很多人是这么过的…这数据有点迷啊？</p><p>正解用的是倒着的ST表。</p><p>$d[i][j]$：$[i,i+2^j-1]$区间的最大值，即区间长度为$2^j$。</p><p>举个栗子，</p><p>首先对于一个区间<script type="math/tex">[5,9]</script>，可以分成两个区间<script type="math/tex">[5,8](d[5][2])</script>和<script type="math/tex">[6,9](d[6][2])</script>,给这两个区间打上要取最大值的标记。像这样进行m次操作。</p><p>然后对于每一个<script type="math/tex">d[i][j]</script>将标记下压，比如<script type="math/tex">d[6][3]([6,13])</script>下压给<script type="math/tex">d[6][2]([6,9])</script>和<script type="math/tex">d[10][2]([10,13])</script>，这样一直压下去，直到区间长度为<script type="math/tex">2^0</script>。</p><p>最后统计一下要求的东西就好了。</p><p>这样的复杂度为<script type="math/tex">O(m+nlogn)</script>。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uint;<span class="hljs-keyword">const</span> uint MOD=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>;ll tot;uint f[<span class="hljs-number">16000010</span>];ll d[<span class="hljs-number">100010</span>][<span class="hljs-number">20</span>];<span class="hljs-keyword">int</span> llog[<span class="hljs-number">100010</span>];<span class="hljs-function">uint <span class="hljs-title">fx</span><span class="hljs-params">(uint &amp;x,uint &amp;y,uint &amp;z)</span></span><span class="hljs-function"></span>&#123;    x=x^(x&lt;&lt;<span class="hljs-number">11</span>);    x=x^(x&gt;&gt;<span class="hljs-number">4</span>);    x=x^(x&lt;&lt;<span class="hljs-number">5</span>);    x=x^(x&gt;&gt;<span class="hljs-number">14</span>);    uint w=x^(y^z);    x=y;    y=z;    z=w;    <span class="hljs-keyword">return</span> z;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1e5</span>;i++)        llog[i]=(<span class="hljs-keyword">int</span>)log2(i);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m;    uint x,y,z;    init();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%u%u%u"</span>,&amp;n,&amp;m,&amp;x,&amp;y,&amp;z);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>*m;i++)            f[i]=fx(x,y,z);        <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        &#123;            <span class="hljs-keyword">int</span> l=<span class="hljs-built_in">min</span>(f[<span class="hljs-number">3</span>*i<span class="hljs-number">-2</span>]%n+<span class="hljs-number">1</span>,f[<span class="hljs-number">3</span>*i<span class="hljs-number">-1</span>]%n+<span class="hljs-number">1</span>);            <span class="hljs-keyword">int</span> r=<span class="hljs-built_in">max</span>(f[<span class="hljs-number">3</span>*i<span class="hljs-number">-2</span>]%n+<span class="hljs-number">1</span>,f[<span class="hljs-number">3</span>*i<span class="hljs-number">-1</span>]%n+<span class="hljs-number">1</span>);            ll v=f[<span class="hljs-number">3</span>*i]%MOD;            <span class="hljs-comment">//printf("%d %d %lld\n",l,r,v);</span>            <span class="hljs-keyword">int</span> temp=llog[r-l+<span class="hljs-number">1</span>];            <span class="hljs-comment">//printf("%d\n",temp);</span>            d[l][temp]=<span class="hljs-built_in">max</span>(d[l][temp],v);            d[r-(<span class="hljs-number">1</span>&lt;&lt;temp)+<span class="hljs-number">1</span>][temp]=<span class="hljs-built_in">max</span>(d[r-(<span class="hljs-number">1</span>&lt;&lt;temp)+<span class="hljs-number">1</span>][temp],v);            <span class="hljs-comment">//printf("(%d,%d)(%d,%d)\n",l,l+(1&lt;&lt;temp)-1,r-(1&lt;&lt;temp)+1,r);</span>        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=llog[n];i&gt;=<span class="hljs-number">1</span>;i--)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j+(<span class="hljs-number">1</span>&lt;&lt;i)<span class="hljs-number">-1</span>&lt;=n;j++)            &#123;                d[j][i<span class="hljs-number">-1</span>]=<span class="hljs-built_in">max</span>(d[j][i<span class="hljs-number">-1</span>],d[j][i]);                d[j+(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))][i<span class="hljs-number">-1</span>]=<span class="hljs-built_in">max</span>(d[j+(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))][i<span class="hljs-number">-1</span>],d[j][i]);                <span class="hljs-comment">//注意这里是j+1&lt;&lt;(i-1)，子区间是不重合的区间</span>            &#125;        &#125;        ll tot=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            tot^=d[i][<span class="hljs-number">0</span>]*i;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,tot);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上海大都会赛F 扫描线</title>
    <link href="/2018/08/06/%E4%B8%8A%E6%B5%B7%E5%A4%A7%E9%83%BD%E4%BC%9A%E8%B5%9BF-%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    <url>/2018/08/06/%E4%B8%8A%E6%B5%B7%E5%A4%A7%E9%83%BD%E4%BC%9A%E8%B5%9BF-%E6%89%AB%E6%8F%8F%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出<script type="math/tex">N*M</script>的区域，每个格子<script type="math/tex">(i,j)|(0≤i<N,0≤j<M)</script>最开始是白色的，现在有q次操作，每次操作对于给定的<script type="math/tex">(x_c,y_c)</script>和<script type="math/tex">r</script>，把满足<script type="math/tex">\sqrt{(i-x_c)^2+(j-y_c)^2}≤r</script>的格子涂成黑色。问在q次操作后区域中白色格子的个数。其中<script type="math/tex">1≤ N,M≤2*10^4,1≤q≤200</script>。</p><p><strong>思路：</strong></p><p>自己做的时候想到每个圆覆盖的整数点可以变成菱形，所以想到了矩形面积并，还觉得是不是要变换坐标系，整个都跑偏了…</p><p>其实考虑到数据范围很小，直接扫描线就可以了。</p><p>枚举<script type="math/tex">N</script>，遍历每个操作，可以求出这条扫描线与每个圆相交的区间，存入vector，再将这些区间按照左端点进行排序，然后问题就转化为这些区间覆盖的点的个数了，只要维护最右边的点R就可以了。</p><p>复杂度是<script type="math/tex">O(T*N*q)</script>，<script type="math/tex">10^8</script>似乎跑得蛮快啊？</p><p>写的时候仔细一点，注意我代码里注释的那个点。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> l,r;&#125;;<span class="hljs-built_in">vector</span>&lt;node&gt;v;<span class="hljs-keyword">int</span> r[<span class="hljs-number">210</span>][<span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x.l!=y.l)<span class="hljs-keyword">return</span> x.l&lt;y.l;    <span class="hljs-keyword">return</span> x.r&lt;y.r;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m,q;    node temp;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;q;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;r[i][<span class="hljs-number">0</span>],&amp;r[i][<span class="hljs-number">1</span>],&amp;r[i][<span class="hljs-number">2</span>]);        <span class="hljs-keyword">int</span> ans=n*m;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            v.<span class="hljs-built_in">clear</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;q;j++)            &#123;                <span class="hljs-keyword">int</span> lx=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,r[j][<span class="hljs-number">0</span>]-r[j][<span class="hljs-number">2</span>]),rx=<span class="hljs-built_in">min</span>(n<span class="hljs-number">-1</span>,r[j][<span class="hljs-number">0</span>]+r[j][<span class="hljs-number">2</span>]);                <span class="hljs-keyword">if</span>(i&lt;lx||i&gt;rx)<span class="hljs-keyword">continue</span>;                <span class="hljs-comment">//printf("(%d,%d)(%d,%d)\n",i,j,lx,rx);</span>                <span class="hljs-keyword">int</span> d=<span class="hljs-built_in">abs</span>(i-r[j][<span class="hljs-number">0</span>]);                <span class="hljs-comment">//printf("d:%d\n",d);</span>                <span class="hljs-keyword">int</span> dd=(<span class="hljs-keyword">int</span>)<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span>*r[j][<span class="hljs-number">2</span>]*r[j][<span class="hljs-number">2</span>]-d*d));                <span class="hljs-comment">//printf("dd:%d\n",dd);</span>                temp.l=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,r[j][<span class="hljs-number">1</span>]-dd);                temp.r=<span class="hljs-built_in">min</span>(m<span class="hljs-number">-1</span>,r[j][<span class="hljs-number">1</span>]+dd);                <span class="hljs-comment">//printf("%d %d\n",temp.l,temp.r);</span>                v.push_back(temp);            &#125;            <span class="hljs-keyword">int</span> len=v.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;            sort(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),cmp);            <span class="hljs-keyword">int</span> R=v[<span class="hljs-number">0</span>].r;            ans-=v[<span class="hljs-number">0</span>].r-v[<span class="hljs-number">0</span>].l+<span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;len;j++)            &#123;                <span class="hljs-keyword">if</span>(v[j].r&lt;=R)<span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>(v[j].l&lt;=R)ans-=v[j].r-R;                <span class="hljs-comment">//这里注意不用+1，因为之前已经算过R这个点了，因为这个WA了一发...</span>                <span class="hljs-keyword">else</span> ans-=v[j].r-v[j].l+<span class="hljs-number">1</span>;                R=v[j].r;            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上海大都会赛A 随机</title>
    <link href="/2018/08/05/%E4%B8%8A%E6%B5%B7%E5%A4%A7%E9%83%BD%E4%BC%9A%E8%B5%9BA-%E9%9A%8F%E6%9C%BA/"/>
    <url>/2018/08/05/%E4%B8%8A%E6%B5%B7%E5%A4%A7%E9%83%BD%E4%BC%9A%E8%B5%9BA-%E9%9A%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出N个点，求是否存在一条直线，至少经过N个点中的<script type="math/tex">\lceil N*x\rceil</script>个点。其中<script type="math/tex">1≤ T ≤ 100</script>，<script type="math/tex">1≤N≤10^4</script>，<script type="math/tex">0 < x < 1</script>且x为一位小数。</p><p><strong>思路：</strong></p><p>这道题是随机两个点形成一条直线，这条直线满足条件的概率为<script type="math/tex">x*x</script>，因为在满足条件的直线上的点至少有<script type="math/tex">\lceil N*x\rceil</script>个，所以某个点在这条直线上的概率为<script type="math/tex">\frac{\lceil N*x\rceil}{N}≈x</script>，两个点都在这条直线上的概率为<script type="math/tex">x*x</script>，<script type="math/tex">x*x</script>的极端情况为0.01，所以随机几百次就可以了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> x,y;&#125;p[<span class="hljs-number">10010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    srand(time(<span class="hljs-number">0</span>));    <span class="hljs-keyword">int</span> t,n;    <span class="hljs-keyword">double</span> k;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%lf"</span>,&amp;n,&amp;k);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;p[i].x,&amp;p[i].y);        <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)        &#123;            <span class="hljs-keyword">int</span> a=rand()%n,b=rand()%n;            <span class="hljs-keyword">if</span>(a==b)<span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)                <span class="hljs-keyword">if</span>((p[i].y-p[a].y)*(p[i].x-p[b].x)==(p[i].y-p[b].y)*(p[i].x-p[a].x))                cnt++;            <span class="hljs-keyword">if</span>(<span class="hljs-number">1.0</span>*cnt&gt;=n*k)            &#123;                sign++;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(sign!=<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Yes\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6331 flyod+dp+分块</title>
    <link href="/2018/08/04/HDU6331-flyod-dp-%E5%88%86%E5%9D%97/"/>
    <url>/2018/08/04/HDU6331-flyod-dp-%E5%88%86%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出n个点，m条有向边，有q次询问，问从s到t至少经过<script type="math/tex">k_i</script>条路的最短路为多少。其中<script type="math/tex">1≤T≤10,2≤n≤50,1≤q≤100000,1≤k_i≤10000</script>。</p><p><strong>思路：</strong></p><p>dp也可以分块啊 感觉开拓了我的思路啊(๑•̀ㅂ•́)و✧真有趣！</p><p>这里有两份比较好的题解：</p><p><a href="https://blog.csdn.net/weixin_42068627/article/details/81299321" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42068627/article/details/81299321</a></p><p><a href="https://blog.csdn.net/qq_34454069/article/details/81292814" target="_blank" rel="noopener">https://blog.csdn.net/qq_34454069/article/details/81292814</a></p><p>首先考虑最朴素的dp，<script type="math/tex">dp[k][i][j]</script>：从i到j<strong>至少</strong>走k条路的最短路。有转移：<script type="math/tex">dp[k][i][j]=min(dp[k-1][i][l]+d[l][j])|1≤l≤n且l≠j</script>，其中<script type="math/tex">d[i][j]</script>表示i到j的最短路。</p><p>复杂度是<script type="math/tex">O(T*k*n^3)</script>，结合数据范围，这有<script type="math/tex">10^{10}</script>。当然不可能是这么做的啦。</p><p>那么考虑倍增？</p><p><script type="math/tex">dp1[k][i][j]</script>：从i到j<strong>恰好</strong>走<script type="math/tex">2^k</script>条路的最短路。</p><p><script type="math/tex">dp2[k][i][j]</script>：从i到j<strong>至少</strong>走<script type="math/tex">2^k</script>条路的最短路。</p><p>有转移：</p><p><script type="math/tex">dp1[k][i][j]=min(dp1[k-1][i][l]+dp1[k-1][l][j])|1≤l≤n</script>。</p><p><script type="math/tex">dp2[k][i][j]=min(dp1[k-1][i][l]+d[k-1][l][j])|1≤l≤n</script>。</p><p>预处理的复杂度是<script type="math/tex">O(T*log_2k*n^3)</script>，结合数据范围，这是<script type="math/tex">10^7</script>，对于每次询问，枚举中转点i，<script type="math/tex">ans[k][i][j]=dp2[k的二进制形式中的1][i][l]+dp1[k-k的二进制中的1][l][j]</script>，而这里的也需要二进制中的1也要循环处理，处理询问的复杂度为<script type="math/tex">O(q*T*n*log_2k)</script>，结合数据范围，这是<script type="math/tex">7*10^8</script>，似乎也不太行啊？</p><p>所以考虑分块。</p><p>假设分成M块，<script type="math/tex">M=\sqrt k</script>。</p><p><script type="math/tex">dp[k][i][j]</script>：从i到j<strong>恰好</strong>走k条路的最短路<script type="math/tex">(k≤M)</script>。</p><p><script type="math/tex">dp1[k][i][j]</script>：从i到j<strong>至少</strong>走k条路的最短路<script type="math/tex">(k≤M)</script>。</p><p><script type="math/tex">dp2[k][i][j]</script>：从i到j<strong>恰好</strong>走M*k条路的最短路。</p><p>有转移：</p><p><script type="math/tex">dp[k][i][j]=min(dp[k-1][i][l]+w[l][j])|1≤l≤n且l≠j</script>。</p><p><script type="math/tex">dp1[k][i][j]=min(dp1[k-1][i][l]+d[l][j])|1≤l≤n且l≠j</script>。</p><p><script type="math/tex">dp2[k][i][j]=min(dp2[k-1][i][l]+dp[M][l][j])|1≤l≤n</script>。</p><p>预处理的复杂度是<script type="math/tex">O(T*M*n^3)</script>，结合数据范围，这是<script type="math/tex">10^8</script>，对于每个询问，枚举中转点l，<script type="math/tex">ans[k][i][j]=min(dp2[k/m][i][l]+dp1[k\%m][l][j])</script>，复杂度为<script type="math/tex">O(T*q*n)</script>，相比倍增，这个复杂度是可以接受的。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> g[<span class="hljs-number">55</span>][<span class="hljs-number">55</span>];<span class="hljs-keyword">int</span> d[<span class="hljs-number">55</span>][<span class="hljs-number">55</span>];<span class="hljs-keyword">int</span> dp[<span class="hljs-number">110</span>][<span class="hljs-number">55</span>][<span class="hljs-number">55</span>];<span class="hljs-comment">//从i到j恰好走k条路的最短路</span><span class="hljs-keyword">int</span> dp1[<span class="hljs-number">110</span>][<span class="hljs-number">55</span>][<span class="hljs-number">55</span>];<span class="hljs-comment">//从i到j至少走k条路的最短路</span><span class="hljs-keyword">int</span> dp2[<span class="hljs-number">110</span>][<span class="hljs-number">55</span>][<span class="hljs-number">55</span>];<span class="hljs-comment">//从i到j恰好走k*100条路的最短路</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m,x,y,z,q;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-built_in">memset</span>(g,INF,<span class="hljs-keyword">sizeof</span>(g));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            g[i][i]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(m--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);            g[x][y]=<span class="hljs-built_in">min</span>(g[x][y],z);        &#125;        <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            for(int j=1;j&lt;=n;j++)</span><span class="hljs-comment">                printf("%d ",g[i][j]);</span><span class="hljs-comment">            printf("\n");</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        printf("\n");*/</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)                d[i][j]=g[i][j];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)                    d[i][j]=<span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);        <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            for(int j=1;j&lt;=n;j++)</span><span class="hljs-comment">                printf("%d ",d[i][j]);</span><span class="hljs-comment">            printf("\n");</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        printf("\n");*/</span>        <span class="hljs-built_in">memset</span>(dp,INF,<span class="hljs-keyword">sizeof</span>(dp));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            dp[<span class="hljs-number">0</span>][i][i]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">100</span>;k++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;l++)                       <span class="hljs-keyword">if</span>(l!=j)dp[k][i][j]=<span class="hljs-built_in">min</span>(dp[k][i][j],dp[k<span class="hljs-number">-1</span>][i][l]+g[l][j]);        <span class="hljs-comment">/*for(int k=1;k&lt;=n;k++)</span><span class="hljs-comment">            for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">            for(int j=1;j&lt;=n;j++)</span><span class="hljs-comment">            printf("dp[%d][%d][%d]=%d\n",k,i,j,dp[k][i][j]);</span><span class="hljs-comment">        printf("\n");*/</span>        <span class="hljs-built_in">memset</span>(dp1,INF,<span class="hljs-keyword">sizeof</span>(dp1));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)               dp1[<span class="hljs-number">0</span>][i][j]=d[i][j];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">100</span>;k++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;l++)                        <span class="hljs-keyword">if</span>(l!=j)dp1[k][i][j]=<span class="hljs-built_in">min</span>(dp1[k][i][j],dp1[k<span class="hljs-number">-1</span>][i][l]+d[l][j]);        <span class="hljs-comment">/*for(int k=0;k&lt;=n;k++)</span><span class="hljs-comment">            for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">            for(int j=1;j&lt;=n;j++)</span><span class="hljs-comment">            printf("dp[%d][%d][%d]=%d\n",k,i,j,dp1[k][i][j]);</span><span class="hljs-comment">        printf("\n");*/</span>        <span class="hljs-built_in">memset</span>(dp2,INF,<span class="hljs-keyword">sizeof</span>(dp2));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            dp2[<span class="hljs-number">0</span>][i][i]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">100</span>;k++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;l++)                        dp2[k][i][j]=<span class="hljs-built_in">min</span>(dp2[k][i][j],dp2[k<span class="hljs-number">-1</span>][i][l]+dp[<span class="hljs-number">100</span>][l][j]);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);        <span class="hljs-keyword">while</span>(q--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);            <span class="hljs-keyword">int</span> p1=z/<span class="hljs-number">100</span>,p2=z%<span class="hljs-number">100</span>;            <span class="hljs-keyword">int</span> ans=INF;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;l++)                ans=<span class="hljs-built_in">min</span>(ans,dp2[p1][x][l]+dp1[p2][l][y]);            <span class="hljs-keyword">if</span>(ans==INF)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6321 状压DP</title>
    <link href="/2018/08/02/HDU6391-%E7%8A%B6%E5%8E%8BDP/"/>
    <url>/2018/08/02/HDU6391-%E7%8A%B6%E5%8E%8BDP/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>定义图的匹配是一组任意两边都没有公共顶点的边集，有n个点，现在有两种类型的操作m个：</p><p><script type="math/tex">+ u\ v</script>：在u和v之间加一条边，</p><p><script type="math/tex">- u\ v</script>：删去u和v之间的边，</p><p>问每次操作之后边集中有<script type="math/tex">1,2,3,···,\frac{n}{2}</script>条边的边集有几个。</p><p>其中<script type="math/tex">1≤T≤10,2≤n≤10,n\ mod\ 2=0,1≤m≤30000</script>。</p><p><strong>思路：</strong></p><p>由n的范围可以想到要状压，</p><p>考虑<script type="math/tex">dp[i][j]</script>：经过i次操作之后，j集合的点已经匹配的方案数。</p><p>比如j为0011的时候，只有两个点，边集只能有一条边，1111的时候，因为是匹配，表示边集有两条边。</p><p>加边的时候<script type="math/tex">dp[i][j]=dp[i-1][j]+dp[i-1][j-u-v]</script>，可以写成一维的，从大到小遍历j。</p><p>对于删边，因为之前加边的顺序对于删边是没有关系的，所以可以看作i-1的时候刚把这条边加上，所以将加边操作倒过来，即从小到大遍历j，<script type="math/tex">dp[i][j]=dp[i][j]-dp[j-u-v]</script>。</p><p>刚开始的时候连题解都看不懂啊…把标程dp中的前后状态输出来才懂啊…主要是对题目的这个匹配的没有很好地理解…</p><p>__builtin_popcount函数：返回一个数的二进制形式中有多少个1。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">char</span> a[<span class="hljs-number">5</span>];<span class="hljs-keyword">int</span> cnt[<span class="hljs-number">1200</span>];ll dp[<span class="hljs-number">1200</span>];ll ans[<span class="hljs-number">1200</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,x%<span class="hljs-number">2</span>);        x/=<span class="hljs-number">2</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,x,y,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>); i++)        cnt[i]=__builtin_popcount(i);    <span class="hljs-comment">/*for(int i=0;i&lt;(1&lt;&lt;4);i++)</span><span class="hljs-comment">        printf("%d\n",cnt[i]);*/</span>    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>&lt;&lt;n;        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(m--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%d%d"</span>,a,&amp;x,&amp;y);            x--;y--;            <span class="hljs-keyword">int</span> temp=<span class="hljs-number">1</span>&lt;&lt;x|<span class="hljs-number">1</span>&lt;&lt;y;            <span class="hljs-comment">//printf("temp:");trans(temp);</span>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==<span class="hljs-string">'+'</span>)            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=tot<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)                &#123;                    <span class="hljs-keyword">if</span>(!(temp&amp;i))<span class="hljs-comment">//i中没有u和v</span>                    &#123;                        <span class="hljs-comment">//printf("before:");trans(i);</span>                        dp[i|temp]=(dp[i|temp]+dp[i])%MOD;                        <span class="hljs-comment">//printf("after:");trans(i|temp);</span>                        <span class="hljs-comment">//printf("%lld-&gt;%lld\n",dp[i],dp[i|temp]);</span>                    &#125;                &#125;            &#125;            <span class="hljs-keyword">else</span>            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;i++)                &#123;                    <span class="hljs-keyword">if</span>(!(temp&amp;i))                        dp[i|temp]=(dp[i|temp]-dp[i]+MOD)%MOD;                &#125;            &#125;            <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ans));            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;i++)                ans[cnt[i]]=(ans[cnt[i]]+dp[i])%MOD;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>,ans[<span class="hljs-number">2</span>]);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">4</span>;i&lt;=n;i+=<span class="hljs-number">2</span>)                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %lld"</span>,ans[i]);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6336 规律+容斥</title>
    <link href="/2018/08/02/HDU6336-%E8%A7%84%E5%BE%8B-%E5%AE%B9%E6%96%A5/"/>
    <url>/2018/08/02/HDU6336-%E8%A7%84%E5%BE%8B-%E5%AE%B9%E6%96%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出长度为L的序列A，根据这个序列跑出一个矩阵，问左上角的点<script type="math/tex">(x_0,y_0)</script>和右下角的点<script type="math/tex">(x_1,y_1)</script>形成的矩阵的和。</p><p><strong>思路：</strong></p><p>打表可以打出规律，会发现有循环节。比赛的时候发现了，然而写法不好，就GG了。所以写之前一定要想出一个优雅一点的写法啊。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftvkx0aj7cj30ht0hx77e.jpg" srcset="/img/loading.gif" alt="点击放大"> </p><p>根据这张图可以看出，蓝色框子矩阵的和由那些小的矩阵组成，所以整张图中间的子矩阵可以用容斥原理表示成这些图的左上角的矩阵的运算之和。所以预处理一下二维前缀和。</p><p>这样子就好写多了。</p><p>注意打表的那一块多打一点，我直接找的具体的数字，似乎是不对的啊。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    ll x,y;&#125;l,r;ll len[<span class="hljs-number">15</span>]= &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>,<span class="hljs-number">16</span>,<span class="hljs-number">18</span>,<span class="hljs-number">20</span>&#125;;ll A[<span class="hljs-number">25</span>];ll g[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];ll pre[<span class="hljs-number">10101</span>][<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> L;<span class="hljs-function">ll <span class="hljs-title">cal</span><span class="hljs-params">(ll x,ll y)</span></span><span class="hljs-function"></span>&#123;    ll xx=(x+<span class="hljs-number">1</span>)/L,yy=(y+<span class="hljs-number">1</span>)/L;    ll tot=<span class="hljs-number">0</span>;    tot+=(xx*yy)*pre[L<span class="hljs-number">-1</span>][L<span class="hljs-number">-1</span>];    ll xm=(x+<span class="hljs-number">1</span>)%L,ym=(y+<span class="hljs-number">1</span>)%L;    <span class="hljs-keyword">if</span>(ym!=<span class="hljs-number">0</span>)tot+=xx*pre[L<span class="hljs-number">-1</span>][ym<span class="hljs-number">-1</span>];    <span class="hljs-keyword">if</span>(xm!=<span class="hljs-number">0</span>)tot+=yy*pre[xm<span class="hljs-number">-1</span>][L<span class="hljs-number">-1</span>];    <span class="hljs-keyword">if</span>(xm!=<span class="hljs-number">0</span>&amp;&amp;ym!=<span class="hljs-number">0</span>)tot+=pre[xm<span class="hljs-number">-1</span>][ym<span class="hljs-number">-1</span>];    <span class="hljs-keyword">return</span> tot;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("C:/Users/lenovo/Desktop/e.in","r",stdin);</span>    <span class="hljs-comment">//freopen("C:/Users/lenovo/Desktop/out.txt","w",stdout);</span>    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-keyword">int</span> n;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;A[i]);        L=len[n];        <span class="hljs-comment">//L=2ll*n;</span>        <span class="hljs-built_in">memset</span>(pre,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(pre));        <span class="hljs-keyword">int</span> <span class="hljs-built_in">cursor</span>=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; ++i)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;=i; ++j)            &#123;                g[j][i-j]=A[<span class="hljs-built_in">cursor</span>];                <span class="hljs-built_in">cursor</span>=(<span class="hljs-built_in">cursor</span>+<span class="hljs-number">1</span>)%n;            &#125;        &#125;        <span class="hljs-comment">/*for(int i=0;i&lt;L+1;i++)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            for(int j=0;j&lt;L+1;j++)</span><span class="hljs-comment">                printf("%3d",g[i][j]);</span><span class="hljs-comment">            printf("\n");</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        printf("\n");*/</span>        ll cur;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;L;i++)        &#123;            cur=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;L;j++)            &#123;                cur+=g[i][j];                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)pre[i][j]=cur;                <span class="hljs-keyword">else</span> pre[i][j]=cur+pre[i<span class="hljs-number">-1</span>][j];            &#125;        &#125;        <span class="hljs-comment">/*for(int i=0;i&lt;L+1;i++)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            for(int j=0;j&lt;L+1;j++)</span><span class="hljs-comment">                printf("%4d",pre[i][j]);</span><span class="hljs-comment">            printf("\n");</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        printf("\n");*/</span>        <span class="hljs-keyword">int</span> q;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);        <span class="hljs-keyword">while</span>(q--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld%lld"</span>,&amp;l.x,&amp;l.y,&amp;r.x,&amp;r.y);            <span class="hljs-comment">//printf("(%lld,%lld)(%lld,%lld)(%lld,%lld)(%lld,%lld)\n",r.x,r.y,l.x-1,l.y-1,l.x-1,r.y,r.x,l.y-1);</span>            <span class="hljs-comment">//printf("%lld %lld %lld %lld\n",cal(r.x,r.y),cal(l.x-1,l.y-1),cal(l.x-1,r.y),cal(r.x,l.y-1));</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,cal(r.x,r.y)+cal(l.x<span class="hljs-number">-1</span>,l.y<span class="hljs-number">-1</span>)-cal(l.x<span class="hljs-number">-1</span>,r.y)-cal(r.x,l.y<span class="hljs-number">-1</span>));        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6333 推导+莫队算法</title>
    <link href="/2018/08/01/HDU6333-%E6%8E%A8%E5%AF%BC-%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
    <url>/2018/08/01/HDU6333-%E6%8E%A8%E5%AF%BC-%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出n，m，求<script type="math/tex">C_n^1+C_n^2+···+C_n^m</script>，答案模<script type="math/tex">10^9+7</script>。</p><p>其中<script type="math/tex">1≤T≤10^5</script>，<script type="math/tex">1≤m≤n≤10^5</script>。</p><p><strong>思路：</strong></p><p>比赛的时候我是根据dp，想到这相当于是杨辉三角的前缀和，画出这个三角之后感觉是个莫队啊？然而觉得转移有点麻烦没细想而且队友打表打出的另一道题目有点东西就去转战其他题目了…赛后看题解感觉血亏啊？</p><p>m的转移相当于<script type="math/tex">S(n,m)=S(n,m-1)+C_n^m</script>，就是前缀和的递推。</p><p>n的转移相当于<script type="math/tex">S(n,m)=2*S(n-1,m)-C_{n-1}^m</script>（zz如我…很好推的我怎么还想了这么久？？？）。</p><p><script type="math/tex">S(n,m)=\sum_{i=0}^{m-1} C_{n-1}^k+\sum_{i=0}^{m} C_{n-1}^k=2*S(n-1,m)-C_{n-1}^m</script>。</p><p>然后莫队一下就可以了。</p><p>注意组合数的处理用线性求出阶乘的逆元的方法比较好。</p><p>交上去AC之后发现自己写的就是比别人跑得慢啊？以为自己写的程序自带常数了啊？？？其实是模得太多了啊？两个式子可以合并就尽量写一个 模能不用就不用 很慢的啊。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span></span><span class="hljs-function"></span>&#123;    x=<span class="hljs-number">0</span>;<span class="hljs-keyword">char</span> c=getchar();    <span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">'0'</span>||c&gt;<span class="hljs-string">'9'</span>)c=getchar();    <span class="hljs-keyword">while</span>(c&gt;=<span class="hljs-string">'0'</span>&amp;&amp;c&lt;=<span class="hljs-string">'9'</span>)    &#123;        x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">'0'</span>;        c=getchar();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ll x)</span></span>&#123;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">putchar</span>(<span class="hljs-number">48</span>);<span class="hljs-keyword">return</span>;&#125;    <span class="hljs-keyword">int</span> len=<span class="hljs-number">0</span>,dg[<span class="hljs-number">20</span>];    <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>)&#123;dg[++len]=x%<span class="hljs-number">10</span>;x/=<span class="hljs-number">10</span>;&#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len;i&gt;=<span class="hljs-number">1</span>;i--)<span class="hljs-built_in">putchar</span>(dg[i]+<span class="hljs-number">48</span>);&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qnode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> l,r,id;&#125;q[<span class="hljs-number">100010</span>];ll fac[<span class="hljs-number">100010</span>];ll inv[<span class="hljs-number">100010</span>];ll tot;ll ans[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> pos[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(qnode x,qnode y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos[x.l]!=pos[y.l])<span class="hljs-keyword">return</span> pos[x.l]&lt;pos[y.l];    <span class="hljs-keyword">return</span> x.r&lt;y.r;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">PowerMod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k;    k=a;    k=k%c;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)            ans=(ans*k)%c;        b&gt;&gt;=<span class="hljs-number">1</span>;        k=(k*k)%c;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=MAXN;i++)        fac[i]=fac[i<span class="hljs-number">-1</span>]*i%MOD;    inv[MAXN]=PowerMod(fac[MAXN],MOD<span class="hljs-number">-2</span>,MOD);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=MAXN<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)        inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%MOD;&#125;<span class="hljs-function">ll <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(n&lt;m)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> fac[n]*inv[m]%MOD*inv[n-m]%MOD;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m;    <span class="hljs-built_in">read</span>(m);    init();    <span class="hljs-keyword">int</span> block=<span class="hljs-built_in">sqrt</span>(MAXN);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-built_in">read</span>(q[i].l);<span class="hljs-built_in">read</span>(q[i].r);        q[i].id=i;        pos[i]=(i<span class="hljs-number">-1</span>)/block;    &#125;    sort(q+<span class="hljs-number">1</span>,q+<span class="hljs-number">1</span>+m,cmp);    <span class="hljs-keyword">int</span> L=<span class="hljs-number">0</span>,R=<span class="hljs-number">0</span>;    tot=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">while</span>(L&gt;q[i].l)        &#123;            L--;            tot=(tot+calc(L,R))*xs%MOD;        &#125;        <span class="hljs-keyword">while</span>(L&lt;q[i].l)        &#123;            tot=(tot*<span class="hljs-number">2</span>-calc(L,R)+MOD)%MOD;            L++;        &#125;        <span class="hljs-keyword">while</span>(R&lt;q[i].r)        &#123;            R++;            tot=(tot+calc(L,R))%MOD;        &#125;        <span class="hljs-keyword">while</span>(R&gt;q[i].r)        &#123;            tot=(tot-calc(L,R)+MOD)%MOD;            R--;        &#125;        ans[q[i].id]=tot;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-built_in">write</span>(ans[i]);        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'\n'</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU4565 &amp; HDU5451 推导+矩阵快速幂+广义斐波那契数列循环节</title>
    <link href="/2018/07/31/HDU4565-HDU5451-%E6%8E%A8%E5%AF%BC-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%B9%BF%E4%B9%89%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%BE%AA%E7%8E%AF%E8%8A%82/"/>
    <url>/2018/07/31/HDU4565-HDU5451-%E6%8E%A8%E5%AF%BC-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%B9%BF%E4%B9%89%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%BE%AA%E7%8E%AF%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h5 id="HDU4565"><a href="#HDU4565" class="headerlink" title="HDU4565"></a>HDU4565</h5><p><strong>题意：</strong></p><p>给出a，b，n，m，求<script type="math/tex">S_n=\lceil(a+\sqrt b)^n\rceil\%m</script>。其中<script type="math/tex">0<a,m<2^{15}</script>，<script type="math/tex">(a-1)^2<b <a^2</script>，<script type="math/tex">0<b,n<2^{31}</script>。</p><p><strong>思路：</strong></p><p>首先根据构造共轭因式的思想，构造下式：</p><script type="math/tex; mode=display">(a+\sqrt b)^n=A+B\sqrt b</script><script type="math/tex; mode=display">(a-\sqrt b)^n=A-B\sqrt b</script><p>注意一个条件，<script type="math/tex">(a-1)^2<b <a^2</script>，则<script type="math/tex">a-1<\sqrt b<a</script>，则<script type="math/tex">0<a-\sqrt b<1</script>，则有<script type="math/tex">0<(a-\sqrt b)^n=A-B\sqrt b<1</script>,</p><p>则<script type="math/tex">A -1<B\sqrt b<A​</script>，</p><p>因为<script type="math/tex">S_n=\lceil(a+\sqrt b)^n\rceil\%m=\lceil(A+B\sqrt b)\rceil\%m=2*A</script>。</p><p>①和②相加得<script type="math/tex">(a+\sqrt b)^n+(a-\sqrt b)^n=2*A</script>。</p><p>所以<script type="math/tex">S_n=(a+\sqrt b)^n+(a-\sqrt b)^n</script>。</p><p>对于<script type="math/tex">S_n</script>的递推公式，可以有多种方法推导得到，这里说其中两种。</p><p>法一：二阶线性递推式</p><p>定理：对于由递推公式<script type="math/tex">a_{n+2}=pa_{n+1}+qa_n</script>，<script type="math/tex">a_1=\alpha,a_2=\beta</script>给出的数列<script type="math/tex">\left\{a_n\right\}</script>，方程<script type="math/tex">x^2-px-q=0</script>，叫做数列<script type="math/tex">\left\{a_n\right\}</script>的特征方程。</p><p>这里<script type="math/tex">(a+\sqrt b)^n</script>和<script type="math/tex">(a-\sqrt b)^n</script>是特征方程的两个根，可以由韦达定理推出特征方程为<script type="math/tex">x^2-2ax+a^2-b=0</script>，所以有递推公式<script type="math/tex">S_{n+2}=2a*S_{n+1}+(b-a^2)*S_n</script>。</p><p>法二：递推</p><script type="math/tex; mode=display">\ \ \ \ S_n*[(a+\sqrt b)+(a-\sqrt b)]\\=[(a+\sqrt b)^n+(a-\sqrt b)^n][(a+\sqrt b)+(a-\sqrt b)]\\=(a+\sqrt b)^{n+1}+(a-\sqrt b)^{n+1}+(a^2-b)(a+\sqrt b)^{n-1}+(a^2-b)(a-\sqrt b)^{n-1}\\=S_{n+1}+(a^2-b)*S_{n-1}</script><p>所以<script type="math/tex">S_{n+1}=2a*S_n+(b-a^2)*S_{n-1}</script>。</p><p>这样就可以构造矩阵了，</p><script type="math/tex; mode=display">\left(     \begin{matrix}           f_n \\            f_{n-1} \\        \end{matrix}\right)        =\left(    \begin{matrix}        2a & b-a^2\\        1 & 0\\    \end{matrix}\right)=\left(     \begin{matrix}            f_{n-1} \\            f_{n-2} \\        \end{matrix}\right)</script><script type="math/tex; mode=display">\left(     \begin{matrix}           f_n \\            f_{n-1} \\        \end{matrix}\right)        =\left(    \begin{matrix}        2a & b-a^2\\        1 & 0\\    \end{matrix}\right)^{n-1}=\left(     \begin{matrix}            f_1 \\            f_2 \\        \end{matrix}\right)</script><p>再用矩阵快速幂做就可以了。</p><p>这里要注意，<script type="math/tex">b-a^2</script>可能是负的，所以在矩阵乘法中取模的时候要加上模数再取模。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];&#125;m,r;ll p;<span class="hljs-function">mat <span class="hljs-title">mult</span><span class="hljs-params">(mat x,mat y)</span></span><span class="hljs-function"></span>&#123;    mat res=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;k++)                res.a[i][j]=(res.a[i][j]+(x.a[i][k]*y.a[k][j])%p+p)%p;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">mat <span class="hljs-title">PowerMod</span><span class="hljs-params">(mat x,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span></span><span class="hljs-function"></span>&#123;    mat ans=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)        ans.a[i][i]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)            ans=mult(ans,x);        x=mult(x,x);        n=n/<span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ll x,y,n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;n,&amp;p)!=EOF)    &#123;        m.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>*x;m.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=y-x*x;        m.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;m.a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;        r=PowerMod(m,n<span class="hljs-number">-1</span>);        ll ans=(r.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]*<span class="hljs-number">2</span>*x+r.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>)%p;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="HDU5451"><a href="#HDU5451" class="headerlink" title="HDU5451"></a>HDU5451</h5><p><strong>题意：</strong></p><p>给出x和一个质数M，<script type="math/tex">y=(5+2\sqrt 6)^{1+2^x}</script>，求<script type="math/tex">\lfloor y\rfloor\%m</script>。其中<script type="math/tex">0≤x≤2^{32}</script>，<script type="math/tex">M≤46337</script>。</p><p><strong>思路：</strong></p><p>类似上题的方法，根据特征方程可以求出递推公式为<script type="math/tex">f_n=10*f_{n-1}-f_{n-2}</script>。</p><p>已知数列<script type="math/tex">\left\{a_n\right\}​</script>满足<script type="math/tex">a_{n+2}=c_1*a_{n+1}+c_2*a_n​</script>，其中<script type="math/tex">c_1​</script>，<script type="math/tex">c_2​</script>为常数，且<script type="math/tex">c_2≠0​</script>，<script type="math/tex">n∈N^*​</script>。</p><p>定理1：方程<script type="math/tex">x^2=c_1x+c_2</script>为该式的特征的特征方程，该方程的根称为<script type="math/tex">\left\{a_n\right\}</script>的特征根，记为<script type="math/tex">\lambda_1</script>，<script type="math/tex">\lambda_2</script>。</p><p>定理2:若<script type="math/tex">\lambda_1≠\lambda_2</script>，则<script type="math/tex">a_n=b_1{\lambda_1}^n+b_2{\lambda_2}^n</script>，其中<script type="math/tex">b_1</script>，<script type="math/tex">b_2</script>为常数，且满足</p><script type="math/tex; mode=display">\left\{ \begin{array}{c}    a_1=b_1\lambda_1+b_2\lambda_2 \\     a_2=b_1{\lambda_1}^2+{b_2\lambda_2}^2  \\ \end{array}\right.</script><p>定理3:若<script type="math/tex">\lambda_1=\lambda_2=\lambda</script>，则<script type="math/tex">a_n=(b_1+b_2n)\lambda^n</script>，其中<script type="math/tex">b_1</script>，<script type="math/tex">b_2</script>为常数，且满足</p><script type="math/tex; mode=display">\left\{ \begin{array}{c}    a_1=(b_1+b_2)\lambda \\     a_2=(b_1+2b_2)\lambda  \\ \end{array}\right.</script><p>由定理2，得到通项<script type="math/tex">f_n=(5+2\sqrt 6)^n+(5-2\sqrt 6)^n</script>。</p><p>因为<script type="math/tex">(5+2\sqrt6)^n>1</script>，<script type="math/tex">(5-2\sqrt6)^n<1</script>，因<script type="math/tex">(5+2\sqrt 6)^n</script>的整数部分为<script type="math/tex">f_n-1</script>。</p><p>指数是<script type="math/tex">2^x+1</script>非常大，但模数<script type="math/tex">M≤46337</script>，所以可以直接暴力找循环节。</p><p>还有一个结论，对于广义斐波那契数列<script type="math/tex">f(n)=af(n−1)+bf(n−2),f(1)=c,f(2)=d</script>，</p><p>f(n)%p循环节：当c是模p的二次剩余，枚举<script type="math/tex">n=(p-1)</script>的因子，  　　　　　　　当c是模p的非二次剩余，枚举<script type="math/tex">n=(p-1)(p+1)</script>的因子。</p><p>什么叫二次剩余呢？</p><p>d是模p的二次剩余当且仅当<script type="math/tex">d(p−1)/2≡1(mod\ p)</script>，</p><p>d是模p的非二次剩余当且仅当<script type="math/tex">d(p−1)/2≡-1(mod\ p)</script>。</p><p>假设MOD为模数,则在<script type="math/tex">f[2]!=MOD</script>时,<script type="math/tex">(MOD+1)*(MOD-1)</script>一定为其一个循环节。 </p><p>在这里循环节可以直接算出，循环节为<script type="math/tex">(m+1)*(m-1)</script>。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll f[<span class="hljs-number">100010</span>];ll l[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">init</span><span class="hljs-params">(ll m)</span></span><span class="hljs-function"></span>&#123;    f[<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>%m,f[<span class="hljs-number">1</span>]=<span class="hljs-number">10</span>%m;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;;i++)    &#123;        f[i]=(<span class="hljs-number">10</span>*f[i<span class="hljs-number">-1</span>]-f[i<span class="hljs-number">-2</span>]+m)%m;        <span class="hljs-comment">//if(i&lt;=10)printf("%lld ",f[i]);</span>        <span class="hljs-keyword">if</span>(f[i<span class="hljs-number">-1</span>]==f[<span class="hljs-number">0</span>]&amp;&amp;f[i]==f[<span class="hljs-number">1</span>])            <span class="hljs-keyword">return</span> i<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-comment">//printf("\n");</span>&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">PowerMod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k;    k=a;    k=k%c;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)        ans=(ans*k)%c;        b&gt;&gt;=<span class="hljs-number">1</span>;        k=(k*k)%c;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        ll x,m;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;x,&amp;m);        <span class="hljs-keyword">int</span> len=init(m);        <span class="hljs-comment">//printf("%d\n",len);</span>        <span class="hljs-keyword">int</span> p=PowerMod(<span class="hljs-number">2</span>,x,len);        <span class="hljs-comment">//printf("p:%d\n",p);</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case #%d: %lld\n"</span>,kase,(f[(p+<span class="hljs-number">1</span>)%len]<span class="hljs-number">-1</span>+m)%m);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6219 思维+单调队列</title>
    <link href="/2018/07/30/HDU6219-%E6%80%9D%E7%BB%B4-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2018/07/30/HDU6219-%E6%80%9D%E7%BB%B4-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出一个序列，从左往右每次选择一个长度为m的区间，对于每个区间，找出它的最大值max和从左往右扫描该区间时最大值的变化次数cnt。</p><p><strong>思路：</strong></p><p>max用单调队列维护是常规操作。但是cnt要怎么在O(n)的复杂度内统计呢？</p><p>倒着单调队列就可以了。</p><p>比如样例3 2 2 1 5 7 6 8 2 9，先把(9,9)放入队尾，因为2比9小，继续吧(2,8)放入队尾，(8,7)比(2,8)更优，这时候应该把(2,8)弹掉，因为要求的是最大值变化的次数，所以最大值能改变的时候一定要改变，所以8比2大，而且8在2的前面，肯定是最优的，这样子下去，每个区间的最大值的变化次数就是单调队列的元素个数。</p><p>这里用deque来写会TLE 所以还是手写个双端队列吧。</p><p>这样想想的确是很有道理，但是做题的时候怎么就想不到呢QAQ这问题到底是出在哪里呢QAQ难受啊QAQ</p><p>以后碰到题目不仅正着想想 倒着也想想吧。</p><p>update：还是思考了一下 倒着做是有道理的 因为常规的单调队列是越后面的越优 而这道题目是越前面的越优 只要数字变大了 就一定要选 这就是越前面越优 所以要倒着做。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> id;    ll val;&#125;;ll a[<span class="hljs-number">10000010</span>];node qq[<span class="hljs-number">10000010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m,k;    ll p,q,r,MOD;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%lld%lld%lld%lld"</span>,&amp;n,&amp;m,&amp;k,&amp;p,&amp;q,&amp;r,&amp;MOD);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k+<span class="hljs-number">1</span>;i&lt;=n;i++)            a[i]=((p*a[i<span class="hljs-number">-1</span>])%MOD+(q*i)%MOD+r)%MOD;        <span class="hljs-comment">//for(int i=1;i&lt;=n;i++)</span>            <span class="hljs-comment">//printf("%lld ",a[i]);</span>        <span class="hljs-comment">//printf("\n");</span>        <span class="hljs-comment">//deque&lt;node&gt;q;</span>        <span class="hljs-keyword">int</span> Front=<span class="hljs-number">0</span>,Back=<span class="hljs-number">0</span>;        ll ans1=<span class="hljs-number">0</span>,ans2=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)        &#123;            node temp;            temp.id=i;temp.val=a[i];            <span class="hljs-keyword">while</span>(Front!=Back&amp;&amp;a[i]&gt;=qq[Back].val)                Back--;            <span class="hljs-comment">//while(!q.empty()&amp;&amp;a[i]&gt;=q.back().val)</span>                <span class="hljs-comment">//q.pop_back();</span>            qq[++Back]=temp;            <span class="hljs-comment">//q.push_back(temp);</span>            <span class="hljs-comment">//while(!q.empty()&amp;&amp;q.front().id&gt;i+m-1)</span>                    <span class="hljs-comment">//q.pop_front();</span>            <span class="hljs-keyword">while</span>(Front!=Back&amp;&amp;qq[Front+<span class="hljs-number">1</span>].id&gt;i+m<span class="hljs-number">-1</span>)                Front++;            <span class="hljs-keyword">if</span>(i&lt;=n-m+<span class="hljs-number">1</span>)            &#123;                <span class="hljs-comment">//printf("%d:%d ",i,q.front().val);</span>                <span class="hljs-comment">//printf("%d\n",q.size());</span>                <span class="hljs-comment">//ans2+=q.size()^i;</span>                ans2+=(Back-Front)^i;                <span class="hljs-comment">//ans1+=q.front().val^i;</span>                ans1+=qq[Front+<span class="hljs-number">1</span>].val^i;            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld %lld\n"</span>,ans1,ans2);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2017UrumqiA 贪心+概率DP</title>
    <link href="/2018/07/30/ACM-ICPC-2017-Asia-UrumqiA-%E6%A6%82%E7%8E%87DP/"/>
    <url>/2018/07/30/ACM-ICPC-2017-Asia-UrumqiA-%E6%A6%82%E7%8E%87DP/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n个反面朝上的硬币，每次可以选a个硬币扔，要扔m次，目的是尽可能得让正面朝上的硬币多。问硬币正面朝上的期望为多少。</p><p><strong>思路：</strong></p><p>题目又看错了…主要是样例手算不出来…就以为本来的理解是对的…</p><p>事实上它是有贪心在里面的，因为尽可能要让正面朝上的硬币多，所以每次尽可能扔反面朝上的硬币，如果反面朝上的硬币不足a个的话，把反面朝上的硬币全选了以外正面朝上的硬币也选几个。</p><p>这里就可以dp了。</p><p><script type="math/tex">dp[i][j]:扔了i次有j个硬币正面朝上的概率</script>。</p><p>对于某个状态<script type="math/tex">(i,j)</script>，再扔一次a个硬币中有l个硬币正面朝上的概率为<script type="math/tex">C_{a}^l* \frac{1}{2^a}</script>。</p><p>当反面朝上的硬币大于等于a个的话，有转移<script type="math/tex">dp[i+1][j+k]+=dp[i][j]+C_{a}^l* \frac{1}{2^a}</script>，其中<script type="math/tex">0≤k≤a</script>，表示这次扔正面朝上的硬币数。</p><p>当反面朝上的硬币小于a个的话，有转移<script type="math/tex">dp[i+1][j-(a-(n-j))+k]+=dp[i][j]+C_{a}^l* \frac{1}{2^a}</script>，其中<script type="math/tex">0≤k≤a</script>。</p><p>边界条件为<script type="math/tex">dp[0][0]=1</script>。</p><p>再算一下期望就可以了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">double</span> dp[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<span class="hljs-comment">//扔i次有j面朝上的概率</span><span class="hljs-keyword">double</span> c[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>],xs[<span class="hljs-number">110</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)<span class="hljs-comment">//j是上面，i是下面</span>    &#123;        c[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)        &#123;            c[i][j]=c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];        &#125;    &#125;    xs[<span class="hljs-number">1</span>]=<span class="hljs-number">0.5</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">100</span>;i++)        xs[i]=<span class="hljs-number">0.5</span>*xs[i<span class="hljs-number">-1</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,m,a;    init();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;a);<span class="hljs-comment">//n个硬币扔m次每次扔a个</span>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;=a;k++)<span class="hljs-comment">//有k枚硬币向上</span>                &#123;                    <span class="hljs-keyword">if</span>(n-j&gt;=a)dp[i+<span class="hljs-number">1</span>][j+k]+=dp[i][j]*c[a][k]*xs[a];                    <span class="hljs-keyword">else</span> dp[i+<span class="hljs-number">1</span>][j-(a-n+j)+k]+=dp[i][j]*c[a][k]*xs[a];                &#125;            &#125;        &#125;        <span class="hljs-comment">/*for(int i=1;i&lt;=m;i++)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            for(int j=0;j&lt;=n;j++)</span><span class="hljs-comment">                printf("%.3f ",dp[i][j]);</span><span class="hljs-comment">            printf("\n");</span><span class="hljs-comment">        &#125;*/</span>        <span class="hljs-keyword">double</span> ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)            ans+=dp[m][i]*i;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.3f\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>徐州邀请赛G 分块思想+前缀积后缀积</title>
    <link href="/2018/07/28/%E5%BE%90%E5%B7%9E%E9%82%80%E8%AF%B7%E8%B5%9BG-%E5%88%86%E5%9D%97%E6%80%9D%E6%83%B3-%E5%89%8D%E7%BC%80%E7%A7%AF%E5%90%8E%E7%BC%80%E7%A7%AF/"/>
    <url>/2018/07/28/%E5%BE%90%E5%B7%9E%E9%82%80%E8%AF%B7%E8%B5%9BG-%E5%88%86%E5%9D%97%E6%80%9D%E6%83%B3-%E5%89%8D%E7%BC%80%E7%A7%AF%E5%90%8E%E7%BC%80%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有一个长度为m的窗口，一个长度为n的序列，现在将这个窗口在序列上滑动，问每次滑动这个窗口内数的乘积模p的总和为多少。</p><p><strong>思路：</strong></p><p>可以将序列分成长度为m的若干块，每次滑动窗口的乘积可以用前一块的后缀积与后一块的前缀积拼起来得到。所以预处理出每个数在自己的块内的前缀积和后缀积即可。</p><p>挺巧妙的。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll a[<span class="hljs-number">1000010</span>];ll pre[<span class="hljs-number">1000010</span>];ll suf[<span class="hljs-number">1000010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m;    ll p,x,y,z;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%lld"</span>,&amp;n,&amp;m,&amp;p)!=EOF)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld%lld"</span>,&amp;a[<span class="hljs-number">0</span>],&amp;x,&amp;y,&amp;z);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)            a[i]=((((x*a[i<span class="hljs-number">-1</span>])%p*a[i<span class="hljs-number">-1</span>])%p+(y*a[i<span class="hljs-number">-1</span>])%p)%p+z)%p;        <span class="hljs-comment">/*for(int i=0;i&lt;n;i++)</span><span class="hljs-comment">            scanf("%lld",&amp;a[i]);*/</span>        <span class="hljs-comment">/*for(int i=0;i&lt;n;i++)</span><span class="hljs-comment">            printf("%lld ",a[i]);</span><span class="hljs-comment">        printf("\n");*/</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-keyword">if</span>(i%m==<span class="hljs-number">0</span>)pre[i]=a[i]%p;            <span class="hljs-keyword">else</span> pre[i]=(pre[i<span class="hljs-number">-1</span>]*a[i])%p;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)        &#123;            <span class="hljs-keyword">if</span>(i%m==m<span class="hljs-number">-1</span>||i==n<span class="hljs-number">-1</span>)suf[i]=a[i]%p;            <span class="hljs-keyword">else</span> suf[i]=(suf[i+<span class="hljs-number">1</span>]*a[i])%p;        &#125;        <span class="hljs-comment">/*for(int i=0;i&lt;n;i++)</span><span class="hljs-comment">            printf("%lld ",pre[i]);</span><span class="hljs-comment">        printf("\n");</span><span class="hljs-comment">        for(int i=0;i&lt;n;i++)</span><span class="hljs-comment">            printf("%lld ",suf[i]);</span><span class="hljs-comment">        printf("\n");*/</span>        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n-m;i++)        &#123;            ll temp=<span class="hljs-number">1</span>;            temp=(temp*suf[i])%p;            <span class="hljs-keyword">if</span>(i%m!=<span class="hljs-number">0</span>)temp=(temp*pre[i+m<span class="hljs-number">-1</span>])%p;            <span class="hljs-comment">//printf("%lld ",temp);</span>            ans+=temp;        &#125;        <span class="hljs-comment">//printf("\n");</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>徐州邀请赛F 树状数组+dfs序思想</title>
    <link href="/2018/07/28/%E5%BE%90%E5%B7%9E%E9%82%80%E8%AF%B7%E8%B5%9BF-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-dfs%E5%BA%8F%E6%80%9D%E6%83%B3/"/>
    <url>/2018/07/28/%E5%BE%90%E5%B7%9E%E9%82%80%E8%AF%B7%E8%B5%9BF-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-dfs%E5%BA%8F%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出一片森林，问能找到多少个三元组(x,y,z)满足f[y]&gt;f[x]和f[z]&gt;f[x]，并且x是y的祖先，y是z的祖先。</p><p><strong>思路：</strong></p><p>对于每个点作为y，答案为y的祖先中f比它小的乘以y的子树中f比它小的。y的子树中f比它小的，之前上一篇博文中用dfs序解决了这个问题，但是这里考虑到这里比较的不是编号而是f，所以像那个做法比较麻烦，所以可以考虑另一种做法，对于一个点，进入它的时候查询当前比它小的结点数（用树状数组维护权值），从它出来的时候查询当前比它小的结点数，两者相减就是子树中比它小的结点数。</p><p>y的祖先中f比它小的，可以在进入的时候查询当前比它小的结点，出来的时候也要把它从树状数组里删除，这样可以保证每次查询的时候只有祖先。</p><p>所以这样每棵树只要搜一次，最后把答案相加即可。</p><p>这道题目卡内存，所以为了省内存，因为这是一棵树，而且肯定是从根结点搜下来的，所以可以只保存从父节点到子结点的那条边，vis数组也可以省略。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">1000010</span>];<span class="hljs-keyword">int</span> fa[<span class="hljs-number">1000010</span>];<span class="hljs-keyword">int</span> w[<span class="hljs-number">1000010</span>];<span class="hljs-keyword">int</span> d1[<span class="hljs-number">1000010</span>],d2[<span class="hljs-number">1000010</span>];ll tot;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        res+=a[x];        x-=lowbit(x);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(x&lt;=<span class="hljs-number">1000000</span>)    &#123;        a[x]+=v;        x+=lowbit(x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> par)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> in=query(d1,w[id]<span class="hljs-number">-1</span>);    add(d1,w[id],<span class="hljs-number">1</span>);    add(d2,w[id],<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">if</span>(v[id][i]!=par)            dfs(v[id][i],id);    &#125;    add(d2,w[id],<span class="hljs-number">-1</span>);    tot+=(ll)(query(d1,w[id]<span class="hljs-number">-1</span>)-in)*query(d2,w[id]<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            v[i].<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;fa[i]);            <span class="hljs-keyword">if</span>(fa[i]!=<span class="hljs-number">0</span>)            &#123;                <span class="hljs-comment">//v[i].push_back(fa[i]);</span>                v[fa[i]].push_back(i);            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;w[i]);        tot=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(d1,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d1));        <span class="hljs-built_in">memset</span>(d2,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d2));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">if</span>(fa[i]==<span class="hljs-number">0</span>)                dfs(i,i);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,tot);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU3887 dfs序+树状数组</title>
    <link href="/2018/07/27/HDU3887-dfs%E5%BA%8F-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2018/07/27/HDU3887-dfs%E5%BA%8F-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有一棵n个结点的树，结点编号分别为1～n，询问对于每个结点，它的子结点中有多少结点的编号比它小。</p><p><strong>思路：</strong></p><p>这里用到了dfs序。</p><p>dfs序的介绍见这里：<a href="https://www.bilibili.com/video/av4482146?from=search&amp;seid=7981889138645681255。" target="_blank" rel="noopener">https://www.bilibili.com/video/av4482146?from=search&amp;seid=7981889138645681255。</a></p><p>dfs序有一个可以利用的性质是每一棵子树在序列里都是连续的，所以可以对每个结点给两个时间戳，一个是遍历到该点时的时间戳，另一个是从该点出去的时间戳。</p><p>比如样例如图，</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1ftovfno753j30du0a8t9l.jpg" srcset="/img/loading.gif" alt="未命名"></p><p>可以得到一个dfs序为7 10 14 2 13 1 9 11 6 5 8 3 15 12 4，</p><p>1～15的时间戳分别为(6,6)(4,4)(12,14)(15,15)(10,10)(9,11)(1,15)(11,11)(7,11)(2,5)(8,8)(14,14)(5,5)(3,5)(13,13)。</p><p>时间戳区间内的结点都为该结点的子结点。</p><p>因为要求的是子树中编号比它小的结点数，所以从1～n遍历，类似于逆序数的做法，查询时间戳区间内的区间和得到的就是子树中编号比它小的结点个数，之后再将入时间戳的位置置为1。</p><p>vector不清空也会OLE啊…</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">100010</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> cnt;<span class="hljs-keyword">int</span> intime[<span class="hljs-number">100010</span>];<span class="hljs-comment">//入时间戳</span><span class="hljs-keyword">int</span> outime[<span class="hljs-number">100010</span>];<span class="hljs-comment">//出时间戳</span><span class="hljs-keyword">int</span> ans[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> d[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    vis[id]=<span class="hljs-literal">true</span>;    intime[id]=++cnt;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">if</span>(!vis[v[id][i]])            dfs(v[id][i]);    &#125;    outime[id]=cnt;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        res+=d[x];        x-=lowbit(x);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(x&lt;=cnt)    &#123;        d[x]+=v;        x+=lowbit(x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,p,x,y;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;p)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>&amp;&amp;p==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            v[i].<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);            v[x].push_back(y);            v[y].push_back(x);        &#125;        cnt=<span class="hljs-number">0</span>;        dfs(p);        <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            ans[i]=query(outime[i])-query(intime[i]<span class="hljs-number">-1</span>);            add(intime[i],<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"(%d,%d)"</span>,intime[i],outime[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,ans[i]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans[n]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宁夏邀请赛F floyd中dp的思想</title>
    <link href="/2018/07/27/%E5%AE%81%E5%A4%8F%E9%82%80%E8%AF%B7%E8%B5%9BF-floyd%E4%B8%ADdp%E7%9A%84%E6%80%9D%E6%83%B3/"/>
    <url>/2018/07/27/%E5%AE%81%E5%A4%8F%E9%82%80%E8%AF%B7%E8%B5%9BF-floyd%E4%B8%ADdp%E7%9A%84%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n个城市，每个城市有一个被抢劫的风险值，现在有q次询问，问u到v在不经过风险值大于w的条件下的最短路长度。其中<script type="math/tex">1≤n≤200</script>，<script type="math/tex">1≤q≤2×10^4</script>，<script type="math/tex">1≤w≤10^5</script>。</p><p><strong>思路：</strong></p><p>不经过某些城市就相当于不用某些城市松弛，这可以想到floyd，最外层是松弛的城市，所以容易想到要将城市的风险值进行从小到大排序，即从小到大进行松弛，再把每次松弛的结果保存下来，相当于三维dp表示经过前i个城市进行松弛j到k的最短路，这样预处理出来。</p><p>所以之后询问的时候遍历每个风险值，最后一个小于等于询问的风险值的就可以输出。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> w;    <span class="hljs-keyword">int</span> id;&#125;a[<span class="hljs-number">210</span>];<span class="hljs-keyword">int</span> dp[<span class="hljs-number">210</span>][<span class="hljs-number">210</span>][<span class="hljs-number">210</span>];<span class="hljs-comment">//通过前i个点松弛所得的最短路</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x.w&lt;y.w;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,q,x,y,z;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;q);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i].w);            a[i].id=i;        &#125;        sort(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+n,cmp);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;dp[i][j][<span class="hljs-number">0</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)                    dp[j][k][i]=<span class="hljs-built_in">min</span>(dp[j][k][i<span class="hljs-number">-1</span>],dp[j][a[i].id][i<span class="hljs-number">-1</span>]+dp[a[i].id][k][i<span class="hljs-number">-1</span>]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case #%d:\n"</span>,kase);        <span class="hljs-keyword">while</span>(q--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);            <span class="hljs-keyword">if</span>(a[n].w&lt;=z)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[x][y][n]);<span class="hljs-keyword">continue</span>;&#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)                <span class="hljs-keyword">if</span>(a[i].w&gt;z)                &#123;                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[x][y][i<span class="hljs-number">-1</span>]);                    <span class="hljs-keyword">break</span>;                &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>徐州邀请赛K 思维+最短路</title>
    <link href="/2018/07/27/%E5%BE%90%E5%B7%9E%E9%82%80%E8%AF%B7%E8%B5%9BK-%E6%80%9D%E7%BB%B4-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2018/07/27/%E5%BE%90%E5%B7%9E%E9%82%80%E8%AF%B7%E8%B5%9BK-%E6%80%9D%E7%BB%B4-%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有0~n-1这几个城市是连通的，每个城市之间连接着一些道路，问有几种删除边（有可能不删除）的方案，使得这些城市还是连通的，剩下的边最少（即生成树，剩下n-1条边），对于每个城市，它们到0的最短路不变。</p><p><strong>思路：</strong></p><p>因为只能有n-1条边，所以对于每个点每次加边的时候只能加一条。</p><p>首先算出每个点到0的最短路，然后对于每个点找一个父节点，如果0到父节点的最短路+该点到父节点的距离=0到该点的最短路，就可以通过这个父节点来走，只多加了一条边，因为0到父节点的最短路是本来就存在的。这样遍历每个点，再把结果相乘，就是答案了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> g[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<span class="hljs-keyword">char</span> a[<span class="hljs-number">110</span>];<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;p;<span class="hljs-keyword">int</span> dis[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">fill</span>(dis,dis+n,INF);    dis[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    priority_queue&lt;p,<span class="hljs-built_in">vector</span>&lt;p&gt;,greater&lt;p&gt; &gt;q;    q.push(p(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        p temp=q.top();        q.pop();        <span class="hljs-keyword">int</span> w=temp.first;        <span class="hljs-keyword">int</span> id=temp.second;        <span class="hljs-keyword">if</span>(w&gt;dis[id])<span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-keyword">if</span>(w+g[id][i]&lt;dis[i])            &#123;                dis[i]=w+g[id][i];                q.push(p(dis[i],i));            &#125;        &#125;    &#125;    <span class="hljs-comment">//for(int i=0;i&lt;n;i++)</span>        <span class="hljs-comment">//printf("%d ",dis[i]);</span>    <span class="hljs-comment">//printf("\n");</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)            &#123;                g[i][j]=a[j]-<span class="hljs-string">'0'</span>;                <span class="hljs-keyword">if</span>(i!=j&amp;&amp;g[i][j]==<span class="hljs-number">0</span>)g[i][j]=INF;            &#125;        &#125;        dijkstra();        ll ans=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)        &#123;            ll temp=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)            &#123;                <span class="hljs-keyword">if</span>(i!=j&amp;&amp;dis[j]+g[i][j]==dis[i])                    temp++;            &#125;            <span class="hljs-comment">//printf("%lld\n",temp);</span>            ans=(ans*temp)%MOD;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客网暑期ACM多校训练营（第一场）E dp</title>
    <link href="/2018/07/27/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9A%91%E6%9C%9FACM%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89E-dp/"/>
    <url>/2018/07/27/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9A%91%E6%9C%9FACM%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89E-dp/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出一个长度为n且元素不超过k的序列，问删除m个数之后不同的序列有几种，模<script type="math/tex">1e9+7</script>。其中<script type="math/tex">1 ≤ n ≤ 10^5</script>，<script type="math/tex">1 ≤ m ≤ min \{ n - 1, 10\}</script>，<script type="math/tex">1 ≤ k ≤ 10</script>。</p><p><strong>思路：</strong></p><p><script type="math/tex">dp[i][j]：前i个数字删除j个数字的方案数</script>。</p><p>有转移<script type="math/tex">dp[i][j]=dp[i-1][j](不删除该数字)+dp[i-1][j-1](删除该数字)</script>。</p><p>考虑到序列里面可能有重复数字，比如</p><p>1,3,2,4,1,5，这时如果<del>1,3,2,4,</del>1,5和1,<del>3,2,4,1,</del>5这两种情况应该是同一种方案，所以当前后有两个数字相同，其中一个删除，中间的也全部删除，这是会有重复方案的。</p><p>所以对于一个前面有相同数字的i，假设前一个数字为pre[i]，相当于要减去pre[i]-1时候删除的数字为j-(i-pre[i])，就相当于当前i没有删除，将pre[i]~i-1全部删除，这种方案是重复的，所以要减去。</p><p>dp的初始化在循环中进行会快很多，memset比较慢。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> cur[<span class="hljs-number">15</span>];<span class="hljs-keyword">int</span> pre[<span class="hljs-number">100010</span>];<span class="hljs-comment">//上一个相同数字出现在哪里</span>ll dp[<span class="hljs-number">100010</span>][<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,k;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k)!=EOF)    &#123;        <span class="hljs-keyword">int</span> x;        <span class="hljs-built_in">memset</span>(pre,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(pre));        <span class="hljs-built_in">memset</span>(cur,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(cur));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            <span class="hljs-keyword">if</span>(cur[x]!=<span class="hljs-number">-1</span>)pre[i]=cur[x];            cur[x]=i;        &#125;        <span class="hljs-keyword">if</span>(m&gt;n)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);<span class="hljs-keyword">continue</span>;&#125;        <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">            printf("%d ",pre[i]);</span><span class="hljs-comment">        printf("\n");*/</span>        <span class="hljs-comment">//memset(dp,0,sizeof(dp));</span>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-built_in">min</span>(m,i);j++)        &#123;            dp[i][j]=<span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;j<span class="hljs-number">-1</span>&lt;=<span class="hljs-built_in">min</span>(m,i<span class="hljs-number">-1</span>))dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%MOD;            <span class="hljs-keyword">if</span>(j&lt;=<span class="hljs-built_in">min</span>(m,i<span class="hljs-number">-1</span>))dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][j])%MOD;            <span class="hljs-keyword">if</span>(pre[i]!=<span class="hljs-number">-1</span>&amp;&amp;j-(i-pre[i])&gt;=<span class="hljs-number">0</span>&amp;&amp;j-(i-pre[i])&lt;=<span class="hljs-built_in">min</span>(m,pre[i]<span class="hljs-number">-1</span>))                dp[i][j]=(dp[i][j]-dp[pre[i]<span class="hljs-number">-1</span>][j-(i-pre[i])]+MOD)%MOD;        &#125;        <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            for(int j=0;j&lt;=min(m,i);j++)</span><span class="hljs-comment">                printf("%lld ",dp[i][j]);</span><span class="hljs-comment">            printf("\n");</span><span class="hljs-comment">        &#125;*/</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,dp[n][m]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NCPC2015A 思维+树的直径</title>
    <link href="/2018/07/27/NCPC2015A-%E6%80%9D%E7%BB%B4-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2018/07/27/NCPC2015A-%E6%80%9D%E7%BB%B4-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出一些树组成的森林，让你添加几条边让它们连成一棵树，并且使树的直径最小。</p><p><strong>思路：</strong></p><p>要使直径最小，可以想到以前一道题目，可以连成菊花形，所以把直径最大的放在最中间，然后其他的连在它的外面，这样子的话，连成一棵树以后，最大直径肯定只跟两棵树有关，当然一棵树的时候就是树的直径，两棵树的时候是两个树的直径+1，,三棵树及以上的时候，最大直径肯定是最长的树的直径+第二长的树的直径+1或者第二长的树的直径+第三长树的直径+2。</p><p>所以先dfs处理出树的直径（先从一棵树的一个点开始找到一个最远的点，再从这个最远的点dfs回来找到的最长的路就是树的直径），然后把这些树的直径从大到小排序再比较一下求一下最大值就好了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">100010</span>];<span class="hljs-keyword">bool</span> vis1[<span class="hljs-number">100010</span>];<span class="hljs-keyword">bool</span> vis2[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> length[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> temp;<span class="hljs-keyword">int</span> pos;<span class="hljs-keyword">int</span> ss;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>)</span></span><span class="hljs-function"></span>&#123;    vis1[id]=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">if</span>(vis1[v[id][i]])<span class="hljs-keyword">continue</span>;        sign++;        dfs1(v[id][i],<span class="hljs-built_in">step</span>+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">if</span>(sign==<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">step</span>&gt;temp)    &#123;        temp=<span class="hljs-built_in">step</span>;        pos=id;    &#125;    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>)</span></span><span class="hljs-function"></span>&#123;    vis2[id]=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">if</span>(vis2[v[id][i]])<span class="hljs-keyword">continue</span>;        dfs2(v[id][i],<span class="hljs-built_in">step</span>+<span class="hljs-number">1</span>);    &#125;    ss=<span class="hljs-built_in">max</span>(ss,<span class="hljs-built_in">step</span>);    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&gt;y;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        v[x].push_back(y);        v[y].push_back(x);    &#125;    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">if</span>(!vis2[i])        &#123;            temp=<span class="hljs-number">-1</span>;ss=<span class="hljs-number">-1</span>;            dfs1(i,<span class="hljs-number">0</span>);            dfs2(pos,<span class="hljs-number">0</span>);            length[++num]=ss;            ans=<span class="hljs-built_in">max</span>(ans,ss);        &#125;    &#125;    sort(length+<span class="hljs-number">1</span>,length+num+<span class="hljs-number">1</span>,cmp);    <span class="hljs-comment">//for(int i=1;i&lt;=num;i++)</span>        <span class="hljs-comment">//printf("%d\n",length[i]);</span>    <span class="hljs-keyword">if</span>(num&gt;=<span class="hljs-number">2</span>)ans=<span class="hljs-built_in">max</span>(ans,(<span class="hljs-keyword">int</span>)<span class="hljs-built_in">ceil</span>(length[<span class="hljs-number">1</span>]/<span class="hljs-number">2.0</span>)+(<span class="hljs-keyword">int</span>)<span class="hljs-built_in">ceil</span>(length[<span class="hljs-number">2</span>]/<span class="hljs-number">2.0</span>)+<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(num&gt;=<span class="hljs-number">3</span>)ans=<span class="hljs-built_in">max</span>(ans,(<span class="hljs-keyword">int</span>)<span class="hljs-built_in">ceil</span>(length[<span class="hljs-number">2</span>]/<span class="hljs-number">2.0</span>)+(<span class="hljs-keyword">int</span>)<span class="hljs-built_in">ceil</span>(length[<span class="hljs-number">3</span>]/<span class="hljs-number">2.0</span>)+<span class="hljs-number">2</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>徐州邀请赛I 类矩阵快速幂</title>
    <link href="/2018/07/27/%E5%BE%90%E5%B7%9E%E9%82%80%E8%AF%B7%E8%B5%9BI-%E7%B1%BB%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2018/07/27/%E5%BE%90%E5%B7%9E%E9%82%80%E8%AF%B7%E8%B5%9BI-%E7%B1%BB%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有N天，一个人每天穿一件衣服，总共有m件衣服，某天穿颜色A下一天穿颜色B，能得到愉快值<script type="math/tex">f[A][B]</script>。问最大的愉快值是多少。</p><p><strong>思路：</strong></p><p><script type="math/tex">dp[i][j][k]：第k天从i到j的最大愉快值</script> ，</p><p>所以<script type="math/tex">dp[i][j][k]=max(dp[i][j][k],dp[i][t][k-1]+f[t][j])</script>。</p><p>这类似于矩阵乘法了，</p><p>矩阵乘法的形式为<script type="math/tex">dp[i][j][k]=dp[i][j][k]+dp[i][t][k-1]*f[t][j]</script>。</p><p>是很类似的。</p><p>这里注意初始化应该为全零矩阵而不是单位矩阵，因为初始的时候愉快值都为0。</p><p>max和加法本身都是可以交换和结合的，满足结合律的似乎都可以用矩阵做？</p><p>其实找个例子手算一下这种方法就有感觉了，挺妙的，以后对于这种松弛？的式子的时候可以考虑这种做法。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> ss;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];&#125;m,r;<span class="hljs-function">mat <span class="hljs-title">mult</span><span class="hljs-params">(mat x,mat y)</span></span><span class="hljs-function"></span>&#123;    mat res=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;ss;i++)    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;ss;j++)    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;ss;k++)        res.a[i][j]=<span class="hljs-built_in">max</span>(res.a[i][j],x.a[i][k]+y.a[k][j]);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">mat <span class="hljs-title">PowerMod</span><span class="hljs-params">(mat x,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span></span><span class="hljs-function"></span>&#123;    mat ans=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-comment">//for(i=0;i&lt;ss;i++)</span>        <span class="hljs-comment">//ans.a[i][i]=1;</span>    <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)ans=mult(ans,x);        x=mult(x,x);        n=n/<span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ll n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%d"</span>,&amp;n,&amp;ss)!=EOF)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ss;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ss;j++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;m.a[i][j]);        r=PowerMod(m,n<span class="hljs-number">-1</span>);        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ss;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ss;j++)            ans=<span class="hljs-built_in">max</span>(ans,r.a[i][j]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6315 线段树</title>
    <link href="/2018/07/26/HDU6315-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2018/07/26/HDU6315-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有一个长度为n的序列a和一个相同长度的序列b，a初始都为0，b初始为乱序的全排列。现在有两种操作，共操作q次：</p><p>add l r：对于<script type="math/tex">a_l,a_{l+1}...a_r</script>加一；</p><p>query l r：询问<script type="math/tex">\sum_{i=l}^r\lfloor \frac{a_i}{b_i}\rfloor</script>。</p><p>其中<script type="math/tex">1 \leq n,q \leq 100000</script>，<script type="math/tex">1 \leq l \leq r \leq n</script>。</p><p><strong>思路：</strong></p><p>在经过q次操作之后，<script type="math/tex">\sum_{i=1}^n\frac{a_i}{b_i}</script>最大为<script type="math/tex">\sum_{i=1}^n\lfloor \frac{q}{b_i}\rfloor</script>，因为b为全排列，有调和级数<script type="math/tex">\sum_{i=1}^n \frac{q}{b_i}<=qlogn</script>。</p><p>建立两棵线段树，一棵树A维护序列a的最小值，另一棵树B维护<script type="math/tex">\lfloor \frac{a_i}{b_i}\rfloor</script>的和。</p><p>对于add操作，将A的<script type="math/tex">[l,r]</script>区间减1，时间复杂度为<script type="math/tex">O(logn)</script>。当发现该区间的最小值等于0，就向下dfs，找到那个最小值为0的叶子，对这个叶子对应的<script type="math/tex">\lfloor \frac{a_i}{b_i}\rfloor</script>进行修改，复杂度上面证明了应该为<script type="math/tex">O(qlogn)</script>。</p><p>所以总的复杂度为<script type="math/tex">O(q*qlogn)</script>。</p><p>比赛的时候就是卡在要如何知道哪个点要对<script type="math/tex">\lfloor \frac{a_i}{b_i}\rfloor</script>进行修改，也没想到这个全排列居然是这么用的，有勇气的时候还是要暴力一发啊…不要怕写之后要调很久（虽然补题的时候的确调了很久…懒标记下放的地方没有累加啊…</p><p>写线段树的时候也仔细一点吧。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll tot;ll ori[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> num;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node1</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> l,r;    ll mmin,f1;    ll sum;    <span class="hljs-keyword">int</span> pos;&#125;b[<span class="hljs-number">100010</span>&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    b[id].l=L;b[id].r=R;    b[id].f1=<span class="hljs-number">0</span>;    b[id].sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(L==R)    &#123;        b[id].mmin=ori[++num];        b[id].pos=num;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(L+R)&gt;&gt;<span class="hljs-number">1</span>;    build(L,m,id&lt;&lt;<span class="hljs-number">1</span>);    build(m+<span class="hljs-number">1</span>,R,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    b[id].mmin=<span class="hljs-built_in">min</span>(b[id&lt;&lt;<span class="hljs-number">1</span>].mmin,b[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mmin);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    ll c=b[id].f1;    b[id&lt;&lt;<span class="hljs-number">1</span>].mmin-=c;b[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mmin-=c;    b[id&lt;&lt;<span class="hljs-number">1</span>].f1+=b[id].f1;b[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].f1+=b[id].f1;    b[id].f1=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loc,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=b[id].l,r=b[id].r;    <span class="hljs-keyword">if</span>(l==r)    &#123;        b[id].sum++;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(loc&lt;=m)update2(loc,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(loc&gt;m)update2(loc,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    b[id].sum=b[id&lt;&lt;<span class="hljs-number">1</span>].sum+b[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loc,ll c,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=b[id].l,r=b[id].r;    <span class="hljs-keyword">if</span>(l==r)    &#123;        b[id].mmin=c;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(loc&lt;=m)update(loc,c,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(loc&gt;m)update(loc,c,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    b[id].mmin=<span class="hljs-built_in">min</span>(b[id&lt;&lt;<span class="hljs-number">1</span>].mmin,b[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mmin);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=b[id].l,r=b[id].r;    <span class="hljs-keyword">if</span>(l==r)    &#123;        <span class="hljs-keyword">if</span>(b[id].mmin==<span class="hljs-number">0</span>)        &#123;            update(b[id].pos,ori[b[id].pos],<span class="hljs-number">1</span>);            update2(b[id].pos,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(b[id].f1!=<span class="hljs-number">0</span>)pushdown1(id);    <span class="hljs-keyword">if</span>(b[id&lt;&lt;<span class="hljs-number">1</span>].mmin==<span class="hljs-number">0</span>)dfs(id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(b[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mmin==<span class="hljs-number">0</span>)dfs(id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    b[id].mmin=<span class="hljs-built_in">min</span>(b[id&lt;&lt;<span class="hljs-number">1</span>].mmin,b[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mmin);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=b[id].l,r=b[id].r;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        b[id].mmin--;        b[id].f1++;        <span class="hljs-keyword">if</span>(b[id].mmin==<span class="hljs-number">0</span>)            dfs(id);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(b[id].f1!=<span class="hljs-number">0</span>)pushdown1(id);    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)update1(L,R,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)update1(L,R,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    b[id].mmin=<span class="hljs-built_in">min</span>(b[id&lt;&lt;<span class="hljs-number">1</span>].mmin,b[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].mmin);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=b[id].l,r=b[id].r;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        tot+=b[id].sum;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)query(L,R,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)query(L,R,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,q,x,y;    <span class="hljs-keyword">char</span> s[<span class="hljs-number">10</span>];    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;q)!=EOF)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;ori[i]);        num=<span class="hljs-number">0</span>;        build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);        <span class="hljs-keyword">while</span>(q--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s);            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);            <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">'a'</span>)                update1(x,y,<span class="hljs-number">1</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">'q'</span>)            &#123;                tot=<span class="hljs-number">0</span>;                query(x,y,<span class="hljs-number">1</span>);                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,tot);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU6299 贪心</title>
    <link href="/2018/07/24/HDU6299-%E8%B4%AA%E5%BF%83/"/>
    <url>/2018/07/24/HDU6299-%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出几个括号序列，可以对这些括号序列重新进行排序，使得连起来的括号序列里面能匹配的括号长度最长。</p><p><strong>思路：</strong></p><p>首先对于同一个括号序列里面的括号可以直接进行匹配，全部匹配完后，剩下的情况肯定只有三种：全是左括号，全是右括号，前面是右括号后面是左括号。</p><p>所以对这三种情况进行贪心，排序。</p><p>全是左括号的一定要往前放，全是右括号的一定要往后放。</p><p>前面是右括号后面是左括号这种情况中，左括号多的肯定要往前放，来匹配更多的后面的右括号。</p><p>在左括号多的情况中，左括号越少的越往前放，这样能增加与后面右括号多的情况的匹配数，减少左括号的浪费。</p><p>在右括号多的情况中，右括号越多的越往前放，这样右括号可以尽可能与前面的左括号匹配。</p><p>注意cmp函数的写法。</p><p>如果贪不出来的话，可以枚举多种排序情况，然后取最小值。</p><p>这里循环里多次用到strlen()的时候，要用变量存下来，否则会TLE。而且用G++交会RE也是很迷了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> l,r;&#125;p[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> ans;<span class="hljs-keyword">char</span> a[<span class="hljs-number">100010</span>];<span class="hljs-function">node <span class="hljs-title">solve1</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt;s;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(a);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(s.empty()||a[i]==<span class="hljs-string">'('</span>)&#123;s.push(a[i]);<span class="hljs-keyword">continue</span>;&#125;        <span class="hljs-keyword">if</span>(s.top()==<span class="hljs-string">'('</span>)        &#123;            ans+=<span class="hljs-number">2</span>;            s.pop();        &#125;        <span class="hljs-keyword">else</span> s.push(a[i]);    &#125;    <span class="hljs-keyword">int</span> ans1=<span class="hljs-number">0</span>,ans2=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!s.empty())    &#123;        <span class="hljs-keyword">if</span>(s.top()==<span class="hljs-string">'('</span>)ans1++;        <span class="hljs-keyword">else</span> ans2++;        s.pop();    &#125;    <span class="hljs-keyword">return</span> node&#123;ans1,ans2&#125;;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x.r==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(y.r==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x.l==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(y.l==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> a=x.l-x.r,b=y.l-y.r;    <span class="hljs-keyword">if</span>(a&gt;=<span class="hljs-number">0</span>&amp;&amp;b&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">0</span>&amp;&amp;b&gt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(a&gt;=<span class="hljs-number">0</span>&amp;&amp;b&gt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> x.r&lt;y.r;    <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">0</span>&amp;&amp;b&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> x.l&gt;y.l;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve2</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt;s;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;p[i].r;j++)        &#123;            <span class="hljs-keyword">if</span>(s.empty())s.push(<span class="hljs-string">')'</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.top()==<span class="hljs-string">'('</span>)            &#123;                ans+=<span class="hljs-number">2</span>;                s.pop();            &#125;            <span class="hljs-keyword">else</span> s.push(<span class="hljs-string">')'</span>);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;p[i].l;j++)            s.push(<span class="hljs-string">'('</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        ans=<span class="hljs-number">0</span>;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);            p[i]=solve1();        &#125;        <span class="hljs-comment">//printf("%d\n",ans);</span>        <span class="hljs-comment">//for(int i=0;i&lt;n;i++)</span>        <span class="hljs-comment">//printf("(%d,%d)\n",p[i].first,p[i].second);</span>        sort(p,p+n,cmp);        solve2();        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>括号匹配的另一种更快的写法：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> l,r;&#125;p[<span class="hljs-number">100010</span>];<span class="hljs-keyword">char</span> a[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x.r==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(y.r==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x.l==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(y.l==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x.l&gt;=x.r&amp;&amp;y.l&lt;y.r)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x.l&lt;x.r&amp;&amp;y.l&gt;=y.r)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x.l&gt;=x.r&amp;&amp;y.l&gt;=y.r)<span class="hljs-keyword">return</span> x.r&lt;y.r;    <span class="hljs-keyword">if</span>(x.l&lt;x.r&amp;&amp;y.l&lt;y.r)<span class="hljs-keyword">return</span> x.l&gt;y.l;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,ans;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        ans=<span class="hljs-number">0</span>;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);            p[j].l=<span class="hljs-number">0</span>;p[j].r=<span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(a);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)            &#123;                <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">'('</span>)                    p[j].l++;                <span class="hljs-keyword">else</span>                &#123;                    <span class="hljs-keyword">if</span>(p[j].l!=<span class="hljs-number">0</span>)                    &#123;                        ans+=<span class="hljs-number">2</span>;                        p[j].l--;                    &#125;                    <span class="hljs-keyword">else</span> p[j].r++;                &#125;            &#125;        &#125;        <span class="hljs-comment">//printf("%d\n",ans);</span>        <span class="hljs-comment">//for(int i=0;i&lt;n;i++)</span>        <span class="hljs-comment">//printf("(%d,%d)\n",p[i].first,p[i].second);</span>        sort(p,p+n,cmp);        <span class="hljs-keyword">int</span> L=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-keyword">if</span>(L&gt;=p[i].r)            &#123;                ans+=<span class="hljs-number">2</span>*p[i].r;                L-=p[i].r;            &#125;            <span class="hljs-keyword">else</span>            &#123;                ans+=<span class="hljs-number">2</span>*L;                L=<span class="hljs-number">0</span>;            &#125;            L+=p[i].l;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客网暑期ACM多校训练营（第一场）B dp+公式推导</title>
    <link href="/2018/07/22/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9A%91%E6%9C%9FACM%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89B-dp-%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/"/>
    <url>/2018/07/22/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%9A%91%E6%9C%9FACM%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89B-dp-%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>符合下列条件的n*n的矩阵有多少个？(mod m)</p><p>每个元素只能为0,1,2；</p><p>对称矩阵，主对角线都为0；</p><p>每行的和为2。</p><p><strong>思路：</strong></p><p>看到矩阵的这些特征可以想到把它看作一个无向图的邻接矩阵。</p><p>若<script type="math/tex">A_{i,j}=2</script>表示i和j之间有两条边，就相当于是两个点的环。</p><p>那么每行的和为2的意思就是每个点的度为2，说明这个图全部都是环，每个点属于且仅属于一个环。</p><p>可以考虑dp：</p><p>f(n)表示n个点时的方案数。</p><p>转移：</p><p>第n个点在二个点的环内的方案数：<script type="math/tex">(n-1)*f(n-2)</script>；</p><p>第n个点在三个点的环内的方案数：<script type="math/tex">C_{n-1}^2*f(n-3)*(\frac{3!}{3})*(\frac{1}{2})</script>；</p><p>第n个点在四个点的环内的方案数：<script type="math/tex">C_{n-1}^3*f(n-4)*(\frac{4!}{4})*(\frac{1}{2})</script>；</p><p>……</p><p>第n个点在k个点的环内的方案数：<script type="math/tex">C_{n-1}^{k-1}*f(n-k)*(\frac{k!}{k})*(\frac{1}{2})=C_{n-1}^{k-1}*f(n-k)*(k-1)!*(\frac{1}{2})</script>。</p><p>所以，<script type="math/tex">f(n)=(n-1)*f(n-2)+\frac{1}{2}\sum_{k=3}^nC_{n-1}^{k-1}*f(n-k)*(k-1)!\\\ \ \ \ \ \ \ \ =(n-1)*f(n-2)+\frac{1}{2}\sum_{k=3}^n\frac{(n-1)!}{(n-k)!}*f(n-k)</script></p><p>令<script type="math/tex">n-k=t</script>，得</p><script type="math/tex; mode=display">f(n)=(n-1)*f(n-2)+\frac{1}{2}\sum_{t=0}^{n-3}\frac{(n-1)!}{t}*f(t)$$，同除以$$(n-1)!$$，得$$n*\frac{f(n)}{n!}=\frac{f(n-2)}{(n-2)!}+\frac{1}{2}\sum_{t=0}^{n-3}\frac{f(n)}{n!}</script><p>令<script type="math/tex">g(n)=\frac{f(n)}{n!}</script>，得</p><p><script type="math/tex">n*g(n)=g(n-2)+\frac{1}{2}\sum_{t=0}^{n-3}g(t)</script>。</p><p><script type="math/tex">(n-1)*g(n-1)=g(n-3)+\sum_{t=0}^{n-4}g(t-1)</script>。</p><p>两式相减，得</p><p><script type="math/tex">g(n)=(\frac{n-1}{n})g(n-1)+\frac{1}{n}g(n-2)-\frac{1}{2n}g(n-3)</script>。</p><p>将<script type="math/tex">g(n)=\frac{f(n)}{n!}</script>代入，得</p><p><script type="math/tex">f(n)=(n-1)(f(n-1)+f(n-2))-\frac{(n-1)(n-2)}{2}f(n-3)</script>。</p><p>就可以做了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll f[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ll n,m;    f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;f[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;f[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;f[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;n,&amp;m)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">3</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,f[n]);<span class="hljs-keyword">continue</span>;&#125;        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">4</span>;i&lt;=n;i++)            f[i]=(((i<span class="hljs-number">-1</span>)*(f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>])%m)%m-(((i<span class="hljs-number">-1</span>)*(i<span class="hljs-number">-2</span>)/<span class="hljs-number">2</span>)%m*f[i<span class="hljs-number">-3</span>])%m+m)%m;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,f[n]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>io优化</title>
    <link href="/2018/07/20/io%E4%BC%98%E5%8C%96/"/>
    <url>/2018/07/20/io%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> fastIO&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 100000</span>    <span class="hljs-comment">//fread -&gt; read</span>    <span class="hljs-keyword">bool</span> IOerror = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">nc</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;        <span class="hljs-keyword">if</span>(p1 == pend)        &#123;            p1 = buf;            pend = buf + fread(buf, <span class="hljs-number">1</span>, BUF_SIZE, <span class="hljs-built_in">stdin</span>);            <span class="hljs-keyword">if</span>(pend == p1)            &#123;                IOerror = <span class="hljs-number">1</span>;                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> *p1++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">blank</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> ch == <span class="hljs-string">' '</span> || ch == <span class="hljs-string">'\n'</span> || ch == <span class="hljs-string">'\r'</span> || ch == <span class="hljs-string">'\t'</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span><span class="hljs-comment">//这里int &amp;x,实参需为int，这里改为ll &amp;x,就可以读入ll型</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">char</span> ch;        <span class="hljs-keyword">while</span>(blank(ch = nc()));        <span class="hljs-keyword">if</span>(IOerror) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">for</span>(x = ch - <span class="hljs-string">'0'</span>; (ch = nc()) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; ch &lt;= <span class="hljs-string">'9'</span>; x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">'0'</span>);    &#125;    <span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> BUF_SIZE</span>&#125;;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> fastIO; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T;    <span class="hljs-built_in">read</span>(T);    <span class="hljs-built_in">read</span>(n);    <span class="hljs-built_in">read</span>(m);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) <span class="hljs-built_in">read</span>(v[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> IO&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 100000</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OUT_SIZE 100000</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span>    <span class="hljs-comment">//fread-&gt;read</span>     <span class="hljs-keyword">bool</span> IOerror=<span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">nc</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;        <span class="hljs-keyword">if</span> (p1==pend)&#123;            p1=buf; pend=buf+fread(buf,<span class="hljs-number">1</span>,BUF_SIZE,<span class="hljs-built_in">stdin</span>);            <span class="hljs-keyword">if</span> (pend==p1)&#123;IOerror=<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;            <span class="hljs-comment">//&#123;printf("IO error!\n");system("pause");for (;;);exit(0);&#125;</span>        &#125;        <span class="hljs-keyword">return</span> *p1++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">blank</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span>&#123;<span class="hljs-keyword">return</span> ch==<span class="hljs-string">' '</span>||ch==<span class="hljs-string">'\n'</span>||ch==<span class="hljs-string">'\r'</span>||ch==<span class="hljs-string">'\t'</span>;&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span></span>&#123;        <span class="hljs-keyword">bool</span> sign=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> ch=nc(); x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (;blank(ch);ch=nc());        <span class="hljs-keyword">if</span> (IOerror)<span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">'-'</span>)sign=<span class="hljs-number">1</span>,ch=nc();        <span class="hljs-keyword">for</span> (;ch&gt;=<span class="hljs-string">'0'</span>&amp;&amp;ch&lt;=<span class="hljs-string">'9'</span>;ch=nc())x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span> (sign)x=-x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(ll &amp;x)</span></span>&#123;        <span class="hljs-keyword">bool</span> sign=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> ch=nc(); x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (;blank(ch);ch=nc());        <span class="hljs-keyword">if</span> (IOerror)<span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">'-'</span>)sign=<span class="hljs-number">1</span>,ch=nc();        <span class="hljs-keyword">for</span> (;ch&gt;=<span class="hljs-string">'0'</span>&amp;&amp;ch&lt;=<span class="hljs-string">'9'</span>;ch=nc())x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span> (sign)x=-x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">double</span> &amp;x)</span></span>&#123;        <span class="hljs-keyword">bool</span> sign=<span class="hljs-number">0</span>; <span class="hljs-keyword">char</span> ch=nc(); x=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (;blank(ch);ch=nc());        <span class="hljs-keyword">if</span> (IOerror)<span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">'-'</span>)sign=<span class="hljs-number">1</span>,ch=nc();        <span class="hljs-keyword">for</span> (;ch&gt;=<span class="hljs-string">'0'</span>&amp;&amp;ch&lt;=<span class="hljs-string">'9'</span>;ch=nc())x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">'.'</span>)&#123;            <span class="hljs-keyword">double</span> tmp=<span class="hljs-number">1</span>; ch=nc();            <span class="hljs-keyword">for</span> (;ch&gt;=<span class="hljs-string">'0'</span>&amp;&amp;ch&lt;=<span class="hljs-string">'9'</span>;ch=nc())tmp/=<span class="hljs-number">10.0</span>,x+=tmp*(ch-<span class="hljs-string">'0'</span>);        &#125;        <span class="hljs-keyword">if</span> (sign)x=-x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span>&#123;        <span class="hljs-keyword">char</span> ch=nc();        <span class="hljs-keyword">for</span> (;blank(ch);ch=nc());        <span class="hljs-keyword">if</span> (IOerror)<span class="hljs-keyword">return</span>;        <span class="hljs-keyword">for</span> (;!blank(ch)&amp;&amp;!IOerror;ch=nc())*s++=ch;        *s=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> &amp;c)</span></span>&#123;        <span class="hljs-keyword">for</span> (c=nc();blank(c);c=nc());        <span class="hljs-keyword">if</span> (IOerror)&#123;c=<span class="hljs-number">-1</span>;<span class="hljs-keyword">return</span>;&#125;    &#125;    <span class="hljs-comment">//fwrite-&gt;write</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ostream_fwrite</span>&#123;</span>        <span class="hljs-keyword">char</span> *buf,*p1,*pend;        Ostream_fwrite()&#123;buf=<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[BUF_SIZE];p1=buf;pend=buf+BUF_SIZE;&#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span>&#123;            <span class="hljs-keyword">if</span> (p1==pend)&#123;                fwrite(buf,<span class="hljs-number">1</span>,BUF_SIZE,<span class="hljs-built_in">stdout</span>);p1=buf;            &#125;            *p1++=ch;        &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;            <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> s[<span class="hljs-number">15</span>],*s1;s1=s;            <span class="hljs-keyword">if</span> (!x)*s1++=<span class="hljs-string">'0'</span>;<span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>)out(<span class="hljs-string">'-'</span>),x=-x;            <span class="hljs-keyword">while</span>(x)*s1++=x%<span class="hljs-number">10</span>+<span class="hljs-string">'0'</span>,x/=<span class="hljs-number">10</span>;            <span class="hljs-keyword">while</span>(s1--!=s)out(*s1);        &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;            <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> s[<span class="hljs-number">15</span>],*s1;s1=s;            <span class="hljs-keyword">if</span> (!x)*s1++=<span class="hljs-string">'0'</span>;<span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>)out(<span class="hljs-string">'-'</span>),x=-x;            <span class="hljs-keyword">while</span>(x)*s1++=x%<span class="hljs-number">10</span>+<span class="hljs-string">'0'</span>,x/=<span class="hljs-number">10</span>;            <span class="hljs-keyword">while</span>(s1--!=s)out(*s1); out(<span class="hljs-string">'\n'</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ll x)</span></span>&#123;            <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> s[<span class="hljs-number">25</span>],*s1;s1=s;            <span class="hljs-keyword">if</span> (!x)*s1++=<span class="hljs-string">'0'</span>;<span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>)out(<span class="hljs-string">'-'</span>),x=-x;            <span class="hljs-keyword">while</span>(x)*s1++=x%<span class="hljs-number">10</span>+<span class="hljs-string">'0'</span>,x/=<span class="hljs-number">10</span>;            <span class="hljs-keyword">while</span>(s1--!=s)out(*s1);        &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(ll x)</span></span>&#123;            <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> s[<span class="hljs-number">25</span>],*s1;s1=s;            <span class="hljs-keyword">if</span> (!x)*s1++=<span class="hljs-string">'0'</span>;<span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>)out(<span class="hljs-string">'-'</span>),x=-x;            <span class="hljs-keyword">while</span>(x)*s1++=x%<span class="hljs-number">10</span>+<span class="hljs-string">'0'</span>,x/=<span class="hljs-number">10</span>;            <span class="hljs-keyword">while</span>(s1--!=s)out(*s1); out(<span class="hljs-string">'\n'</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;            <span class="hljs-keyword">static</span> ll mul[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">100000</span>,<span class="hljs-number">1000000</span>,<span class="hljs-number">10000000</span>,<span class="hljs-number">100000000</span>,                <span class="hljs-number">1000000000</span>,<span class="hljs-number">10000000000L</span>L,<span class="hljs-number">100000000000L</span>L,<span class="hljs-number">1000000000000L</span>L,<span class="hljs-number">10000000000000L</span>L,                <span class="hljs-number">100000000000000L</span>L,<span class="hljs-number">1000000000000000L</span>L,<span class="hljs-number">10000000000000000L</span>L,<span class="hljs-number">100000000000000000L</span>L&#125;;            <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">-1e-12</span>)out(<span class="hljs-string">'-'</span>),x=-x;x*=mul[y];            ll x1=(ll)<span class="hljs-built_in">floor</span>(x); <span class="hljs-keyword">if</span> (x-<span class="hljs-built_in">floor</span>(x)&gt;=<span class="hljs-number">0.5</span>)++x1;            ll x2=x1/mul[y],x3=x1-x2*mul[y]; <span class="hljs-built_in">print</span>(x2);            <span class="hljs-keyword">if</span> (y&gt;<span class="hljs-number">0</span>)&#123;out(<span class="hljs-string">'.'</span>); <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">1</span>;i&lt;y&amp;&amp;x3*mul[i]&lt;mul[y];out(<span class="hljs-string">'0'</span>),++i); <span class="hljs-built_in">print</span>(x3);&#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-built_in">print</span>(x,y);out(<span class="hljs-string">'\n'</span>);&#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span>&#123;<span class="hljs-keyword">while</span> (*s)out(*s++);&#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span>&#123;<span class="hljs-keyword">while</span> (*s)out(*s++);out(<span class="hljs-string">'\n'</span>);&#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span> (p1!=buf)&#123;fwrite(buf,<span class="hljs-number">1</span>,p1-buf,<span class="hljs-built_in">stdout</span>);p1=buf;&#125;&#125;        ~Ostream_fwrite()&#123;<span class="hljs-built_in">flush</span>();&#125;    &#125;Ostream;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;Ostream.<span class="hljs-built_in">print</span>(x);&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;Ostream.<span class="hljs-built_in">println</span>(x);&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">char</span> x)</span></span>&#123;Ostream.out(x);&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-keyword">char</span> x)</span></span>&#123;Ostream.out(x);Ostream.out(<span class="hljs-string">'\n'</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ll x)</span></span>&#123;Ostream.<span class="hljs-built_in">print</span>(x);&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(ll x)</span></span>&#123;Ostream.<span class="hljs-built_in">println</span>(x);&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;Ostream.<span class="hljs-built_in">print</span>(x,y);&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;Ostream.<span class="hljs-built_in">println</span>(x,y);&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span>&#123;Ostream.<span class="hljs-built_in">print</span>(s);&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span>&#123;Ostream.<span class="hljs-built_in">println</span>(s);&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">()</span></span>&#123;Ostream.out(<span class="hljs-string">'\n'</span>);&#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>&#123;Ostream.<span class="hljs-built_in">flush</span>();&#125;    <span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> ll</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> OUT_SIZE</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> BUF_SIZE</span>&#125;; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> t=<span class="hljs-number">1234.46789</span>;    <span class="hljs-keyword">int</span> n=<span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="hljs-built_in">endl</span>;    IO::<span class="hljs-built_in">println</span>(n);    IO::<span class="hljs-built_in">println</span>(t,n);<span class="hljs-comment">//四舍五入，输出小数点后n位</span>    <span class="hljs-comment">//IO::read(n);IO::read(k);</span>    <span class="hljs-comment">//能读入和输出int,long long,double,char,char *,</span>    <span class="hljs-comment">//读入read;输出带换行println,不带换行print</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lindström–Gessel–Viennot引理</title>
    <link href="/2018/07/20/LGV%E5%BC%95%E7%90%86/"/>
    <url>/2018/07/20/LGV%E5%BC%95%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h5 id="Lindström–Gessel–Viennot引理"><a href="#Lindström–Gessel–Viennot引理" class="headerlink" title="Lindström–Gessel–Viennot引理"></a>Lindström–Gessel–Viennot引理</h5><p>对于一张无边权的DAG图，给定n个起点和对应的n个终点，<u>这n条不相交路径</u>的方案数为</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ftg6jj4yj7j30wv0domyr.jpg" srcset="/img/loading.gif" alt="img"></p><p>其中e(a,b)为图上a（起点）到b（终点）的方案数。</p><hr><h5 id="CodeForces348D"><a href="#CodeForces348D" class="headerlink" title="CodeForces348D"></a>CodeForces348D</h5><p><strong>题意：</strong></p><p>给出一张n*m的有障碍的图，问从(1,1)到(n,m)不相交的两条路径的方案。其中<script type="math/tex">2<=n,m<=3000</script>。</p><p><strong>思路：</strong></p><p>可以将起点看作<script type="math/tex">A_1(1,2)</script>和<script type="math/tex">A_2(2,1)</script>，将终点看作<script type="math/tex">B_1(n-1,m)</script>和<script type="math/tex">B_2(n,m-1)</script>（不能换，因为这样<script type="math/tex">A_1B_1</script>和<script type="math/tex">A_2B_2</script>路径是不相交的，如果换了以后这两条路径肯定是会相交的），路径肯定是<script type="math/tex">(1,2)->(n-1,m)</script>和<script type="math/tex">(2,1)->(n,m-1)</script>这两条，否则是会相交的。</p><p>设<script type="math/tex">S(x,y)</script>为从x到y的方案数。</p><p>根据LGV引理，答案为<script type="math/tex">S(A1,B1)*S(A2,B2)-S(A1,B2)*S(A2,B1)</script>。</p><p>因为是有障碍的而且范围可以进行DP，所以DP求出<script type="math/tex">S(x,y)</script>就可以了。</p><p>如果没有障碍的话可以直接组合数，比如从(1,1)到(n,m)为<script type="math/tex">C_{n+m-2}^{n-1}</script>（总共要走n+m-2步其中有n-1步是往下走的）。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">char</span> mp[<span class="hljs-number">3010</span>][<span class="hljs-number">3010</span>];ll dp[<span class="hljs-number">3010</span>][<span class="hljs-number">3010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> r,c;    ll ans11,ans12,ans21,ans22;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;r,&amp;c);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,mp[i]+<span class="hljs-number">1</span>);    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">if</span>(mp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]==<span class="hljs-string">'.'</span>)dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=c;j++)        &#123;            <span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">'#'</span>)<span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>&amp;&amp;mp[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">'.'</span>)                dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][j])%MOD;            <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>&amp;&amp;mp[i][j<span class="hljs-number">-1</span>]==<span class="hljs-string">'.'</span>)                dp[i][j]=(dp[i][j]+dp[i][j<span class="hljs-number">-1</span>])%MOD;        &#125;    ans11=dp[r<span class="hljs-number">-1</span>][c];ans12=dp[r][c<span class="hljs-number">-1</span>];    <span class="hljs-keyword">if</span>(mp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]==<span class="hljs-string">'.'</span>)dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=c;j++)        &#123;            <span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">'#'</span>)<span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>&amp;&amp;mp[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">'.'</span>)                dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][j])%MOD;            <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>&amp;&amp;mp[i][j<span class="hljs-number">-1</span>]==<span class="hljs-string">'.'</span>)                dp[i][j]=(dp[i][j]+dp[i][j<span class="hljs-number">-1</span>])%MOD;        &#125;    ans21=dp[r<span class="hljs-number">-1</span>][c];ans22=dp[r][c<span class="hljs-number">-1</span>];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,((ans11*ans22)%MOD-(ans12*ans21)%MOD+MOD)%MOD);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h5 id="牛客网暑期ACM多校训练营（第一场）A"><a href="#牛客网暑期ACM多校训练营（第一场）A" class="headerlink" title="牛客网暑期ACM多校训练营（第一场）A"></a>牛客网暑期ACM多校训练营（第一场）A</h5><p><strong>题意：</strong></p><p>要求满足以下条件的n*m的矩阵个数模1e9+7：</p><script type="math/tex; mode=display">A_{i,j}∈ {0, 1, 2}</script><script type="math/tex; mode=display">A_{i,j}\leq A_{i+1,j}</script><p><script type="math/tex">A_{i, j}\leq A_{i,j+1}</script>。</p><p><strong>思路：</strong></p><p>考虑01和12的分界线，是<script type="math/tex">(n,0)</script>到<script type="math/tex">(0,m)</script>的两条不相交（可重合）路径。因为两个起点重合了，所以平移其中一条变成<script type="math/tex">(n-1,-1)</script>到<script type="math/tex">(-1,m-1)</script>。</p><p>所以将起点看作<script type="math/tex">(n,0)</script>和<script type="math/tex">(n-1,-1)</script>，把终点看作<script type="math/tex">(0,m)</script>和<script type="math/tex">(-1,m-1)</script>。</p><p>之后就可以用LGV公式了。</p><p>所以答案是<script type="math/tex">{C_{n+m}^{n}}^{2}-C_{n+m}^{m-1}*C_{n+m}^{n-1}</script>。</p><p>所以分界线将矩阵分为三部分。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ftgom5htgjj30ic0duaaz.jpg" srcset="/img/loading.gif" alt="img"></p><p>我之前有个疑问，为什么不仍然像上面那道题一样分成两个那样的起点和终点呢？</p><p>结合上面那张图考虑了一下，这样子分是会有遗漏的，就只有这张图的这些情况了，就少了一些，就是说分界线中间相差的不止是一格，而以上那样的相差的就是一格。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ftgor2hqgzj30ic0duglv.jpg" srcset="/img/loading.gif" alt="1096169-20180720180334882-4476819992"></p><p><strong>代码：</strong></p><pre><code class="hljs c++">ll c[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2000</span>;i++)<span class="hljs-comment">//j是上面，i是下面</span>    &#123;        c[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j&lt;=i;j++)        &#123;            c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%MOD;            <span class="hljs-comment">//printf("%lld %lld %lld\n",i,j,c[i][j]);</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    init();    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,m;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;n,&amp;m)!=EOF)    &#123;        ll temp1=c[n+m][n];        ll temp2=c[n+m][m<span class="hljs-number">-1</span>];        ll temp3=c[n+m][n<span class="hljs-number">-1</span>];        <span class="hljs-comment">//printf("%lld %lld %lld\n",temp1,temp2,temp3);</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,((temp1*temp1)%MOD-(temp2*temp3)%MOD+MOD)%MOD);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莫队算法</title>
    <link href="/2018/07/18/bzoj2038-%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90-%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
    <url>/2018/07/18/bzoj2038-%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90-%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>莫队算法可以一个可高效解决绝大多数<strong>离线</strong>+<strong>无修改</strong>+<strong>区间查询</strong>问题的算法。这类问题具体是指：如果知道<script type="math/tex">[L,R]</script>的答案时，可以在<script type="math/tex">O(g(n))</script>的时间下得到<script type="math/tex">[L,R−1]</script>,<script type="math/tex">[L,R+1]</script>,<script type="math/tex">[L−1,R]</script>,<script type="math/tex">[L+1,R]</script>的答案的话，就可以<script type="math/tex">O(n\sqrt n · \mathrm{g}(n))</script>的时间内求出所有查询。</p><p>对于莫队算法我感觉就是暴力。由于预先知道所有的询问，因此可以合理的组织计算每个询问的顺序以此来降低复杂度。</p><p>假设我们算完<script type="math/tex">[L,R]</script>的答案后现在要算<script type="math/tex">[L′,R′]</script>的答案。由于可以在<script type="math/tex">O(1)</script>的时间下得到<script type="math/tex">[L,R−1]</script>,<script type="math/tex">[L,R+1]</script>,<script type="math/tex">[L−1,R]</script>,<script type="math/tex">[L+1,R]</script>的答案，所以计算<script type="math/tex">[L′,R′]</script>的答案耗时<script type="math/tex">|L−L′|+|R−R′|</script>。如果把询问<script type="math/tex">[L,R]</script>看做平面上的点<script type="math/tex">a(L,R)</script>，询问<script type="math/tex">[L′,R′]</script>看做点<script type="math/tex">b(L′,R′)</script>的话，那么时间开销就为两点的曼哈顿距离。</p><p>因此，如果将每个询问看做平面上的一个点，按一定顺序计算每个值，那开销就为曼哈顿距离的和。要计算到每个点，路径至少会形成一棵树。所以问题就变成了求二维平面的最小曼哈顿距离生成树。</p><p>这样只要顺着树边计算一次就OK了，可以证明时间复杂度为<script type="math/tex">O(n\sqrt{n})</script>（这个我不会证明），但是这种方法的编程复杂度稍微高了一点。</p><p>有一个比较优雅的替代品：先对序列分块，然后对于所有询问按照L所在块的大小排序，如果一样再按照R排序，最后再计算。为什么这样计算就可以降低复杂度呢?</p><p>一、i与i+1在同一块内，r单调递增，所以r是<script type="math/tex">O(n)</script>的。由于有<script type="math/tex">\sqrt{n}</script>块,所以这一部分时间复杂度是<script type="math/tex">O(n\sqrt{n})</script>；<br>二、i与i+1跨越一块，r最多变化n，由于有<script type="math/tex">\sqrt{n}</script>块，所以这一部分时间复杂度是<script type="math/tex">O(n\sqrt{n})</script>；<br>三、i与i+1在同一块内时，变化不超过<script type="math/tex">\sqrt{n}</script>，跨越一块也不会超过<script type="math/tex">\sqrt{n}</script>，不妨看作是<script type="math/tex">\sqrt{n}</script>。由于有n个数，所以时间复杂度是<script type="math/tex">O(n\sqrt{n})</script>；<br>于是就变成了<script type="math/tex">O(n\sqrt{n})</script>了。</p><h5 id="例题（bzoj2038"><a href="#例题（bzoj2038" class="headerlink" title="例题（bzoj2038)"></a>例题（bzoj2038)</h5><p><strong>题意：</strong></p><p>有n只袜子，每只袜子有不同的颜色，给出区间<script type="math/tex">[L,R]</script>，问在这个区间中有多大的概率抽到两只颜色相同的袜子。</p><p><strong>思路：</strong></p><p>假设区间<script type="math/tex">[L,R]</script>中有三种颜色，每种颜色的袜子只数分别为a,b,c。</p><p>则抽到两只颜色相同的袜子的概率为<script type="math/tex">\frac{a}{a+b+c}*\frac{a-1}{a+b+c-1}+\frac{b}{a+b+c}*\frac{b-1}{a+b+c-1}+\frac{c}{a+b+c}*\frac{c}{a+b+c-1}</script>，化简结果为<script type="math/tex">\frac{a^2+b^2+c^2-(a+b+c)}{(a+b+c)*(a+b+c-1)}=\frac{a^2+b^2+c^2-(R-L+1)}{(R-L+1)*(R-L)}</script>。</p><p>所以只要求每个区间内每种袜子的数目的平方和就可以了。</p><p>这时可以用莫队算法了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qnode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> l,r,id;&#125;q[<span class="hljs-number">50010</span>];ll tot;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anode</span></span><span class="hljs-class">&#123;</span>    ll fz,fm;&#125;ans[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> col[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> pos[<span class="hljs-number">50010</span>];<span class="hljs-comment">//在哪一块里（用来对询问排序）</span>ll num[<span class="hljs-number">50010</span>];<span class="hljs-comment">//当前每种颜色的数目</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(qnode x,qnode y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos[x.l]!=pos[y.l])<span class="hljs-keyword">return</span> pos[x.l]&lt;pos[y.l];    <span class="hljs-keyword">return</span> x.r&lt;y.r;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> d)</span></span><span class="hljs-function"></span>&#123;    tot-=num[col[id]]*num[col[id]];    num[col[id]]+=d;    tot+=num[col[id]]*num[col[id]];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">int</span> block=<span class="hljs-built_in">sqrt</span>(n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;col[i]);        pos[i]=(i<span class="hljs-number">-1</span>)/block;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;q[i].l,&amp;q[i].r);        q[i].id=i;    &#125;    sort(q+<span class="hljs-number">1</span>,q+<span class="hljs-number">1</span>+m,cmp);    <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(num));    <span class="hljs-keyword">int</span> L=<span class="hljs-number">1</span>,R=<span class="hljs-number">0</span>;    tot=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">int</span> id=q[i].id;        <span class="hljs-keyword">if</span>(q[i].l==q[i].r)        &#123;            ans[id].fz=<span class="hljs-number">0</span>;            ans[id].fm=<span class="hljs-number">1</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span>(q[i].l&lt;L)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=L<span class="hljs-number">-1</span>;j&gt;=q[i].l;j--)                update(j,<span class="hljs-number">1</span>);   <span class="hljs-comment">//区间增加</span>        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=L;j&lt;=q[i].l<span class="hljs-number">-1</span>;j++)                update(j,<span class="hljs-number">-1</span>);   <span class="hljs-comment">//区间减少</span>        &#125;        L=q[i].l;        <span class="hljs-keyword">if</span>(q[i].r&gt;R)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=R+<span class="hljs-number">1</span>;j&lt;=q[i].r;j++)                update(j,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=R;j&gt;=q[i].r+<span class="hljs-number">1</span>;j--)                update(j,<span class="hljs-number">-1</span>);        &#125;        R=q[i].r;        ans[id].fz=tot-(q[i].r-q[i].l+<span class="hljs-number">1</span>);        ans[id].fm=(ll)(q[i].r-q[i].l+<span class="hljs-number">1</span>)*(q[i].r-q[i].l);        ll temp=__gcd(ans[id].fz,ans[id].fm);        ans[id].fz/=temp;ans[id].fm/=temp;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld/%lld\n"</span>,ans[i].fz,ans[i].fm);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>一般来说只要update函数根据题意作出修改就行了，其他都差不多。</p><h5 id="小优化"><a href="#小优化" class="headerlink" title="小优化"></a>小优化</h5><p>如果l所在块的编号为奇数则按r升序排序，偶数则按r降序排序。 </p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(qnode x,qnode y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos[x.l]!=pos[y.l])        <span class="hljs-keyword">return</span> pos[x.l]&lt;pos[y.l];    <span class="hljs-keyword">if</span>(pos[x.l]&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> x.r&lt;y.r;    <span class="hljs-keyword">return</span> x.r&gt;y.r;&#125;</code></pre><h5 id="update"><a href="#update" class="headerlink" title="update"></a>update</h5><p>惊了 while循环比for跑得快！考虑到莫队算法是一个很暴力的算法，还是尽可能要优化代码，所以改进一哈。</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qnode</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> l,r,id;&#125;q[<span class="hljs-number">50010</span>];ll tot;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">anode</span></span><span class="hljs-class">&#123;</span>    ll fz,fm;&#125;ans[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> col[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> pos[<span class="hljs-number">50010</span>];<span class="hljs-comment">//在哪一块里（用来对询问排序）</span>ll num[<span class="hljs-number">50010</span>];<span class="hljs-comment">//当前每种颜色的数目</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(qnode x,qnode y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos[x.l]!=pos[y.l])<span class="hljs-keyword">return</span> pos[x.l]&lt;pos[y.l];    <span class="hljs-keyword">return</span> x.r&lt;y.r;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> d)</span></span><span class="hljs-function"></span>&#123;    tot-=num[col[id]]*num[col[id]];    num[col[id]]+=d;    tot+=num[col[id]]*num[col[id]];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">int</span> block=<span class="hljs-built_in">sqrt</span>(n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;col[i]);        pos[i]=(i<span class="hljs-number">-1</span>)/block;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;q[i].l,&amp;q[i].r);        q[i].id=i;    &#125;    sort(q+<span class="hljs-number">1</span>,q+<span class="hljs-number">1</span>+m,cmp);    <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(num));    <span class="hljs-keyword">int</span> L=<span class="hljs-number">1</span>,R=<span class="hljs-number">0</span>;    tot=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">int</span> id=q[i].id;        <span class="hljs-keyword">if</span>(q[i].l==q[i].r)        &#123;            ans[id].fz=<span class="hljs-number">0</span>;            ans[id].fm=<span class="hljs-number">1</span>;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">while</span>(L&gt;q[i].l)        &#123;            L--;            update(L,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">while</span>(L&lt;q[i].l)        &#123;            update(L,<span class="hljs-number">-1</span>);            L++;        &#125;        <span class="hljs-keyword">while</span>(R&lt;q[i].r)        &#123;            R++;            update(R,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">while</span>(R&gt;q[i].r)        &#123;            update(R,<span class="hljs-number">-1</span>);            R--;        &#125;        ans[id].fz=tot-(q[i].r-q[i].l+<span class="hljs-number">1</span>);        ans[id].fm=(ll)(q[i].r-q[i].l+<span class="hljs-number">1</span>)*(q[i].r-q[i].l);        ll temp=__gcd(ans[id].fz,ans[id].fm);        ans[id].fz/=temp;ans[id].fm/=temp;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld/%lld\n"</span>,ans[i].fz,ans[i].fm);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wannafly挑战赛19C 状压+dfs+容斥</title>
    <link href="/2018/07/18/Wannafly%E6%8C%91%E6%88%98%E8%B5%9B19C-%E7%8A%B6%E5%8E%8B-dfs-%E5%AE%B9%E6%96%A5/"/>
    <url>/2018/07/18/Wannafly%E6%8C%91%E6%88%98%E8%B5%9B19C-%E7%8A%B6%E5%8E%8B-dfs-%E5%AE%B9%E6%96%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有一棵树包含N个节点，节点编号从1到N。节点总共有K种颜色，颜色编号从1到K。第i个节点的颜色为<script type="math/tex">A_i</script>。</p><p><script type="math/tex">F_i</script>表示恰好包含i种颜色的路径数量。请计算：</p><p><script type="math/tex">\left(\sum_{i=1}^k(F_i*131^i)\right)\ mod\ (10^9+7)</script>。</p><p>其中<script type="math/tex">1≤N≤50000</script>，<script type="math/tex">1≤K≤10</script>。</p><p><strong>思路：</strong></p><p>做的时候完全无从下手QAQ</p><p>突破点是在这个k，由范围看出可以用状压，压什么呢？压路径中颜色的使用情况。</p><p>比如k=5，dp[10010]表示的就是路径中有第一种和第四种颜色的路径数（事实上表示的是只有第一种+只有第四种+恰好有第一种和第四种）。</p><p>那么知道了某一种状态，要如何求出路径数呢？</p><p>dfs一下，把有这些颜色的并连通的视为一个连通块，在连通块内部路径数为cnt*(cnt-1)/2（每两个不同的点之间一条路径），这里注意一个点也算一条路径，这个就放在最后进行计算。</p><p>所以枚举颜色的使用情况，进行dfs就可以算出dp。</p><p>之前括号里也说了这样子出来的dp表示的不是恰好有这些颜色的，而是有不超过这些颜色的路径总数。</p><p>所以这里就要用到容斥了。</p><p>ans表示的是恰好有这些颜色的路径数。</p><p>ans[111]</p><p>=dp[111]-ans[110]-ans[101]-ans[011]-ans[001]-ans[010]-ans[100]</p><p>=dp[111]-(dp[110]-dp[100]-dp[010])-(dp[101]-dp[100]-dp[001])-(dp[011]-dp[010]-dp[001])-dp[001]-dp[010]-dp[100]</p><p>=dp[111]-dp[110]-dp[101]-dp[011]+dp[001]+dp[010]+dp[100]</p><p>由此可以看出，如果子集和它相差的颜色是奇数的话，就减，如果相差的是偶数的话，就加。</p><p>最后再把一个结点的情况加上就可以了。</p><p>复杂度是<script type="math/tex">O(2^k*n)</script>。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll f[<span class="hljs-number">15</span>];<span class="hljs-keyword">int</span> col[<span class="hljs-number">50010</span>];ll dp[<span class="hljs-number">1500</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">50010</span>];<span class="hljs-keyword">bool</span> rcol[<span class="hljs-number">15</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">50010</span>];ll num[<span class="hljs-number">50010</span>];ll cnt=<span class="hljs-number">0</span>;ll ans[<span class="hljs-number">1500</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    vis[id]=<span class="hljs-literal">true</span>;    cnt++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[id][i];        <span class="hljs-keyword">if</span>(!vis[temp]&amp;&amp;rcol[col[temp]])            dfs(temp);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,k,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k);    f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)        f[i]=(f[i<span class="hljs-number">-1</span>]*<span class="hljs-number">131</span>)%MOD;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;col[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        v[x].push_back(y);        v[y].push_back(x);    &#125;    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;k);i++)    &#123;        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));        <span class="hljs-built_in">memset</span>(rcol,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(rcol));        cnt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>)&amp;i)            &#123;                rcol[j]=<span class="hljs-literal">true</span>;                cnt++;            &#125;        &#125;        num[i]=cnt;        <span class="hljs-comment">/*for(int i=1;i&lt;=k;i++)</span><span class="hljs-comment">            printf("%d ",rcol[i]);</span><span class="hljs-comment">        printf("\n");*/</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)        &#123;            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;rcol[col[j]])            &#123;                cnt=<span class="hljs-number">0</span>;                dfs(j);                <span class="hljs-comment">//printf("(%d %d %lld)\n",i,j,cnt);</span>                dp[i]+=(cnt*(cnt<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)%MOD;            &#125;        &#125;    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;(1&lt;&lt;k);i++)</span><span class="hljs-comment">        printf("%lld ",num[i]);</span><span class="hljs-comment">    printf("\n");</span><span class="hljs-comment">    for(int i=1;i&lt;(1&lt;&lt;k);i++)</span><span class="hljs-comment">        printf("%lld ",dp[i]);</span><span class="hljs-comment">    printf("\n");*/</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;k);i++)    &#123;        ans[i]=dp[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;k);j++)<span class="hljs-comment">//j是i的子集</span>        &#123;            <span class="hljs-keyword">if</span>((i|j)==i&amp;&amp;i!=j)            &#123;                <span class="hljs-comment">//printf("%d %d\n",i,j);</span>                <span class="hljs-keyword">if</span>((num[i]-num[j])%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)ans[i]=(ans[i]-dp[j]+MOD)%MOD;                <span class="hljs-keyword">else</span> ans[i]=(ans[i]+dp[j])%MOD;            &#125;        &#125;    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;(1&lt;&lt;k);i++)</span><span class="hljs-comment">        printf("%lld ",ans[i]);</span><span class="hljs-comment">    printf("\n");*/</span>    ll aans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;k);i++)        aans=(aans+(ans[i]*f[num[i]])%MOD)%MOD;    aans=(aans+n*f[<span class="hljs-number">1</span>])%MOD;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,aans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>总结：</strong></p><p>看到范围小的，可以想到状压也可以想到全排列。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宁夏邀请赛H &amp; 计蒜之道复赛A 贪心</title>
    <link href="/2018/07/18/%E5%AE%81%E5%A4%8F%E9%82%80%E8%AF%B7%E8%B5%9BH-%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%E5%A4%8D%E8%B5%9BA-%E8%B4%AA%E5%BF%83/"/>
    <url>/2018/07/18/%E5%AE%81%E5%A4%8F%E9%82%80%E8%AF%B7%E8%B5%9BH-%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%E5%A4%8D%E8%B5%9BA-%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h5 id="宁夏邀请赛H"><a href="#宁夏邀请赛H" class="headerlink" title="宁夏邀请赛H"></a>宁夏邀请赛H</h5><p><strong>题意：</strong></p><p>一个人去打n只怪兽，每只怪兽有HP值和ATK值，分别表示血量与对人造成的伤害，每次打的时候活着的所有怪兽都会对人造成伤害，对于一只怪兽来说，人第i次打它HP下降i。问人打完所有怪兽受到的最小伤害为多少。</p><p><strong>思路：</strong></p><p>打的次数事实上与HP并不是正相关的，所以要先算出每只怪兽要打几次。</p><p>考虑两只怪兽的时候，设打的次数分别为h1和h2，ATK值分别为a1和a2，要使先打第一只怪兽受到的伤害比较小，则有h1(a1+a2)+h2a2&lt;h2(a1+a2)+h1a1，化简后变成h1/a1&lt;h2/a2。</p><p>所以要按打的次数/ATK值从小到大排序。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    ll hp,atk;    <span class="hljs-keyword">double</span> val;&#125;a[<span class="hljs-number">100010</span>];ll suf[<span class="hljs-number">100010</span>];ll f[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x.val&lt;y.val;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> num;    f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;;i++)    &#123;        ll temp=(ll)i;        f[i]=temp*(temp+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(f[i]&gt;=<span class="hljs-number">100000</span>)        &#123;            num=i;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=num;i++)</span><span class="hljs-comment">        printf("%lld ",f[i]);</span><span class="hljs-comment">    printf("\n");*/</span>    <span class="hljs-keyword">return</span> num;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,num;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    num=init();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;a[i].hp,&amp;a[i].atk);            <span class="hljs-keyword">int</span> pos=lower_bound(f+<span class="hljs-number">1</span>,f+num+<span class="hljs-number">1</span>,a[i].hp)-f;            a[i].hp=pos;            a[i].val=<span class="hljs-number">1.0</span>*a[i].hp/a[i].atk;        &#125;        sort(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp);        suf[n+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)            suf[i]=suf[i+<span class="hljs-number">1</span>]+a[i].atk;        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            ans+=a[i].hp*suf[i];        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case #%d: %lld\n"</span>,kase,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="计蒜之道复赛A"><a href="#计蒜之道复赛A" class="headerlink" title="计蒜之道复赛A"></a>计蒜之道复赛A</h5><p><strong>题意：</strong></p><p>给你n个一次函数<script type="math/tex">f_i(x)=a_ix+b_i</script>，给出一个x，让你嵌套成一次函数的形式，一次函数可以任意改变顺序，求<script type="math/tex">f(f(f(...f(x))...))</script>的最大值。</p><p><strong>思路：</strong></p><p>同样是考虑两个变量的时候，设有<script type="math/tex">a_1,a_2,b_1,b_2</script>，要使<script type="math/tex">a_1(a_2x+b_2)+b1>a_2(a_1x+b_1)+b2</script>，化简得到<script type="math/tex">(a_1-1)/b_1>(a_2-1)/b_2</script>。所以按<script type="math/tex">(a-1)/b</script>从小到大排序，从里到外计算即可。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> a,b;&#125;num[<span class="hljs-number">10010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>*(<span class="hljs-number">1</span>-x.a)/x.b&gt;<span class="hljs-number">1.0</span>*(<span class="hljs-number">1</span>-y.a)/y.b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;x);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;num[i].a);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;num[i].b);        sort(num,num+n,cmp);        <span class="hljs-keyword">int</span> ans=x;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            ans=((ans*num[i].a)+num[i].b)%<span class="hljs-number">10</span>;            <span class="hljs-comment">//printf("%d\n",ans);</span>        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这两道题目都是从两项入手算出来的，而且这种条件是传递的。这是考虑贪心问题的一种方向。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces292D &amp; ACM训练联盟周赛D 前后缀并查集与无向图的连通分量</title>
    <link href="/2018/07/16/Codeforces292D-ACM%E8%AE%AD%E7%BB%83%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9BD-%E5%89%8D%E5%90%8E%E7%BC%80%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%8E%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <url>/2018/07/16/Codeforces292D-ACM%E8%AE%AD%E7%BB%83%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9BD-%E5%89%8D%E5%90%8E%E7%BC%80%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%8E%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h5 id="Codeforces292D"><a href="#Codeforces292D" class="headerlink" title="Codeforces292D"></a>Codeforces292D</h5><p><strong>题意：</strong></p><p>给出n个点和m条无向边，每条无向边依次编号为1～m，给出q次询问，问删去[l,r]这些边后连通分量个数。其中<script type="math/tex">2 ≤n≤ 500</script>，<script type="math/tex">1≤ m ≤10^4</script>，<script type="math/tex">1≤k≤ 2·10^4</script>。</p><p><strong>思路：</strong></p><p>并查集是可以用来求无向图连通分量的个数的：</p><p>并查集是指比如A和B是一类，A和C是一类，那么A、B、C为一类；</p><p>无向图的连通是指比如A和B连通，A和C连通，那么B和肯定也连通，A、B、C就为一个连通分量；</p><p>类比一下就知道是怎样操作的了。</p><p>删去[l,r]这些边肯定是很难操作的，所以还是考虑添边。</p><p>删去[l,r]这些边就相当于添上1～l-1和r+1～m这些边，所以可以想到要用前缀后缀并查集，即保存下每添一条边当时的par情况。</p><p>所以对于删掉[l,r]这些边来说，相当于把前l-1条边添好的情况x和后m-r条边添好的情况y来unite一下。</p><p>如何unite呢？</p><p>因为并查集肯定是在一个数组里面进行操作的，所以先另外开一个数组。先赋初值为x情况，然后遍历每个点，如果发现x情况和y情况点的par不同，就说明这两个par要进行合并，但是这个数组的初值是x情况的，所以要在新数组里把两个par合并，即unite(2,x,find(0,x,i),find(1,y,i)); 。</p><p>这样子做的复杂度是O(max(m,q)*n)，并不会爆炸，所以不用tarjan缩点直接做就可以了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> eg[<span class="hljs-number">10010</span>][<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> par[<span class="hljs-number">3</span>][<span class="hljs-number">10010</span>][<span class="hljs-number">510</span>];<span class="hljs-comment">//[0][][]表示前缀</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ps)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> id=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(ps==<span class="hljs-number">1</span>)id=m+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        par[ps][id][i]=i;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ps,<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[ps][id][x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> par[ps][id][x]=<span class="hljs-built_in">find</span>(ps,id,par[ps][id][x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ps,<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    x=<span class="hljs-built_in">find</span>(ps,id,x);y=<span class="hljs-built_in">find</span>(ps,id,y);    <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span>;    par[ps][id][x]=y;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">psunite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        par[<span class="hljs-number">2</span>][x][i]=par[<span class="hljs-number">0</span>][x][i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        unite(<span class="hljs-number">2</span>,x,<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>,x,i),<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>,y,i));    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>,x,i)==i)            ans++;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> q,l,r;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;eg[i][<span class="hljs-number">0</span>],&amp;eg[i][<span class="hljs-number">1</span>]);    init(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)            par[<span class="hljs-number">0</span>][i][j]=par[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>][j];        unite(<span class="hljs-number">0</span>,i,eg[i][<span class="hljs-number">0</span>],eg[i][<span class="hljs-number">1</span>]);    &#125;    init(<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m;i&gt;=<span class="hljs-number">1</span>;i--)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)            par[<span class="hljs-number">1</span>][i][j]=par[<span class="hljs-number">1</span>][i+<span class="hljs-number">1</span>][j];        unite(<span class="hljs-number">1</span>,i,eg[i][<span class="hljs-number">0</span>],eg[i][<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);    <span class="hljs-keyword">while</span>(q--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,psunite(l<span class="hljs-number">-1</span>,r+<span class="hljs-number">1</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="ACM训练联盟周赛D"><a href="#ACM训练联盟周赛D" class="headerlink" title="ACM训练联盟周赛D"></a>ACM训练联盟周赛D</h5><p><strong>题意：</strong></p><p>求最大的连通分量中的点数，其他同上。</p><p><strong>思路：</strong></p><p>在上题的基础上每次psunite之后计数每个点的par就可以求出最大的来连通分量中的点数了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> eg[<span class="hljs-number">10010</span>][<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> par[<span class="hljs-number">3</span>][<span class="hljs-number">10010</span>][<span class="hljs-number">510</span>];<span class="hljs-comment">//[0][][]表示前缀</span><span class="hljs-keyword">int</span> cnt[<span class="hljs-number">10010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ps)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> id=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(ps==<span class="hljs-number">1</span>)id=m+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        par[ps][id][i]=i;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ps,<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[ps][id][x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> par[ps][id][x]=<span class="hljs-built_in">find</span>(ps,id,par[ps][id][x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ps,<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    x=<span class="hljs-built_in">find</span>(ps,id,x);y=<span class="hljs-built_in">find</span>(ps,id,y);    <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span>;    par[ps][id][x]=y;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">psunite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        par[<span class="hljs-number">2</span>][x][i]=par[<span class="hljs-number">0</span>][x][i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        unite(<span class="hljs-number">2</span>,x,<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>,x,i),<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>,y,i));    <span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(cnt));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        cnt[<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>,x,i)]++;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        ans=<span class="hljs-built_in">max</span>(ans,cnt[i]);    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> q,l,r;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;eg[i][<span class="hljs-number">0</span>],&amp;eg[i][<span class="hljs-number">1</span>]);    init(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)            par[<span class="hljs-number">0</span>][i][j]=par[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>][j];        unite(<span class="hljs-number">0</span>,i,eg[i][<span class="hljs-number">0</span>],eg[i][<span class="hljs-number">1</span>]);    &#125;    init(<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m;i&gt;=<span class="hljs-number">1</span>;i--)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)            par[<span class="hljs-number">1</span>][i][j]=par[<span class="hljs-number">1</span>][i+<span class="hljs-number">1</span>][j];        unite(<span class="hljs-number">1</span>,i,eg[i][<span class="hljs-number">0</span>],eg[i][<span class="hljs-number">1</span>]);    &#125;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);    <span class="hljs-keyword">while</span>(q--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,psunite(l<span class="hljs-number">-1</span>,r+<span class="hljs-number">1</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACM训练联盟周赛C Nim+二进制思维+矩阵快速幂</title>
    <link href="/2018/07/16/ACM%E8%AE%AD%E7%BB%83%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9BC-Nim-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%9D%E7%BB%B4-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2018/07/16/ACM%E8%AE%AD%E7%BB%83%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9BC-Nim-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%80%9D%E7%BB%B4-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>三堆石子的数量分别为k，4k，5k，进行Nim博弈，问在k小于<script type="math/tex">2^n</script>的时候，有多少种情况先手一定会获得胜利。</p><p><strong>思路：</strong></p><p>这道题被我打表+OEIS水过了…</p><p>之后看了一下正解，是这样子的：</p><p>当k^4k^5k==0时，后手赢。</p><p>k^4k^5k=0可以化成k^4k=5k，</p><p>因为有k+4k=5k，而且4k是k的二进制形式左移两位，</p><p>两个数异或与相加的得数不同的情况只有1和1的时候。</p><p>所以k和k左移两位的数不能有都是1的某一位，即k的二进制形式每隔两个数不能都是1，比如1010这种是不行的。</p><p>那么如何得出递推式呢？</p><p>可以这样进行考虑：</p><p>设f(n)表示n位长度(总数为<script type="math/tex">2^{n-1}</script>)的满足上述条件的k的个数：</p><p>对于f(4)来说，肯定要加上f(3)，就相当于指的是最高位为0的所有情况，</p><p>因为第二位肯定不能为1，所以就忽略这一位，</p><p>然后加上f(2)，这指的是最高三位为100的所有情况，</p><p>然后还有可能出现最高三位为110的情况，但是因为这时候第二位也为1了，所以最后一位只能是0。</p><p>同理对于f(5)来说，肯定要加上f(4)，然后加上f(2)，表示的是最高三位为100的所有情况，然后还可能出现最高三位为110的情况，因为这时候第二位也为1，那么第四位只能为0，后面一位是随便的（只要内部合法即可），相当于加上f(1)。</p><p>同理对于f(6)来说，肯定要加上f(5)，然后加上f(3)，表示的是最高三位为110的所有情况，然后还可能出现最高三位为110的情况，因为这时第二位也为1，那么第四位只能为0，后面两位是随便的（只要这两位内部合法即可），相当于加上f(2)。</p><p>所以，f(n)=f(n-1)+f(n-3)+f(n-4)。</p><p>之后构造矩阵，快速幂就可算出后手赢的种数，总数减它就是前手赢的种数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU5649 二分+线段树</title>
    <link href="/2018/07/14/HDU5649-%E4%BA%8C%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2018/07/14/HDU5649-%E4%BA%8C%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给你一个序列，它是1～n的全排列，现在进行两种操作：</p><p>0 l r：把[l,r]从小到大排列；</p><p>1 l r：把[l,r]从大到小排列。</p><p>做完这些操作以后，请输出下标为k的数。</p><p><strong>思路：</strong></p><p>这道题挺巧妙的。</p><p>考虑到这只有一次查询操作，而且它是全排列的，所以可考虑二分，为什么可以二分呢？二分有什么用呢？我们后面来讲。</p><p>首先二分一个数mid（1～n），然后对于序列中小于它的数记为0，大于等于它的数记为1。</p><p>然后开始模拟操作了，这里用线段树实现：</p><p>对于升序操作：首先查询这个区间有多少个1，假设为x，然后把区间的前面部分修改为0，后面x个修改为1。</p><p>对于降序操作：首先查询这个区间有多少个1，假设为x，然后把区间的前面x个修改为1，后面部分修改为0。</p><p>做完这些操作以后，查询第k个位置是否是1，如果是1的话，说明第k个位置的数肯定是属于[mid,r]的，如果不是1的话，说明第k个位置的数是属于[1,mid-1]的，然后进行二分调整就可以了。</p><p>所以这棵线段树维护的是区间1的个数（即区间和）。</p><p>那么为什么可以二分呢？</p><p>这个二分更像是一种缩小范围的方式，我前面解释的时候就已经体现出来了，而且因为这个下标为k的数肯定是唯一的，所以肯定是可以找得到的。</p><p>再感叹一句，真的巧妙啊。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bitset&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> n,m,num,ans;<span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> left,right;    <span class="hljs-keyword">int</span> val;<span class="hljs-comment">//区间1的数量</span>    <span class="hljs-keyword">int</span> f;&#125;node[<span class="hljs-number">100010</span>&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> op[<span class="hljs-number">100000</span>][<span class="hljs-number">3</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    node[id].left=l;    node[id].right=r;    node[id].f=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span>(l==r)    &#123;        <span class="hljs-keyword">if</span>(a[num]&gt;=x)node[id].val=<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> node[id].val=<span class="hljs-number">0</span>;        <span class="hljs-comment">//printf("%d ",node[id].val);</span>        num++;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    build(l,m,id&lt;&lt;<span class="hljs-number">1</span>,x);    build(m+<span class="hljs-number">1</span>,r,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,x);    node[id].val=node[id&lt;&lt;<span class="hljs-number">1</span>].val+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l1=node[id&lt;&lt;<span class="hljs-number">1</span>].left;    <span class="hljs-keyword">int</span> r1=node[id&lt;&lt;<span class="hljs-number">1</span>].right;    <span class="hljs-keyword">int</span> l2=node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].left;    <span class="hljs-keyword">int</span> r2=node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].right;    node[id&lt;&lt;<span class="hljs-number">1</span>].f=node[id].f;    node[id&lt;&lt;<span class="hljs-number">1</span>].val=(r1-l1+<span class="hljs-number">1</span>)*node[id].f;    node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].f=node[id].f;    node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val=(r2-l2+<span class="hljs-number">1</span>)*node[id].f;    node[id].f=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        ans+=node[id].val;        <span class="hljs-comment">//printf("%d\n",node[id].val);</span>        <span class="hljs-comment">//if(L==2&amp;&amp;R==4)printf("[%d,%d]\n",l,r);</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f!=<span class="hljs-number">-1</span>)down(id);    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)query(L,R,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)query(L,R,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        node[id].val=(r-l+<span class="hljs-number">1</span>)*x;        node[id].f=x;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f!=<span class="hljs-number">-1</span>)down(id);    <span class="hljs-keyword">int</span> m=(l+r)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)update(L,R,id&lt;&lt;<span class="hljs-number">1</span>,x);    <span class="hljs-keyword">if</span>(R&gt;m)update(L,R,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,x);    node[id].val=node[id&lt;&lt;<span class="hljs-number">1</span>].val+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"></span>&#123;    num=<span class="hljs-number">1</span>;    build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,x);    <span class="hljs-comment">//printf("\n");</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">if</span>(op[i][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)<span class="hljs-comment">//升序</span>        &#123;            ans=<span class="hljs-number">0</span>;            query(op[i][<span class="hljs-number">1</span>],op[i][<span class="hljs-number">2</span>],<span class="hljs-number">1</span>);            <span class="hljs-comment">//printf("q%d:%d\n",i,ans);</span>            update(op[i][<span class="hljs-number">1</span>],op[i][<span class="hljs-number">2</span>]-ans,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);            <span class="hljs-comment">//printf("(%d,%d)\n",op[i][1],op[i][2]-ans);</span>            update(op[i][<span class="hljs-number">2</span>]-ans+<span class="hljs-number">1</span>,op[i][<span class="hljs-number">2</span>],<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);            <span class="hljs-comment">//printf("(%d,%d)\n",op[i][2]-ans+1,op[i][2]);</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op[i][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>)        &#123;            ans=<span class="hljs-number">0</span>;            query(op[i][<span class="hljs-number">1</span>],op[i][<span class="hljs-number">2</span>],<span class="hljs-number">1</span>);            <span class="hljs-comment">//printf("q%d:%d\n",i,ans);</span>            update(op[i][<span class="hljs-number">1</span>],op[i][<span class="hljs-number">1</span>]+ans<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);            <span class="hljs-comment">//printf("(%d,%d)\n",op[i][1],op[i][1]+ans-1);</span>            update(op[i][<span class="hljs-number">1</span>]+ans,op[i][<span class="hljs-number">2</span>],<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);            <span class="hljs-comment">//printf("(%d,%d)\n",op[i][1]+ans,op[i][2]);</span>        &#125;    &#125;    ans=<span class="hljs-number">0</span>;    query(k,k,<span class="hljs-number">1</span>);    <span class="hljs-comment">//printf("ans=%d\n",ans);</span>    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,k;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;op[i][<span class="hljs-number">0</span>],&amp;op[i][<span class="hljs-number">1</span>],&amp;op[i][<span class="hljs-number">2</span>]);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;k);        <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=n;        <span class="hljs-keyword">while</span>(l&lt;=r)        &#123;            <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-comment">//printf("mid=%d\n",mid);</span>            <span class="hljs-keyword">if</span>(judge(mid,k))l=mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,l<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces906D &amp; 牛客练习赛22E 扩展欧拉定理</title>
    <link href="/2018/07/14/CodeForces906D-%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    <url>/2018/07/14/CodeForces906D-%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h5 id="CodeForces906D"><a href="#CodeForces906D" class="headerlink" title="CodeForces906D"></a>CodeForces906D</h5><p><strong>题意：</strong></p><p>给定一个数列<script type="math/tex">w_1,w_2,...,w_n</script>和模数p,每次询问一个区间[l,r],求<script type="math/tex">{\,{w_l}^{\,{w_{l+1}\,}^{\,{w_{l+2}\,}^{...^{w_r}\,}\,}\,}\,}mod\ p</script>的值。其中<script type="math/tex">1<=w_k<=10^9</script>，<script type="math/tex">1<=q<=10^5</script>。</p><p><strong>思路：</strong></p><p>有扩展欧拉定理：</p><script type="math/tex; mode=display">a^n≡\begin{cases}a^{n\ mod\ \varphi(m)} & \gcd(a, m) = 1\\a^{n} & \gcd(a, m) \ne 1 \text{ 且 } n < \varphi(m)\\a^{n \bmod \varphi(m) + \varphi(m)} & \gcd(a, m) \ne 1 \text{ 且 } n \ge \varphi(m)\end{cases}\pmod {m}</script><p>由欧拉定理，有<script type="math/tex">a^{\varphi(m)} \equiv 1 \pmod{m}</script>，所以上式可以简单记为：</p><p><script type="math/tex">a^n \equiv\begin{cases}a^{n} & n < \varphi(m)\\a^{n \bmod\varphi(m) + \varphi(m)} & n \ge \varphi(m)\end{cases}\pmod {m}</script>，</p><p>即<script type="math/tex">a^n\ mod\ m=a^{n\ mod\ \varphi(m)+(n>\varphi(m)?\varphi(m):0)}mod\ m</script>。</p><p>比如<script type="math/tex">a^{b^{c^d}}\ mod\ m=a^{b^{c^d}\ mod\ \varphi(m)+(b^{c^d}>\varphi(m)?\varphi(m):0)}\ mod\ m</script>，</p><p>其中<script type="math/tex">b^{c^d}\ mod\ \varphi(m)=b^{c^d\ mod\ \varphi(\varphi(m))+(c^d>\varphi(\varphi(m))?\varphi(\varphi(m)):0)}\ mod\ \varphi(m)</script>，</p><p>其中<script type="math/tex">c^d\ mod\ \varphi(\varphi(m))=c^{d\ mod\ \varphi(\varphi(\varphi(m)))+(d>\varphi(\varphi(\varphi(m)))?\varphi(\varphi(\varphi(m))):0)} \ mod\  \varphi(\varphi(m))</script>。</p><p>可以一直递归下去，<script type="math/tex">b^{c^d}\ mod\ \varphi(m)</script>可以递归处理。</p><p>如果l==r的时候，返回的是<script type="math/tex">d\ mod\ \varphi(\varphi(\varphi(m)))+(d>\varphi(\varphi(\varphi(m)))?\varphi(\varphi(\varphi(m))):0)</script>。</p><p>所以定义一个新的Mod方式：a&lt;b?a:a%b+b。</p><p>递归的终点就是Mod(a[l],mod)。</p><p>如果<script type="math/tex">φ(φ(φ(⋯(n))))=1</script>，那么嵌套层数为<script type="math/tex">O(logn)</script>。</p><p>如果<script type="math/tex">φ(m)=1</script>了，那么可以在第二个式子返回0，之后都不用再继续递归了，这也是一个递归终点。</p><p>回溯的时候就可以用快速幂来计算了，比如先回溯到第三个式子，用正常的快速幂是ojbk的，但是回溯到第二个式子的时候会发现只计算了<script type="math/tex">c^d\ mod\ \varphi(\varphi(m))</script>这一部分，无法判断<script type="math/tex">c^d>\varphi(\varphi(m))</script>，所以用新定义的Mod方式来进行快速幂运算，这样子每次在函数中调用快速幂的时候得到的就是<script type="math/tex">c^d\ mod\ \varphi(\varphi(m))+(c^d>\varphi(\varphi(m))?\varphi(\varphi(m)):0)</script>整个的值啦，体现在式子里面就相当于改变了<script type="math/tex">c^d\ mod\ \varphi(\varphi(m))</script>这个快速幂的方式，那么返回的就是整个上上式的值啦。</p><p>注意计算<script type="math/tex">\varphi(m)</script>的时候要记忆化。</p><p>这里有个坑点，求<script type="math/tex">φ(n)</script>的时候，如果调用参数列表里的参数的话会TLE，如果自己在函数内部传个参，就不会TLE了，为什么时间差这么多这是什么玄学啊，难道用函数内部的变量更快？这还是第一次见这种状况。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Mod(a,b) a&lt;b?a:a%b+b</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> n,l,r,q;ll m;ll a[<span class="hljs-number">100100</span>];<span class="hljs-built_in">map</span>&lt;ll,ll&gt;phi;<span class="hljs-function">ll <span class="hljs-title">euler</span><span class="hljs-params">(ll n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(phi[n]!=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> phi[n];    ll i,res=n;    ll temp=res;<span class="hljs-comment">//传个参就不会TLE了???(迷</span>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)        &#123;            res=res/i*(i<span class="hljs-number">-1</span>);            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)                n=n/i;        &#125;    &#125;    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)res=res/n*(n<span class="hljs-number">-1</span>);    phi[temp]=res;<span class="hljs-comment">//直接phi[n]会TLE</span>    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">ll <span class="hljs-title">PowerMod</span><span class="hljs-params">(ll a,ll b,ll c)</span></span><span class="hljs-function"></span>&#123;    ll ans=<span class="hljs-number">1</span>;    a=Mod(a,c);    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)            ans=Mod(ans*a,c);        b&gt;&gt;=<span class="hljs-number">1</span>;        a=Mod(a*a,c);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,ll mod)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l==r||mod==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> Mod(a[l],mod);    <span class="hljs-keyword">return</span> PowerMod(a[l],solve(l+<span class="hljs-number">1</span>,r,euler(mod)),mod);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%lld"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);    <span class="hljs-keyword">while</span>(q--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(l,r,m)%m);<span class="hljs-comment">//记得这里还是要%m</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="牛客练习赛22E"><a href="#牛客练习赛22E" class="headerlink" title="牛客练习赛22E"></a>牛客练习赛22E</h5><p><strong>题意：</strong></p><p>多了一个区间[l,r]加上x的操作，每次查询的模p也在改变(p &lt;= 2e7)。</p><p><strong>思路：</strong></p><p>套个树状数组或者线段树都可以，这里要先线性筛出欧拉函数。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Mod(a,b) a&lt;b?a:a%b+b</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> n;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 20000001</span>ll eu[MAXN];ll pri[MAXN];<span class="hljs-keyword">bool</span> vis[MAXN];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    eu[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    ll cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;MAXN;i++)    &#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;pri[cnt++]=i;eu[i]=i<span class="hljs-number">-1</span>;&#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt&amp;&amp;pri[j]*i&lt;MAXN;j++)        &#123;            vis[i*pri[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%pri[j]==<span class="hljs-number">0</span>)            &#123;                eu[i*pri[j]]=eu[i]*pri[j];                <span class="hljs-keyword">break</span>;            &#125;            eu[i*pri[j]]=eu[i]*(pri[j]<span class="hljs-number">-1</span>);        &#125;    &#125;&#125;ll c[<span class="hljs-number">500010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    ll res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        res+=c[x];        x-=lowbit(x);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,ll v)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(x&lt;=n)    &#123;        c[x]+=v;        x+=lowbit(x);    &#125;&#125;<span class="hljs-function">ll <span class="hljs-title">PowerMod</span><span class="hljs-params">(ll a,ll b,ll c)</span></span><span class="hljs-function"></span>&#123;    ll ans=<span class="hljs-number">1</span>;    a=Mod(a,c);    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)            ans=Mod(ans*a,c);        b&gt;&gt;=<span class="hljs-number">1</span>;        a=Mod(a*a,c);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,ll mod)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l==r||mod==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> Mod(query(l),mod);    <span class="hljs-keyword">return</span> PowerMod(query(l),solve(l+<span class="hljs-number">1</span>,r,eu[mod]),mod);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l,r,q,op;    ll m;    init();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;q);    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(c));    ll ls=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;m);        add(i,m-ls);        ls=m;    &#125;    <span class="hljs-keyword">while</span>(q--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%lld"</span>,&amp;op,&amp;l,&amp;r,&amp;m);        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)        &#123;            add(l,m);            add(r+<span class="hljs-number">1</span>,-m);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(l,r,m)%m);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ515 &amp; 51nod1573 Bitset乱搞</title>
    <link href="/2018/07/13/LOJ515-51nod1573-Bitset%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2018/07/13/LOJ515-51nod1573-Bitset%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h5 id="LOJ515"><a href="#LOJ515" class="headerlink" title="LOJ515"></a>LOJ515</h5><p><strong>题意：</strong></p><p>一共有n个数，第i个数<script type="math/tex">x_i​</script>可以取<script type="math/tex">[a_i,b_i]​</script>中任意值。 设<script type="math/tex">S=\sum{x_i^2}​</script>，求S种类数。其中<script type="math/tex">1≤n,a_i,b_i≤100​</script>。</p><p><strong>思路：</strong></p><p>刚开始想到的是DP，但是100^4会爆炸，所以就用bitset来暴力一下。</p><p>每一位表示的是有没有该答案，这是一个集合，如果这个集合中的每个数要与一个数x相加怎么办呢？就是把这个集合左移x位然后再与集合或运算就可以了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-built_in">bitset</span>&lt;1000100&gt;ans[<span class="hljs-number">110</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,l,r;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    ans[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=l;j&lt;=r;j++)            ans[i]|=ans[i<span class="hljs-number">-1</span>]&lt;&lt;(j*j);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans[n].count());    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="51nod1573"><a href="#51nod1573" class="headerlink" title="51nod1573"></a>51nod1573</h5><p><strong>题意：</strong></p><p>我们现在有n个多重集合，第i个集合最开始都有一个元素ai(1≤i≤n)。</p><p>一个多重集合的价值为子集中不同的和的个数。</p><p>例如一个多重集合{1,2}，那么会存在有4个不同的和{0,1,2,3}。其价值为4。</p><p>一个多重集合{2,2}，那么会有3个不同的和{0,2,4},其价值为3。</p><p>现在我们有两种操作：</p><p>1、合并最开始时多重集合i现在所在的多重集合与多重集合j现在所在的多重集合，成为一个新的多重集合。</p><p>2、询问最开始多重集合i现在所在多重集合的价值。</p><p>数据保证合并两个最开始时的多重集合所在的多重集合时它们当前不是同一个多重集合。</p><p><strong>思路：</strong></p><p>用并查集来进行启发式合并（小的并到大的），对于每个集合元素都存在一个vector里，如果i所在的集合要和j所在的集合合并了，先找到i和j各自的根，对于小的那个集合，每个元素放到大的那个vector里，每个小的集合里的元素和大的集合相加（左移x）。询问的时候找根然后把1的个数输出即可。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> par[<span class="hljs-number">1010</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">1010</span>];<span class="hljs-built_in">bitset</span>&lt;100010&gt;a[<span class="hljs-number">1010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> par[x]=Find(par[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(v[x].<span class="hljs-built_in">size</span>()&lt;v[y].<span class="hljs-built_in">size</span>())swap(x,y);   <span class="hljs-comment">//y合并到x</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[y].<span class="hljs-built_in">size</span>();i++)    &#123;        v[x].push_back(v[y][i]);        a[x]|=(a[x]&lt;&lt;v[y][i]);    &#125;    <span class="hljs-comment">//cout&lt;&lt;a[x]&lt;&lt;endl;</span>    par[y]=x;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,x,q,op,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        a[i].<span class="hljs-built_in">set</span>(<span class="hljs-number">0</span>);a[i].<span class="hljs-built_in">set</span>(x);        par[i]=i;        v[i].push_back(x);    &#125;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);    <span class="hljs-keyword">while</span>(q--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;op);        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);            x=Find(x);y=Find(y);            Unite(x,y);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            x=Find(x);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,a[x].count());        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>类似集合合并，或者每个状态就是01(yes or no)的题目，可以考虑用bitset来搞。复杂度可以降低到原来的1/32或者1/64（视计算机而定）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCPC2015D 贪心+DFS</title>
    <link href="/2018/07/13/GCPC2015D-%E8%B4%AA%E5%BF%83-DFS/"/>
    <url>/2018/07/13/GCPC2015D-%E8%B4%AA%E5%BF%83-DFS/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给你一个w*h的区域，给你n个不同的地毯，告诉你每个地毯的长宽，让你把区域铺满，地毯可以旋转，不能重叠，不能剪小。问你能不能铺满。其中1≤wi≤100;1≤hi≤100;1≤n≤7。</p><p><strong>思路：</strong></p><p>这属于小规模的平铺类搜索。</p><p>平铺：不允许重叠，将给出的一些方块（最容易处理的是长方形了）放置在一个目标区域内。</p><p>小规模：要放置的方块数量&lt;10，放置的目标区域的边长&lt;=100。</p><p>贪心策略是找到带有空闲单元格的最顶行，然后选择最左边的单元格。</p><p>然后搜一下就可以了。</p><p>我太菜了这种DFS不会写QAQ</p><p>然后学习了一下标程再写的QAQ</p><p>当然还有一种方法是全排列一下，根据顺序来放。</p><p>还是讲一下这深搜是怎么写的吧（每次写这种DFS就无从下手的感觉</p><p>先确定两个参数，x,y表示当前开始铺的位置。</p><p>枚举地毯，这里旋转用了swap，可以让代码简洁一点，如果这个地毯没有被用过，就验证一下能不能放（放了以后越界而且覆盖的地方之前都没有被铺过）。</p><p>如果可以放，就放进去，递归调用dfs(x+a,y)，因为要尽量从最左上放，所以y不动，x+a，如果后面这样放是可以的就返回true，不行的话回溯，把标记还原。</p><p>还要注意dfs里边界条件，如果x为w的话就铺下一行，如果y为h就返回true，如果这个单元格被铺过了的话就铺左边一个。</p><p>写DFS的时候就心里觉得调起来肯定很麻烦就不敢写，这样不行，写之前细节都想想好，会好一点。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> w,h,c;<span class="hljs-keyword">bool</span> mp[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> a,b,cnt;&#125;carp[<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//printf("%d,%d\n",x,y);</span>    <span class="hljs-keyword">if</span>(x==w)&#123;<span class="hljs-comment">/*printf("!\n");*/</span><span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,y+<span class="hljs-number">1</span>);&#125;    <span class="hljs-keyword">if</span>(y==h)&#123;<span class="hljs-comment">/*printf("?\n");*/</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;    <span class="hljs-keyword">if</span>(mp[x][y])&#123;<span class="hljs-comment">/*printf(".\n");*/</span><span class="hljs-keyword">return</span> dfs(x+<span class="hljs-number">1</span>,y);&#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;c;i++)    &#123;        <span class="hljs-keyword">if</span>(carp[i].cnt&gt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">int</span> cura=carp[i].a,curb=carp[i].b;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)            &#123;                swap(cura,curb);                <span class="hljs-keyword">if</span>(x+cura&gt;w)<span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>(y+curb&gt;h)<span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;cura&amp;&amp;sign==<span class="hljs-number">0</span>;k++)                &#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l&lt;curb&amp;&amp;sign==<span class="hljs-number">0</span>;l++)                    &#123;                        <span class="hljs-keyword">int</span> curx=x+k,cury=y+l;                        <span class="hljs-keyword">if</span>(mp[curx][cury])sign++;                    &#125;                &#125;                <span class="hljs-keyword">if</span>(sign!=<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;                carp[i].cnt--;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;cura;k++)                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l&lt;curb;l++)                    &#123;                        <span class="hljs-keyword">int</span> curx=x+k,cury=y+l;                        mp[curx][cury]=<span class="hljs-literal">true</span>;                    &#125;                <span class="hljs-keyword">if</span>(dfs(x+cura,y))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                carp[i].cnt++;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;cura;k++)                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l&lt;curb;l++)                    &#123;                        <span class="hljs-keyword">int</span> curx=x+k,cury=y+l;                        mp[curx][cury]=<span class="hljs-literal">false</span>;                    &#125;                <span class="hljs-keyword">if</span>(cura==curb)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;w,&amp;h);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;c);    <span class="hljs-built_in">memset</span>(mp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(mp));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;c;i++)       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;carp[i].cnt,&amp;carp[i].a,&amp;carp[i].b);    <span class="hljs-keyword">if</span>(dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<span class="hljs-built_in">printf</span>(<span class="hljs-string">"yes\n"</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"no\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旅行商问题</title>
    <link href="/2018/07/12/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"/>
    <url>/2018/07/12/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>旅行商问题就是每个点都要走到，一般用DP解决。</p><p>避免调太久存个模板。</p><p>点的编号为1～m。</p><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(dp,INF,<span class="hljs-keyword">sizeof</span>(dp));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;    dp[<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>)][i]=<span class="hljs-number">0</span>;    <span class="hljs-comment">//printf("(%d,%d)\n",1&lt;&lt;(i-1),i);</span>&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;m);i++)    <span class="hljs-comment">//两个循环的次序不能交换</span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)    &#123;        <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))&amp;i)        &#123;            <span class="hljs-comment">/*printf("i=%d j=%d|",i,j);</span><span class="hljs-comment">            for(int l=m-1;l&gt;=0;l--)</span><span class="hljs-comment">                printf("%d",i&gt;&gt;l&amp;1);</span><span class="hljs-comment">            printf("\n");*/</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=m;k++)            &#123;                <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;(k<span class="hljs-number">-1</span>))&amp;i)&amp;&amp;k!=j&amp;&amp;dis[k][j]!=<span class="hljs-number">-1</span>)                &#123;                    <span class="hljs-keyword">int</span> temp=i-(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>));                    <span class="hljs-comment">//printf("k=%d|",k);</span>                    <span class="hljs-comment">/*for(int l=m-1;l&gt;=0;l--)</span><span class="hljs-comment">                        printf("%d",temp&gt;&gt;l&amp;1);</span><span class="hljs-comment">                    printf("\n");*/</span>                    dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j],dp[temp][k]+dis[k][j]);                    <span class="hljs-comment">//printf("dp[%d][%d]=%d\n",i,j,dp[i][j]);</span>                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">int</span> ans=INF;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    ans=<span class="hljs-built_in">min</span>(ans,dp[(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>][i]);<span class="hljs-keyword">if</span>(ans==INF)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BAPC2014FinalA 按时间拆点+最大流</title>
    <link href="/2018/07/11/BAPC2014FinalA-%E6%8C%89%E6%97%B6%E9%97%B4%E6%8B%86%E7%82%B9-%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <url>/2018/07/11/BAPC2014FinalA-%E6%8C%89%E6%97%B6%E9%97%B4%E6%8B%86%E7%82%B9-%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n个地点，有g个人要去医院疗伤，他们最开始在in，在T时间内要到m个医院的某一个，有m条x到y的有向边，每条边<u>每个单位时间</u>可以通过pi人，走到这里需要ti个单位时间。</p><p>人可以停留在任意一个点，求最多能有多少人到达医院。</p><hr><p><strong>思路：</strong></p><p>可以看出是一道最大流。</p><p>那么如何建图呢？</p><p>按时间拆点，比如n=4，t=5拆成：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1ft60um0qqmj31kw0u9azs.jpg" srcset="/img/loading.gif" alt="D0C21661627A509C720A76B99CB28BCA"></p><p>超级源点向初始地点连边，容量为g，表示0时刻初始人数为g。</p><p>每个点的时刻向下个时刻连边，容量为INF/g，表示可以原地不动。</p><p>每个医院向超级汇点连边，容量为INF，表示一到医院就无限停留到汇点。</p><p>对于x到y的一条边，每个t的x向t+ti的y连边，容量为pi，表示在t时刻有pi个人可以从x到y，到达y的时间为t+ti。</p><p>其他就是要注意数组的大小。</p><p>每次做完网络流就觉得妙啊。</p><hr><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> s,e;<span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">10000100</span>];<span class="hljs-keyword">int</span> head[<span class="hljs-number">200100</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">200100</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">200100</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s;i&lt;=e;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("/Users/apple/Downloads/problemset/testdata/A.in","r",stdin);</span>    <span class="hljs-keyword">int</span> t,n,in,g,k,m,x,r,a,b,p,tt;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;in,&amp;g,&amp;k);        top=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));        s=<span class="hljs-number">0</span>;e=(k+<span class="hljs-number">1</span>)*n+<span class="hljs-number">1</span>;        add(s,in,g);        add(in,s,<span class="hljs-number">0</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);        <span class="hljs-keyword">while</span>(m--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=k;i++)            &#123;                add(x+i*n,e,g);                add(e,x+i*n,<span class="hljs-number">0</span>);            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;k;j++)            &#123;                add(i+j*n,i+(j+<span class="hljs-number">1</span>)*n,g);                add(i+(j+<span class="hljs-number">1</span>)*n,i+j*n,<span class="hljs-number">0</span>);            &#125;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;r);        <span class="hljs-keyword">while</span>(r--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;a,&amp;b,&amp;p,&amp;tt);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i+tt&lt;=k;i++)            &#123;                add(a+i*n,b+(i+tt)*n,p);                add(b+(i+tt)*n,a+i*n,<span class="hljs-number">0</span>);            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,<span class="hljs-built_in">min</span>(dinic(),g));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BAPC2014FinalK 折半搜索（中途相遇法）</title>
    <link href="/2018/07/11/BAPC2014FinalK-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/"/>
    <url>/2018/07/11/BAPC2014FinalK-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>n个人做m道题目，给出n个人的答案，已知每个人对了几道，求正确答案有几种情况，如果只有一种，就输出那种方案。(1≤n≤12,1≤m≤30)</p><p><strong>思路：</strong></p><p>如果直接枚举的话有2^30种情况，这样肯定是不行的，如果m/2的话就可以，所以可以考虑折半搜索。</p><p>枚举前半段的正确答案，把每个人后半段正确的数量放在vector里存起来（总正确的-前半段正确的），然后把这种情况放在map里，因为可能要输出答案，所以map的second要放两个东西，一个是这个vector的出现的情况次数和出现的情况是什么样的（之前枚举的正确答案）。</p><p>然后对于后半段，枚举后半段的正确答案，每个人的正确题数放在vector之后在map里找，如果有相同的话就ans+=出现这个情况的次数。</p><p>最后输出答案就可以了，如果要拼起来的话就拼起来。</p><p>这就实现了复杂度的降低，本来要2^30的，现在只要2^15*2。</p><p>这里map如何实现查找呢？</p><p>可以利用auto，查找的时候用auto的find函数，如果找不到的话返回map.end()（最后一个元素的后面一个元素）。</p><p>这里vector还有一个优化，用指定长度的方式，直接用下标访问实现覆盖，会快一点。</p><p>下次看到选或不选n/2可以枚举的就可以试试折半搜索这种方式。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> ans[<span class="hljs-number">35</span>];    <span class="hljs-keyword">int</span> num;&#125;a[<span class="hljs-number">15</span>];<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt;mp;<span class="hljs-comment">//个数/答案</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a[i].ans);            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i].num);        &#125;        mp.<span class="hljs-built_in">clear</span>();        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v(n);        <span class="hljs-comment">//[0,m/2-1]</span>        <span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m/<span class="hljs-number">2</span>;i++)            tot*=<span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;i++)<span class="hljs-comment">//正确答案</span>        &#123;            <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n&amp;&amp;sign==<span class="hljs-number">0</span>;j++)            &#123;                <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//正确的题数</span>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;m/<span class="hljs-number">2</span>;k++)                &#123;                    <span class="hljs-keyword">int</span> temp=(i&gt;&gt;k)&amp;<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(temp==a[j].ans[k]-<span class="hljs-string">'0'</span>)cnt++;                &#125;                <span class="hljs-keyword">if</span>(cnt&lt;=a[j].num)v[j]=a[j].num-cnt;                <span class="hljs-keyword">else</span> sign++;            &#125;            <span class="hljs-keyword">if</span>(sign==<span class="hljs-number">0</span>)            &#123;                mp[v].first++;                mp[v].second=i;                <span class="hljs-comment">/*for(int j=0;j&lt;m/2;j++)</span><span class="hljs-comment">                 printf("%d",i&gt;&gt;j&amp;1);</span><span class="hljs-comment">                 printf(" ");</span><span class="hljs-comment">                 for(int j=0;j&lt;v.size();j++)</span><span class="hljs-comment">                 printf("%d ",v[j]);</span><span class="hljs-comment">                 printf("\n");*/</span>            &#125;        &#125;        <span class="hljs-comment">//[m/2,m-1]</span>        <span class="hljs-keyword">int</span> ccnt=<span class="hljs-number">0</span>,ans1=<span class="hljs-number">0</span>,ans2=<span class="hljs-number">0</span>;        tot=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m-m/<span class="hljs-number">2</span>;i++)<span class="hljs-comment">//!!!注意是m-m/2</span>            tot*=<span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;tot;i++)        &#123;            <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n&amp;&amp;sign==<span class="hljs-number">0</span>;j++)            &#123;                <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=m/<span class="hljs-number">2</span>;k&lt;=m<span class="hljs-number">-1</span>;k++)                &#123;                    <span class="hljs-keyword">int</span> temp=(i&gt;&gt;(k-m/<span class="hljs-number">2</span>))&amp;<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(temp==a[j].ans[k]-<span class="hljs-string">'0'</span>)cnt++;                &#125;                <span class="hljs-keyword">if</span>(cnt&lt;=a[j].num)v[j]=cnt;                <span class="hljs-keyword">else</span> sign++;            &#125;            <span class="hljs-keyword">if</span>(sign==<span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">auto</span> it=mp.<span class="hljs-built_in">find</span>(v);                <span class="hljs-keyword">if</span>(it!=mp.<span class="hljs-built_in">end</span>())                &#123;                    ccnt+=it-&gt;second.first;                    ans1=it-&gt;second.second;                    ans2=i;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span>(ccnt!=<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d solutions\n"</span>,ccnt);        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m/<span class="hljs-number">2</span>;i++)                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,ans1&gt;&gt;i&amp;<span class="hljs-number">1</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m-m/<span class="hljs-number">2</span>;i++)                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,ans2&gt;&gt;i&amp;<span class="hljs-number">1</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BAPC2014FinalE 线段树</title>
    <link href="/2018/07/10/BAPC2014-finalE-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2018/07/10/BAPC2014-finalE-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n个人，给出n个人在三个项目中的排名，要选出一些候选人，要求不是候选人里面没有比候选人三项都好的人。</p><p><strong>思路：</strong></p><p>理解能力是硬伤啊QAQ</p><p>这题目的意思是比如3 9 7和5 10 8，其中3 9 7每一项都比5 10 8好，所以5 10 8肯定不是候选人。</p><p>就是如果存在三项都比它好的人，那么这个人就肯定不是候选人。</p><p>假设三个项目排名分别是x,y,z。</p><p>所以可以先把所有人根据x排序，那么就满足了对于当前人，前面所有人的第一项排名都比他高。</p><p>那后面两项呢？可以用RMQ来做，对于当前这个人查询1～y-1看其中的最小值是不是比他小，这既满足了y比他小，而且z也比他小。然后把这个人插入到序列里，即a[y]=z。</p><p>这里这个RMQ我是用线段树实现的。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> ans;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> x,y,z;&#125;a[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x.x&lt;y.x;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> left,right,val;&#125;node[<span class="hljs-number">100010</span>&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> id)</span>   <span class="hljs-comment">//建树</span></span><span class="hljs-function"></span>&#123;    node[id].left=l;    node[id].right=r;    <span class="hljs-keyword">if</span>(l==r)    &#123;        node[id].val=n+<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    build(l,m,id&lt;&lt;<span class="hljs-number">1</span>);    build(m+<span class="hljs-number">1</span>,r,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    node[id].val=<span class="hljs-built_in">min</span>(node[id&lt;&lt;<span class="hljs-number">1</span>].val,node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loc,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> id)</span>   <span class="hljs-comment">//单点修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l==r)    &#123;        node[id].val=c;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(loc&lt;=m)update(loc,c,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">else</span> update(loc,c,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    node[id].val=<span class="hljs-built_in">min</span>(node[id&lt;&lt;<span class="hljs-number">1</span>].val,node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span>   <span class="hljs-comment">//区间查询</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        <span class="hljs-comment">//printf("val=%d\n",node[id].val);</span>        ans=<span class="hljs-built_in">min</span>(ans,node[id].val);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)query(L,R,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)query(L,R,(id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;a[i].x,&amp;a[i].y,&amp;a[i].z);        sort(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp);        build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            ans=INF;            query(<span class="hljs-number">1</span>,a[i].y<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>);            <span class="hljs-comment">//printf("i=%d ans=%d\n",i,ans);</span>            <span class="hljs-keyword">if</span>(ans&lt;a[i].z)tot++;            update(a[i].y,a[i].z,<span class="hljs-number">1</span>);            <span class="hljs-comment">//printf("pos[%d]=%d\n",a[i].y,a[i].z);</span>        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,n-tot);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wannafly挑战赛19B DP+单调队列</title>
    <link href="/2018/07/09/Wannafly%E6%8C%91%E6%88%98%E8%B5%9B19B-DP-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2018/07/09/Wannafly%E6%8C%91%E6%88%98%E8%B5%9B19B-DP-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>矩阵M包含R行C列。</p><p>请寻找一个子矩阵，使得这个子矩阵的和最大，且满足以下三个条件：</p><p>子矩阵的行数不能超过X行。</p><p>子矩阵的列数不能超过Y列。</p><p>子矩阵中0的个数不能超过Z个。</p><p>请输出满足以上条件的最大子矩阵和。</p><p><strong>思路：</strong></p><p>首先考虑一个问题：求一个序列的长度不超过m的最大连续子序列。</p><script type="math/tex; mode=display">dp[i]:以i为结尾的长度不超过m的最大连续子序列。</script><p>利用前缀和可知，<script type="math/tex">dp[i]=pre[i]-pre[k],1<=k<=i-1</script>。</p><p>pre[i]是确定的，想让dp[i]尽可能大，就得让pre[k]尽可能小。</p><p>所以可以用一个单调队列来维护pre[k]的最小值。</p><p>单调队列如何维护呢？</p><p>让这个单调队列保持从队首到队尾从小到大，因为长度不能超过m，所以如果队首的id比当前大m以上的话，就要弹出，然后把自己加入到这个队列里面，若它破坏了原队列的单调性，那么删除队尾元素，并继续比较队尾与新元素，直到找到一个队尾小于新元素时，将新元素插入到队尾。被删除的元素既比新元素小，又会比新元素先超出m，因此肯定不会成为答案。这个操作不断维护了队列中的最值。</p><p>再来看这道题目，这里是一个矩阵，所以对于行数不能超过x行的条件，可以进行枚举，然后就可以把它转化成上面那个问题了，这里还有一个限制条件0的数量，可以在队首元素弹出的时候进行判断。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll a[<span class="hljs-number">510</span>][<span class="hljs-number">510</span>];ll sum[<span class="hljs-number">510</span>];<span class="hljs-comment">//每列的和</span>ll pre[<span class="hljs-number">510</span>];<span class="hljs-comment">//每列的前缀和</span><span class="hljs-keyword">int</span> cnt[<span class="hljs-number">510</span>];<span class="hljs-comment">//每列0的个数</span><span class="hljs-keyword">int</span> bef[<span class="hljs-number">510</span>];<span class="hljs-comment">//每列的前缀0的个数</span>ll dp[<span class="hljs-number">510</span>];<span class="hljs-comment">//以i为结尾的最大子段和</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> id,num;    ll val;&#125;;<span class="hljs-built_in">deque</span>&lt;node&gt;q;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> r,c,x,y,z;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d%d"</span>,&amp;r,&amp;c,&amp;x,&amp;y,&amp;z);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=c;j++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i][j]);    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)    &#123;        <span class="hljs-built_in">memset</span>(sum,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sum));        <span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(cnt));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=<span class="hljs-built_in">min</span>(r,i+x<span class="hljs-number">-1</span>);j++)        &#123;            pre[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;bef[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=c;k++)            &#123;                sum[k]+=a[j][k];                <span class="hljs-keyword">if</span>(a[j][k]==<span class="hljs-number">0</span>)cnt[k]++;                pre[k]=pre[k<span class="hljs-number">-1</span>]+sum[k];                bef[k]=bef[k<span class="hljs-number">-1</span>]+cnt[k];            &#125;            <span class="hljs-comment">/*printf("i=%d j=%d\n",i,j);</span><span class="hljs-comment">             for(int k=1;k&lt;=c;k++)</span><span class="hljs-comment">             printf("%lld ",pre[k]);</span><span class="hljs-comment">             printf("\n");</span><span class="hljs-comment">             for(int k=1;k&lt;=c;k++)</span><span class="hljs-comment">             printf("%d ",bef[k]);</span><span class="hljs-comment">             printf("\n");*/</span>            q.<span class="hljs-built_in">clear</span>();            node temp;            temp.id=<span class="hljs-number">0</span>;temp.num=bef[<span class="hljs-number">0</span>];temp.val=pre[<span class="hljs-number">0</span>];            q.push_back(temp);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=c;k++)            &#123;                <span class="hljs-keyword">while</span>(!q.empty()&amp;&amp;(k-q.front().id&gt;y||bef[k]-q.front().num&gt;z))                &#123;                    <span class="hljs-comment">//printf("(%d,%d)\n",q.front().id,q.front().num);</span>                    q.pop_front();                &#125;                <span class="hljs-keyword">if</span>(!q.empty())dp[k]=pre[k]-q.front().val;                <span class="hljs-comment">//printf("k=%d pre[k]=%lld front=%lld\n",k,pre[k],q.front().val);</span>                ans=<span class="hljs-built_in">max</span>(ans,dp[k]);                temp.id=k;temp.num=bef[k];temp.val=pre[k];                <span class="hljs-keyword">while</span>(!q.empty()&amp;&amp;temp.val&lt;q.back().val)                q.pop_back();                q.push_back(temp);            &#125;            <span class="hljs-comment">/*for(int k=1;k&lt;=c;k++)</span><span class="hljs-comment">             printf("%lld ",dp[k]);</span><span class="hljs-comment">             printf("\n");*/</span>        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BAPC2014PreliminaryH 二分+贪心</title>
    <link href="/2018/07/08/BAPC-2014-PreliminaryH-%E4%BA%8C%E5%88%86-%E8%B4%AA%E5%BF%83/"/>
    <url>/2018/07/08/BAPC-2014-PreliminaryH-%E4%BA%8C%E5%88%86-%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给n个选手评分，你喜欢f个选手，有s个选手可以晋级，每个选手有初始分数，你有k张票，每张票都有一个分数，每个选手只能给一张票（或者不给），票必须给完。分数最高的s个选手晋级，如果你喜欢的选手跟其他选手平票了，还是算你喜欢的选手晋级。要求喜欢的选手晋级的数量最多是多少。</p><hr><p><strong>思路：</strong></p><p>很容易看出是二分+贪心。</p><p>fav：喜欢的选手。nfav：其他选手。</p><p>错误想法：</p><p>如果k大于f的话，就先把分数最小的前k-f张票从小到大给从大到小的nfav。</p><p>之后进行二分，对于每个x（fav中晋级的数量），继续贪心：</p><p>如果x&lt;f，fav中最大的x个人的分数要大于等于nfav中第s-x大的人的分数。</p><p>如果x&gt;=f，fav中每个人的分数都要大于等于nfav中第n-x小的人的分数。</p><p>然而这样贪心是错的，在最开始分配多余的k的时候就错了，因为可能后面x&lt;f的时候，一个nfav的最大的人很大，肯定会入选，那么给它一个最小分数的票就浪费了，给他最大分数才对。</p><p>最后还是看了数据找出来的错误QAQ</p><p>正确想法：</p><p>对于每个x（fav中被选为晋级的数量）：</p><p>票都是按分数从大到小给的。</p><p>把最大的x张票给从小到大的最大的x个fav。</p><p>如果还有票，就把票给剩下的从小到大（从大到小也可以）的fav。</p><p>如果还有票，就把票给从小到大（从大到小也可以）的最大的s-x个nfav。</p><p>如果还有票，就把票给从小到大的剩下的nfav。</p><p>检查最大的x个fav是不是大于等于第s-x大的nfav。</p><p>想一下还是有道理的，第三步就保证了我刚刚错误的贪心不会发生。</p><p>整个思路可能是这样想的：</p><p>把fav分成x个被选为要晋级的（初始分数最大的x人）和f-x个不晋级的。</p><p>把nfav分成s-x个被选为要晋级的（初始分数最大的s-x人）和n-f-(s-x)个不晋级的。</p><p>假设票按分数从大到小给，</p><p>票肯定是要先给fav的，在fav里要尽可能把票给晋级的人，而且要从小到大给，反证可以知道这样能保证x人晋级。</p><p>然后给不晋级的人，因为它们是不晋级的所以怎么给都可以。（我想的是如果给不晋级的人中大的人多一点是不是可以填补上面晋级的人出现的加了票分数也不够的情况，然而这种情况不可能发生呀，因为初始分数和票的分数都比它们小呀，所以无论是fav还是nfav，被选为晋级的人的分数肯定是要比不晋级的人的分数要大的）</p><p>再把剩下的给nfav，在nfav里要尽可能把票给晋级的人，我觉得要从小到大给啊…但是题解里说是无所谓的…emmmmm？难道不是要保证s-x个人晋级才行吗？想了一下，如果晋级人数不够的话不是更好吗，就能把名额给fav了，那么说从大到小给更好？这样的话大的人是一定要大的吧…反正这样子是小于等于s-x的人晋级就是了（当然大于是有可能的）。</p><p>然后给不晋级的人，要把票从小到大给剩下的nfav。这是为什么呢？可能会出现给票之后本是不晋级的人分数多了超过了fav中晋级的人晋级了的情况，所以要从小到大。</p><p>最后检查一下最大的x个fav的分数是不是大于等于第s-x大的nfav。</p><p>这里写的时候也有一个小技巧，可以把n-k的部分填成0，分配票的时候就更好写了，否则就一直要判断有没有票了，很麻烦。</p><p>还要注意的就是二分的下限应该是max(0,s-(n-f))，否则就会出现不合法的情况。</p><p>贪心果然难啊QAQ也证明不了自己是不是对的 只能举举反例这样子QAQ</p><hr><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> n,s,f,k;<span class="hljs-keyword">int</span> fav[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> nfav[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> p[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> curfav[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> curnfav[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//printf("x=%d\n",x);</span>    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-comment">//给从小到大的最大的x个fav</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=f-x;i&lt;f;i++)        curfav[i]=p[pos++]+fav[i];    <span class="hljs-comment">//给剩下的fav</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;f-x;i++)        curfav[i]=p[pos++]+fav[i];    <span class="hljs-comment">//给最大的s-x个nfav</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n-f-(s-x);i&lt;n-f;i++)        curnfav[i]=p[pos++]+nfav[i];    <span class="hljs-comment">//给从小到大的剩下的nfav</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n-f-(s-x);i++)        curnfav[i]=p[pos++]+nfav[i];    sort(curnfav,curnfav+n-f);    <span class="hljs-comment">/*printf("st=%d ",n-f-(s-x)-1);</span><span class="hljs-comment">    for(int i=0;i&lt;f;i++)</span><span class="hljs-comment">        printf("%d ",curfav[i]);</span><span class="hljs-comment">    printf("\n");</span><span class="hljs-comment">    for(int i=0;i&lt;f;i++)</span><span class="hljs-comment">        printf("%d ",curnfav[i]);</span><span class="hljs-comment">    printf("\n");*/</span>    <span class="hljs-comment">//检查最大的x个fav是否大于等于第s-x大的nfav</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=f-x;i&lt;f;i++)        <span class="hljs-keyword">if</span>(curfav[i]&lt;curnfav[n-f-(s-x)<span class="hljs-number">-1</span>])            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("/Users/apple/Downloads/preliminary/testdata/H.in","r",stdin);</span>    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;s,&amp;f);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;f;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;fav[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n-f;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;nfav[i]);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;k);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;p[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k;i&lt;n;i++)            p[i]=<span class="hljs-number">0</span>;        sort(fav,fav+f);        sort(nfav,nfav+n-f);        <span class="hljs-comment">/*for(int i=0;i&lt;f;i++)</span><span class="hljs-comment">            printf("%d ",fav[i]);</span><span class="hljs-comment">        printf("\n");</span><span class="hljs-comment">        for(int i=0;i&lt;n-f;i++)</span><span class="hljs-comment">            printf("%d ",nfav[i]);</span><span class="hljs-comment">        printf("\n");</span><span class="hljs-comment">        for(int i=0;i&lt;k;i++)</span><span class="hljs-comment">            printf("%d ",p[i]);</span><span class="hljs-comment">        printf("\n");*/</span>        <span class="hljs-keyword">int</span> l=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,s-(n-f)),r=<span class="hljs-built_in">min</span>(s,f),ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(l&lt;=r)        &#123;            <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(judge(mid))ans=mid,l=mid+<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> 1</span><span class="hljs-comment"> 10 4 5</span><span class="hljs-comment"> 8 2 2 1 1</span><span class="hljs-comment"> 0 2 4 7 7</span><span class="hljs-comment"> 9</span><span class="hljs-comment"> 3 4 4 4 4 5 5 5 5</span><span class="hljs-comment"> */</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>latex公式用法</title>
    <link href="/2018/07/04/latex%E5%85%AC%E5%BC%8F%E7%94%A8%E6%B3%95/"/>
    <url>/2018/07/04/latex%E5%85%AC%E5%BC%8F%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="排版方式"><a href="#排版方式" class="headerlink" title="排版方式"></a>排版方式</h3><p><strong>行级元素(inline)</strong>，行级元素使用<script type="math/tex">...</script>，两个$表示公式的首尾。</p><p><strong>块级元素(displayed)</strong>，块级元素使用$$$…$$$。块级元素默认是居中显示的。</p><h3 id="常用西文符号"><a href="#常用西文符号" class="headerlink" title="常用西文符号"></a>常用西文符号</h3><p><code>\alpha</code>, <code>\beta</code>, …, <code>\omega</code>代表α,β,…ω. 大写字母,使用<code>\Gamma</code>, <code>\Delta</code>, …, <code>\Omega</code>代表Γ,Δ,…,Ω.</p><h3 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h3><p>使用 ^和 _ 表示上标和下标. 例如,<code>x_i^2</code>:<script type="math/tex">x_i^2</script> 。</p><p>要显示<script type="math/tex">10^{10}</script>,正确的语法应该是<code>10^{10}</code>。</p><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p>小括号和中括号直接使用，大括号由于用来分组，所以需要转义。<code>\{1+2\}</code>:<script type="math/tex">\{1+2\}</script>。</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ul><li><p>分数：<code>\frac{}{}</code>。例如，<code>\frac{1+1}{2}+1</code>: <script type="math/tex">\frac{1+1}{2}+1</script></p></li><li><p>求和：<code>\sum_1^n</code>:<script type="math/tex">\sum_1^n</script></p></li><li><p>积分：<code>\int_1^n</code>:<script type="math/tex">\int_1^n</script></p></li><li><p>极限：<code>lim_{x \to \infty}</code>:<script type="math/tex">\lim_{x \to \infty}</script></p></li><li><p>矩阵：$$$\begin{matrix}…\end{matrix}$$$，使用&amp;分隔同行元素，\换行。例如：</p><pre><code class="hljs latex">$$    \begin&#123;matrix&#125;    1 &amp; x &amp; x^2 \\    1 &amp; y &amp; y^2 \\    1 &amp; z &amp; z^2 \\    \end&#123;matrix&#125;$$</code></pre><p>得到的公式为：</p><script type="math/tex; mode=display">\begin{matrix} 1 & x & x^2 \\ 1 & y & y^2 \\ 1 & z & z^2 \\ \end{matrix}</script></li></ul><h2 id="杂例"><a href="#杂例" class="headerlink" title="杂例"></a>杂例</h2><ul><li><script type="math/tex; mode=display">h(\theta)=\sum_{j=0}^n \theta_jx_j</script><script type="math/tex; mode=display">h(\theta)=\sum_{j=0}^n \theta_jx_j（线性模型）</script></li></ul><ul><li><script type="math/tex; mode=display">J(\theta)=\frac1{2m}\sum_{i=0}(y^i-h_\theta(x^i))^2</script><script type="math/tex; mode=display">J(\theta)=\frac1{2m}\sum_{i=0}(y^i-h_\theta(x^i))^2（均方误差orcostfunction）</script></li></ul><ul><li><script type="math/tex; mode=display">\frac{\partial J(\theta)}{\partial\theta_j }=-\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))x^i_j</script><script type="math/tex; mode=display">\frac{\partial J(\theta)}{\partial\theta_j }=-\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))x^i_j （批量梯度下降的梯度算法）</script></li></ul><ul><li>```<script type="math/tex; mode=display">f(n) =\begin{cases}n/2,  & \text{if $n$ is even} \\3n+1, & \text{if $n$ is odd}\end{cases}</script><pre><code class="hljs">    $$ f(n) = \begin&#123;cases&#125; n/2,  &amp; \text&#123;if $n$ is even&#125; \\ 3n+1, &amp; \text&#123;if $n$ is odd&#125; \end&#123;cases&#125; $$  - ```latex  $$  \left\&#123;   \begin&#123;array&#125;&#123;c&#125;      a_1x+b_1y+c_1z=d_1 \\       a_2x+b_2y+c_2z=d_2 \\       a_3x+b_3y+c_3z=d_3  \end&#123;array&#125;  \right.   $$</code></pre></li></ul><script type="math/tex; mode=display">\left\{  \begin{array}{c} a_1x+b_1y+c_1z=d_1 \\  a_2x+b_2y+c_2z=d_2 \\  a_3x+b_3y+c_3z=d_3 \end{array} \right.</script><ul><li>```latex<script type="math/tex; mode=display">X=\left(    \begin{matrix}        x_{11} & x_{12} & \cdots & x_{1d}\\        x_{21} & x_{22} & \cdots & x_{2d}\\        \vdots & \vdots & \ddots & \vdots\\        x_{m1} & x_{m2} & \cdots & x_{md}\\    \end{matrix}\right)=\left(     \begin{matrix}            x_1^T \\            x_2^T \\            \vdots\\            x_m^T \\        \end{matrix}\right)</script><pre><code class="hljs">    $$X=\left( \begin&#123;matrix&#125; x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \cdots &amp; x_&#123;1d&#125;\\ x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \cdots &amp; x_&#123;2d&#125;\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\ x_&#123;m1&#125; &amp; x_&#123;m2&#125; &amp; \cdots &amp; x_&#123;md&#125;\\ \end&#123;matrix&#125; \right) =\left( \begin&#123;matrix&#125; x_1^T \\ x_2^T \\ \vdots\\ x_m^T \\ \end&#123;matrix&#125; \right) $$  - ```latex  $$  \begin&#123;align&#125;  \frac&#123;\partial J(\theta)&#125;&#123;\partial\theta_j&#125;  &amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i)) \frac&#123;\partial&#125;&#123;\partial\theta_j&#125;(y^i-h_\theta(x^i)) \\  &amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i)) \frac&#123;\partial&#125;&#123;\partial\theta_j&#125;(\sum_&#123;j=0&#125;^n\theta_jx_j^i-y^i) \\  &amp; = -\frac1m\sum_&#123;i=0&#125;^m(y^i-h_\theta(x^i))x^i_j  \end&#123;align&#125;  $$</code></pre></li></ul><script type="math/tex; mode=display">\begin{align} \frac{\partial J(\theta)}{\partial\theta_j} & = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(y^i-h_\theta(x^i)) \\ & = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(\sum_{j=0}^n\theta_jx_j^i-y^i) \\ & = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))x^i_j \end{align}</script><h2 id="括号-1"><a href="#括号-1" class="headerlink" title="括号"></a>括号</h2><div class="table-container"><table><thead><tr><th>功能</th><th>语法</th><th>显示</th></tr></thead><tbody><tr><td>不好看</td><td><code>(\frac{1}{2})</code></td><td><script type="math/tex">(\frac{1}{2})</script></td></tr><tr><td>好一点</td><td><code>\left( \frac{1}{2} \right)</code></td><td><script type="math/tex">\left( \frac{1}{2} \right)</script></td></tr></tbody></table></div><p>您可以使用\left和\right来显示不同的括号：</p><div class="table-container"><table><thead><tr><th>功能</th><th>语法</th><th>显示</th></tr></thead><tbody><tr><td>圆括号，小括号</td><td><code>\left(\frac{a}{b}\right)</code></td><td><script type="math/tex">\left(\frac{a}{b} \right)</script></td></tr><tr><td>方括号，中括号</td><td><code>\left[\frac{a}{b}\right]</code></td><td><script type="math/tex">\left[\frac{a}{b} \right]</script></td></tr><tr><td>花括号，大括号</td><td><code>\left{\frac{a}{b} \right}</code></td><td><script type="math/tex">\left\{\frac{a}{b} \right\}</script></td></tr><tr><td>角括号</td><td><code>\left\langle\frac{a}{b} \right\rangle</code></td><td><script type="math/tex">\left\langle\frac{a}{b} \right\rangle</script></td></tr><tr><td>单竖线，绝对值</td><td>`\left</td><td>\frac{a}{b}\right</td><td>`</td><td>$$\left</td><td>\frac{a}{b}\right</td><td>$$</td></tr><tr><td>双竖线，范</td><td>`\left</td><td>\frac{a}{b}\right</td><td>`</td><td>$$\left</td><td>\frac{a}{b}\right</td><td>$$</td></tr><tr><td>取整函数 （Floor function）</td><td><code>\left\lfloor\frac{a}{b}\right\rfloor</code></td><td><script type="math/tex">\left\lfloor\frac{a}{b}\right\rfloor</script></td></tr><tr><td>取顶函数 （Ceiling function)</td><td><code>\left\lceil\frac{c}{d}\right\rceil</code></td><td><script type="math/tex">\left\lceil\frac{c}{d}\right\rceil</script></td></tr><tr><td>斜线与反斜线</td><td><code>\left/\frac{a}{b}\right\backslash</code></td><td><script type="math/tex">\left/\frac{a}{b}\right\backslash</script></td></tr><tr><td>上下箭头</td><td><code>\left\uparrow\frac{a}{b}\right\downarrow</code></td><td><script type="math/tex">\left\uparrow\frac{a}{b}\right\downarrow</script></td></tr><tr><td></td><td><code>\left\Uparrow\frac{a}{b}\right\Downarrow</code></td><td><script type="math/tex">\left\Uparrow\frac{a}{b}\right\Downarrow</script></td></tr><tr><td></td><td><code>\left\updownarrow\frac{a}{b}\right\Updownarrow</code></td><td><script type="math/tex">\left\updownarrow\frac{a}{b}\right\Updownarrow</script></td></tr><tr><td>混合括号</td><td>`\left[0,1\right)\left\langle\psi \right</td><td>`</td><td>$$\left[0,1\right)\left\langle\psi \right</td><td>$$</td></tr><tr><td>单左括号</td><td><code>\left\{\frac{a}{b}\right.</code></td><td><script type="math/tex">\left\{\frac{a}{b}\right.</script></td></tr><tr><td>单右括号</td><td><code>\left.\frac{a}{b}\right\}</code></td><td><script type="math/tex">\left.\frac{a}{b}\right\}</script></td></tr></tbody></table></div><p>备注：</p><ul><li>可以使用\big, \Big, \bigg, \Bigg控制括号的大小，比如代码<code>\Bigg(\bigg[\Big\{\big\langle\left|\|\frac{a}{b}\|\right|\big\rangle\Big\}\bigg]\Bigg)</code>显示</li></ul><script type="math/tex; mode=display">\Bigg ( \bigg [ \Big \{ \big \langle \left | \| \frac{a}{b} \| \right | \big \rangle \Big \} \bigg ] \Bigg )</script>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上海高校金马五校赛J 二分+匹配/网络流</title>
    <link href="/2018/07/04/%E4%B8%8A%E6%B5%B7%E9%AB%98%E6%A0%A1%E9%87%91%E9%A9%AC%E4%BA%94%E6%A0%A1%E8%B5%9BJ-%E4%BA%8C%E5%88%86-%E5%8C%B9%E9%85%8D-%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <url>/2018/07/04/%E4%B8%8A%E6%B5%B7%E9%AB%98%E6%A0%A1%E9%87%91%E9%A9%AC%E4%BA%94%E6%A0%A1%E8%B5%9BJ-%E4%BA%8C%E5%88%86-%E5%8C%B9%E9%85%8D-%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出一个n个数字的数列a，两个数之间的差异值定义为<script type="math/tex">max\{|A_i-A_{i-1} |,2≤i≤n\}</script>。现在要插入m个数，可以插在最前面，中间，最后面，问插入后的最小的差异值为多少。</p><p><strong>思路：</strong></p><p>容易想到可以二分答案，知道答案后每个坑位可以填哪些数字就可以确定了。</p><p>匹配：</p><p>考虑二分图匹配的思路。m个数字和n+1个坑位进行匹配，这里会发现又问题，因为如果有个坑位不放数字，这样进行匹配的话不能看出来这个不放数字的坑位前后数字相差本身是否满足条件。所以可以引入几个假数字，让他们匹配不插数字就满足条件的坑位。再进行匹配。</p><p>这里注意vis和link的数组大小，应该是右列的编号。</p><p>网络流：</p><p>n+1 中 A 个必填坑位、B 个不必填坑位与 m 个广告匹配，源点拆点，[S-&gt;S1-&gt; 必填坑位]限流 A，[S-&gt;S2-&gt;不必填坑位]限流 B，check 条件最大流=m。  </p><p>（做完网络流24题后再来看看吧）</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> a[<span class="hljs-number">210</span>],b[<span class="hljs-number">210</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">510</span>];<span class="hljs-comment">//每个广告可以匹配的间隔</span><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">510</span>];<span class="hljs-keyword">int</span> link[<span class="hljs-number">510</span>];<span class="hljs-comment">//右列中与之匹配的左边的</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judgee</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[id][i];        <span class="hljs-keyword">if</span>(!vis[temp])        &#123;            vis[temp]=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(link[temp]==<span class="hljs-number">-1</span>||judgee(link[temp]))            &#123;                link[temp]=id;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxmatch</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)    &#123;        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));        <span class="hljs-keyword">if</span>(judgee(i))            num++;    &#125;    <span class="hljs-keyword">return</span> num;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(link,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(link));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)        v[i].<span class="hljs-built_in">clear</span>();    <span class="hljs-comment">//1~m表示真广告，m+1~n+1表示假广告，n+2~2*n+2表示坑位</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(b[i]-a[j])&lt;=x&amp;&amp;<span class="hljs-built_in">abs</span>(b[i]-a[j+<span class="hljs-number">1</span>])&lt;=x)                v[i].push_back(n+j+<span class="hljs-number">2</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(b[i]-a[<span class="hljs-number">1</span>])&lt;=x)            v[i].push_back(n+<span class="hljs-number">2</span>);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(b[i]-a[n])&lt;=x)            v[i].push_back(<span class="hljs-number">2</span>*n+<span class="hljs-number">2</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m+<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[j]-a[j+<span class="hljs-number">1</span>])&lt;=x)                v[i].push_back(n+j+<span class="hljs-number">2</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m+<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)    &#123;        v[i].push_back(n+<span class="hljs-number">2</span>);        v[i].push_back(<span class="hljs-number">2</span>*n+<span class="hljs-number">2</span>);    &#125;    <span class="hljs-comment">/*if(x==2)</span><span class="hljs-comment">    &#123;</span><span class="hljs-comment">        for(int i=1;i&lt;=n+1;i++)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            printf("%d:",i);</span><span class="hljs-comment">            for(int j=0;j&lt;v[i].size();j++)</span><span class="hljs-comment">                printf("%d ",v[i][j]);</span><span class="hljs-comment">            printf("\n");</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">    &#125;*/</span>    <span class="hljs-keyword">int</span> ans=maxmatch();    <span class="hljs-comment">//printf("%d\n",ans);</span>    <span class="hljs-keyword">if</span>(ans==n+<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;b[i]);        <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">1e9</span>,ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(l&lt;=r)        &#123;            <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(judge(mid))ans=mid,r=mid<span class="hljs-number">-1</span>;            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上海高校金马五校赛B DFS+预处理</title>
    <link href="/2018/07/04/%E4%B8%8A%E6%B5%B7%E9%AB%98%E6%A0%A1%E9%87%91%E9%A9%AC%E4%BA%94%E6%A0%A1%E8%B5%9B-%E5%90%88%E7%BA%A6%E6%95%B0/"/>
    <url>/2018/07/04/%E4%B8%8A%E6%B5%B7%E9%AB%98%E6%A0%A1%E9%87%91%E9%A9%AC%E4%BA%94%E6%A0%A1%E8%B5%9B-%E5%90%88%E7%BA%A6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给定一棵n个节点的树，并且根节点的编号为p，第i个节点有属性值vali, 定义F(i): 在以i为根的子树中，属性值是<script type="math/tex">val_i</script>的合约数的节点个数。y 是 x 的合约数是指 y 是合数且 y 是 x 的约数。小埃想知道<script type="math/tex">\sum_{i=1}^n i·F(i)</script>对1000000007取模后的结果.  </p><p><strong>思路：</strong></p><p>有点类似之前做的一道CF题…就都是整体考虑。</p><p>一次DFS就可以了，从根开始，第一次碰到这个结点的时候F[i]减去当前这个<script type="math/tex">val_i</script>的合约数出现的次数。回溯的时候，F[i]加上当前这个<script type="math/tex">val_i</script>的合约数出现的次数，结果就是i的子树中是<script type="math/tex">val_i</script>的合约数的节点个数（子树包括自己）。所以要预处理出每个数字的合约数。</p><p>这里提一下这个复杂度的估计…我以前对DFS的复杂度估计有误解…</p><p>我以前一直以为DFS的复杂度肯定是2^n这样的，现在考虑一下本身这个树也就n个结点，所以这里的复杂度是O(n*sqrt(val))。</p><p>下次看到子树有几个符合要求的结点时可以考虑这种思路。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">10010</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;hys[<span class="hljs-number">10010</span>];<span class="hljs-comment">//每个数的合约数</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;g[<span class="hljs-number">20010</span>];ll val[<span class="hljs-number">20010</span>];ll cnt[<span class="hljs-number">10010</span>];<span class="hljs-comment">//当前i出现的次数</span>ll F[<span class="hljs-number">20010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">10000</span>;i++)    &#123;        <span class="hljs-keyword">if</span>(!vis[i])        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;i*j&lt;=<span class="hljs-number">10000</span>;j++)                vis[i*j]=<span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">10000</span>;i++)    &#123;        <span class="hljs-keyword">if</span>(vis[i])        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;i*j&lt;=<span class="hljs-number">10000</span>;j++)                hys[i*j].push_back(i);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> par)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;hys[val[id]].<span class="hljs-built_in">size</span>();i++)        F[id]-=cnt[hys[val[id]][i]];    cnt[val[id]]++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;g[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">if</span>(g[id][i]!=par)            dfs(g[id][i],id);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;hys[val[id]].<span class="hljs-built_in">size</span>();i++)        F[id]+=cnt[hys[val[id]][i]];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,p,u,v;    init();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;p);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            g[i].<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;u,&amp;v);            g[u].push_back(v);            g[v].push_back(u);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;val[i]);        <span class="hljs-built_in">memset</span>(F,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(F));        <span class="hljs-built_in">memset</span>(cnt,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(cnt));        dfs(p,<span class="hljs-number">-1</span>);        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            ans=(ans+i*F[i])%MOD;        <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">            printf("%lld ",F[i]);</span><span class="hljs-comment">        printf("\n");*/</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018计蒜之道第一场C 强连通缩点</title>
    <link href="/2018/05/15/2018%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%E7%AC%AC%E4%B8%80%E5%9C%BAC-%E5%BC%BA%E8%BF%9E%E9%80%9A%E7%BC%A9%E7%82%B9/"/>
    <url>/2018/05/15/2018%E8%AE%A1%E8%92%9C%E4%B9%8B%E9%81%93%E7%AC%AC%E4%B8%80%E5%9C%BAC-%E5%BC%BA%E8%BF%9E%E9%80%9A%E7%BC%A9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>科学家有一个容量为N的书架，书里有元素，每个元素有一个污染值。</p><p>有两种操作，</p><p>实习生拿了一本新书替换了x位置的书,新书对应元素的污染值为y。</p><p>大科学家得到了新的结果，如果x位置的书对应的元素加入了实验，那么[l,r]区间内的书对应的元素都必须拿来做实验。</p><p>大科学家希望在完成一次科学实验的前提下（不能不选任何元素），这次实验的总污染值最小。问这个最小的总污染值是多少。</p><p>保证大科学家的书籍总数<script type="math/tex">(N+ 新书数量)≤10^5</script> 。</p><p>每个元素的污染值<script type="math/tex">0\leq(a_i,y)\leq10^9</script> 。</p><p>保证<script type="math/tex">1\leq x\leq N</script>，<script type="math/tex">1\leq l\leq r\leq N,M\leq 10^5</script> 。</p><p>保证<script type="math/tex">\sum(r-l+1)\leq 10^5</script> 。</p><p><strong>思路：</strong></p><p>这道题在写简单的时候就已经筋疲力尽了…题意描述不清楚啊…</p><p>看题目的时候范围又看错了…以为挨个建边会TLE…没看到求和符号啊相当于直接就想下一题（困难）了？</p><p>延续上一题的思路，上一题建完图之后对于每个点跑dfs然后找出总污染值最小的那个点，但是这里就不能这么做了，考虑到总污染值最小的总是出度为0的那个点。</p><p>但是如果存在环呢？那不就没有出度为0的点了吗？所以这里就要用到tarjan缩点啦。</p><p>缩点之后找出度为0的强连通分量，找出强连通分量里总污染值里最小的那个即可。</p><p>其实这题还是很简单的啊…做的时候真的傻了…题目数据范围都没看清楚…还是要仔细读题啊…</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll val[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>];<span class="hljs-comment">//当前书架上放的元素</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">100010</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;scc[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> dfn[<span class="hljs-number">100010</span>];<span class="hljs-comment">//在DFS中该节点被搜索的次序</span><span class="hljs-keyword">int</span> low[<span class="hljs-number">100010</span>];<span class="hljs-comment">//i或i的子树能够追溯到的最早的栈中节点的次序号</span><span class="hljs-keyword">int</span> sccn[<span class="hljs-number">100010</span>];<span class="hljs-comment">//缩点数组，表示某个点对应的强连通分量编号</span><span class="hljs-keyword">int</span> ot[<span class="hljs-number">100010</span>];<span class="hljs-comment">//每个强连通分量的出度</span><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">100010</span>];<span class="hljs-comment">//是否在栈中</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>;<span class="hljs-keyword">int</span> cnt;<span class="hljs-comment">//强连通分量编号</span><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;s;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><span class="hljs-function"></span>&#123;    dfn[u]=low[u]=++<span class="hljs-built_in">step</span>;    vis[u]=<span class="hljs-literal">true</span>;    s.push(u);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[u].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[u][i];        <span class="hljs-keyword">if</span>(!dfn[temp])<span class="hljs-comment">//没有被访问过</span>        &#123;            tarjan(temp);            low[u]=<span class="hljs-built_in">min</span>(low[u],low[temp]);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[temp])<span class="hljs-comment">//在栈中</span>            low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[temp]);    &#125;    <span class="hljs-keyword">if</span>(low[u]==dfn[u])<span class="hljs-comment">//构成强连通分量</span>    &#123;        cnt++;        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">int</span> temp=s.top();            s.pop();<span class="hljs-comment">//此点以上的点全部出栈，构成一个强连通分量</span>            vis[temp]=<span class="hljs-literal">false</span>;            sccn[temp]=cnt;<span class="hljs-comment">//cnt是强连通分量的序号</span>            scc[cnt].push_back(temp);            <span class="hljs-keyword">if</span>(temp==u)<span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,op;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;val[i]);        a[i]=i;    &#125;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;op);        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">int</span> x;            ll y;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%lld"</span>,&amp;x,&amp;y);            val[++n]=y;            a[x]=n;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">int</span> x,l,r;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;l,&amp;r);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)                v[a[x]].push_back(a[i]);        &#125;    &#125;    <span class="hljs-built_in">step</span>=cnt=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(dfn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dfn));    <span class="hljs-built_in">memset</span>(sccn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sccn));    <span class="hljs-built_in">fill</span>(vis+<span class="hljs-number">1</span>,vis+n,<span class="hljs-literal">false</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-keyword">if</span>(!dfn[i])            tarjan(i);    <span class="hljs-built_in">memset</span>(ot,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ot));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;v[i].<span class="hljs-built_in">size</span>();j++)    &#123;        <span class="hljs-keyword">int</span> temp=v[i][j];        <span class="hljs-keyword">if</span>(sccn[i]!=sccn[temp])<span class="hljs-comment">//如果i点与他指向的点不在同一个强连通分量中</span>            ot[sccn[i]]++;<span class="hljs-comment">//i点所在的强连通分量的出度+1</span>    &#125;    ll ans=INF;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)    &#123;        <span class="hljs-keyword">if</span>(ot[i]==<span class="hljs-number">0</span>)        &#123;            ll sum=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;scc[i].<span class="hljs-built_in">size</span>();j++)                sum+=val[scc[i][j]];            ans=<span class="hljs-built_in">min</span>(ans,sum);        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU4848 搜索+剪枝</title>
    <link href="/2018/05/12/HDU4848-%E6%90%9C%E7%B4%A2-%E5%89%AA%E6%9E%9D/"/>
    <url>/2018/05/12/HDU4848-%E6%90%9C%E7%B4%A2-%E5%89%AA%E6%9E%9D/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n个城市，每个城市与另一个城市之间都有路，需要从一个城市到另一个城市需要<script type="math/tex">t_{xy}</script>的时间，一个人到从第一个城市开始视察每一个城市，到每个城市都有一个deadline，到达这个城市的时间不能超过这个deadline，问最小的到达每个城市的到达时间的总和为多少。（n&lt;=30）</p><p><strong>思路：</strong></p><p>先用floyd处理出每两个点之间的最短路。</p><p>n&lt;=30本来肯定是会超时的，可以考虑剪枝。</p><p>搜索的常用剪枝：可行性剪枝、最优性剪枝、记忆化搜索、搜索顺序剪枝。</p><p><u>可行性剪枝</u>： 如果当前条件不合法就不再继续搜索，直接return。</p><p><u>最优性剪枝</u>： 如果当前条件所创造出的答案必定比之前的答案大，那么剩下的搜索就毫无必要，甚至可以剪掉。我们利用某个函数估计出此时条件下答案的“下界”，将它与已经推出的答案相比，如果不比当前答案小，就可以剪掉。</p><p>一般实现：在搜索取和最大值时，如果后面的全部取最大仍然不比当前答案大就可以返回。<br>在搜和最小时同理，可以预处理后缀最大/最小和进行快速查询。</p><p><u>搜索顺序剪枝</u>：  在一些迷宫题，网格题，或者其他搜索中可以贪心的题，搜索顺序显得十分重要。我经常听见有人说(我自己也说过)：“从左边搜会T，从右边搜就A了”之类的语句。其实在迷宫、网格类的题目中，以左上-&gt;右下为例，右下左上就明显比左上右下优秀。在一些推断搜索题中，从已知信息最多的地方开始搜索显然更加优秀。在一些题中，先搜某个值大的，再搜某个值小的(比如树的度数，产生答案的预计(A*))，速度明显会比乱搜更快。搜索的复杂度明显讲不清，这种剪枝自然是能加就加。</p><p>这道题中，</p><p>可行性剪枝：在下一个可以走的点里遍历，如果存在<script type="math/tex">cur+dis[id][i]>d[i]</script>那就说明那个i是怎么都不能走到的，可以剪掉。</p><p>最优性剪枝：如果当前的tot大于现有的ans的话，就可以剪掉。这里对于tot的处理也有讲究，比如到三个点的花费的时间分别是1,3,5，这里到达时间时间相当于是1,1+3,1+3+5，答案是1+1+3+1+3+5，这里可以直接<script type="math/tex">1*3+3*2+5*1</script>，把后面的预先加上，这会更快到达要剪枝的条件。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> dis[<span class="hljs-number">35</span>][<span class="hljs-number">35</span>];<span class="hljs-keyword">int</span> d[<span class="hljs-number">35</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">35</span>];<span class="hljs-keyword">int</span> n,ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> cur,<span class="hljs-keyword">int</span> tot,<span class="hljs-keyword">int</span> num)</span><span class="hljs-comment">//当前时间/累加的答案/经过了几个点</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(tot&gt;=ans)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//当前累积的tot&gt;=ans就return</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)        <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;cur+dis[id][i]&gt;d[i])<span class="hljs-keyword">return</span>;<span class="hljs-comment">//当前的时间+T&gt;任意一个节点的d[i]就return（注意！）</span>    <span class="hljs-keyword">if</span>(num==n)    &#123;        ans=<span class="hljs-built_in">min</span>(ans,tot);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(!vis[i])        &#123;            vis[i]=<span class="hljs-number">1</span>;            dfs(i,cur+dis[id][i],tot+dis[id][i]*(n-num),num+<span class="hljs-number">1</span>);<span class="hljs-comment">//提前把所有之后的都加上（注意！）</span>            vis[i]=<span class="hljs-number">0</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;dis[i][j]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;d[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)            dis[i][j]=<span class="hljs-built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);        ans=INF;        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));        vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;        dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(ans==INF)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZOJ4027 DP+预处理</title>
    <link href="/2018/05/08/ZOJ4027-DP-%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <url>/2018/05/08/ZOJ4027-DP-%E9%A2%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="https://blog.csdn.net/V5ZSQ/article/details/80205265" target="_blank" rel="noopener">https://blog.csdn.net/V5ZSQ/article/details/80205265</a></p><p><strong>题意：</strong></p><p>有一串括号，每个括号有一个权值，当遇到前一个括号为’(‘，后一个括号为’)’时，可以进行交换，交换的价值为<script type="math/tex">v_k*v_{k+1}</script>，求价值的最大值。</p><p><strong>思路：</strong></p><p>DP题…没做出来是我的锅QAQ一种转移状态考虑不出来就试着想想别的状态？</p><p>每个左括号能到达的最右的位置是固定的，如果这个括号可以被移动到j位置，那么他后面的左括号一定都在比他右的位置，也就是j+1位之后。</p><p>第i个左括号到j及之后的位置的最大价值有两种转移，一种是第i个左括号移到j+1及之后的位置，另一种是第i个左括号移到j及之后的位置，第i+1个左括号移到j+1及之后的位置。</p><p>有转移方程<script type="math/tex">dp[i][j]=max(dp[i+1][j],移动到这里的价值+dp[i+1][j+1])</script>。</p><p>如何处理移动到这里的价值呢？</p><p>这个价值相当于第i个左括号的权值*pos[i]~j中所有右括号的权值之和。</p><p>直接遍历右括号会变成n^3的dp，所以这里用前缀和处理。</p><p>处理出前i个右括号的总价值。</p><p>为了找出pos[i]~j中所有右括号的编号，要处理出第i个左括号前有多少个右括号。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 10000000</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">char</span> s[<span class="hljs-number">1010</span>];ll v[<span class="hljs-number">1010</span>];ll dp[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<span class="hljs-comment">//第i个左括号到j及之后位置的最大分数</span><span class="hljs-keyword">int</span> pos[<span class="hljs-number">1010</span>];<span class="hljs-comment">//第i个左括号的下标</span>ll sum[<span class="hljs-number">1010</span>];<span class="hljs-comment">//前i个右括号的总价值</span><span class="hljs-keyword">int</span> pre[<span class="hljs-number">1010</span>];<span class="hljs-comment">//第i个左括号前有多少个右括号</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s+<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;v[i]);        <span class="hljs-keyword">int</span> numl=<span class="hljs-number">0</span>,numr=<span class="hljs-number">0</span>;        sum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;pre[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">'('</span>)            &#123;                pos[++numl]=i;                pre[numl]=numr;            &#125;            <span class="hljs-keyword">else</span>            &#123;                numr++;                sum[numr]=sum[numr<span class="hljs-number">-1</span>]+v[i];            &#125;        &#125;        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=numl;i&gt;=<span class="hljs-number">1</span>;i--)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n-numl+i;j&gt;=pos[i];j--)<span class="hljs-comment">//pos[i]~n-(numl-i)(它后面的左括号都在它后面)</span>            &#123;                dp[i][j]=-INF;                <span class="hljs-comment">//第pre[i]+1个右括号经过j-pos[i]个右括号到达pre[i]+j-pos[i]</span>                ll temp=sum[pre[i]+j-pos[i]]-sum[pre[i]];                dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],temp*v[pos[i]]+dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]);                <span class="hljs-keyword">if</span>(j!=n-numl+i)dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[i][j+<span class="hljs-number">1</span>]);            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=pos[i]<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">1</span>;j--)                dp[i][j]=dp[i][j+<span class="hljs-number">1</span>];        &#125;        ll ans=-INF;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            ans=<span class="hljs-built_in">max</span>(ans,dp[<span class="hljs-number">1</span>][i]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZOJ4028 差分约束</title>
    <link href="/2018/05/04/ZOJ4028-%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    <url>/2018/05/04/ZOJ4028-%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有一个长度为n的隐藏的数列a，再给出一个数列f，f[i]是到i（包括自己）的最长递增数列的长度，给出每个数的范围，求出这个隐藏的数列a。</p><p><strong>思路：</strong></p><p>差分约束。</p><p>当<script type="math/tex">f_i=f_j+1(j<i)</script>时，有<script type="math/tex">a_i>a_j</script>，即<script type="math/tex">a_j-a_i<=-1</script>，所以有i-&gt;j的权值为-1的边。</p><p>当<script type="math/tex">f_i=f_j(j<i)</script>时，有<script type="math/tex">a_i<=a_j</script>，即<script type="math/tex">a_i-a_j<=0</script>，所以有j-&gt;i的权值为0的边。</p><p>那么范围如何处理呢？</p><p>假定有一个超级源点，对于每个范围[l,r]，</p><p>有<script type="math/tex">a_i-a_0>=l</script>，即<script type="math/tex">a_0-a_i<=-l</script>，所以有i-&gt;0的权值为-l的边，</p><p>有<script type="math/tex">a_i-a_0<=r</script>，所以有0-&gt;i的权值为r的边。</p><p>之后跑一下SPFA即可。</p><p>这里注意要用long long。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span><span class="hljs-keyword">int</span> pre[<span class="hljs-number">500010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cost;&#125;;<span class="hljs-built_in">vector</span>&lt;edge&gt;v[<span class="hljs-number">500010</span>];ll dis[<span class="hljs-number">500010</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">500010</span>];<span class="hljs-keyword">int</span> cnt[<span class="hljs-number">500010</span>];<span class="hljs-keyword">int</span> n,tp;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">fill</span>(dis,dis+<span class="hljs-number">1</span>+n,INF);    <span class="hljs-built_in">fill</span>(vis,vis+<span class="hljs-number">1</span>+n,<span class="hljs-literal">false</span>);    <span class="hljs-built_in">fill</span>(cnt,cnt+<span class="hljs-number">1</span>+n,<span class="hljs-number">0</span>);    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;q.push(<span class="hljs-number">0</span>);    vis[<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;dis[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;cnt[<span class="hljs-number">0</span>]++;    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        tp=q.front();vis[tp]=<span class="hljs-literal">false</span>;        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[tp].<span class="hljs-built_in">size</span>();i++)        &#123;            edge &amp;e=v[tp][i];            <span class="hljs-keyword">if</span>(dis[tp]+e.cost&lt;dis[e.to])            &#123;                dis[e.to]=dis[tp]+e.cost;                <span class="hljs-keyword">if</span>(!vis[e.to])                &#123;                    q.push(e.to);                    vis[e.to]=<span class="hljs-literal">true</span>;                    cnt[e.to]++;                    <span class="hljs-keyword">if</span>(cnt[e.to]&gt;n)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">//判断负环</span>                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-keyword">int</span> x,l,r;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)        &#123;            pre[i]=<span class="hljs-number">0</span>;            v[i].<span class="hljs-built_in">clear</span>();        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            <span class="hljs-keyword">if</span>(pre[x<span class="hljs-number">-1</span>]!=<span class="hljs-number">0</span>)            &#123;                edge temp;                temp.to=pre[x<span class="hljs-number">-1</span>];temp.cost=<span class="hljs-number">-1</span>;                v[i].push_back(temp);            &#125;            <span class="hljs-keyword">if</span>(pre[x]!=<span class="hljs-number">0</span>)            &#123;                edge temp;                temp.to=i;temp.cost=<span class="hljs-number">0</span>;                v[pre[x]].push_back(temp);            &#125;            pre[x]=i;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r);            edge temp;            temp.to=<span class="hljs-number">0</span>;temp.cost=-l;            v[i].push_back(temp);            temp.to=i;temp.cost=r;            v[<span class="hljs-number">0</span>].push_back(temp);        &#125;        spfa();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld "</span>,dis[i]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,dis[n]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZOJ4029 数学+预处理+二分</title>
    <link href="/2018/05/03/ZOJ4029-%E6%95%B0%E5%AD%A6-%E4%BA%8C%E5%88%86/"/>
    <url>/2018/05/03/ZOJ4029-%E6%95%B0%E5%AD%A6-%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出n个ai，m个pi，<script type="math/tex">z_i=\sum\limits_{1 \le i \le n}\Bigl\lfloor \frac{a_i}{\lceil\log_{p}a_i\rceil}\Bigr\rfloor</script>，求<script type="math/tex">(\sum\limits_{i=1}^{m} i \cdot z_i) \bmod 10^9</script>。</p><script type="math/tex; mode=display">1 \le n, m \le 5 \times 10^5</script><script type="math/tex; mode=display">2 \le a_i \le 10^{9}</script><script type="math/tex; mode=display">2 \le p_i \le 10^{9}</script><p><strong>思路：</strong></p><p>省赛的题目…在最后几分钟以为想到解法了其实是错觉…看到数学公式就一通打表，真的菜啊。</p><p>首先根据数据范围可以知道分母还是很小的，不超过30。</p><p>所以可以先预处理出来a[i]/分母，用前缀和存起来。</p><p>每给你一个p，对于每个分母，可以根据p二分出来ai的范围，落入这个范围的就用前缀和加一下就可以了。</p><p>这里内存有点紧…会SF…用sizeof预估一下内存吧…</p><p>这里有个地方很迷…<script type="math/tex">temp=(temp+pre[j][pos2]-pre[j][pos1-1]+MOD)%MOD</script>;我觉得加的不会是负的吧a[j]/i都是正的呀…对拍了一下各种数据也都是对的…然而似乎是会有负的…所以每次有减的取模的时候都加一下MOD吧…</p><p><strong>代码：</strong></p><pre><code class="hljs c++">ll a[<span class="hljs-number">500003</span>];ll pre[<span class="hljs-number">32</span>][<span class="hljs-number">500003</span>];<span class="hljs-comment">//分母为i的式子的前缀和</span><span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">30</span>;i++)    &#123;        pre[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)            pre[i][j]=(pre[i][j<span class="hljs-number">-1</span>]+a[j]/i)%MOD;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//printf("%d\n",sizeof(a)+sizeof(pre));</span>    <span class="hljs-keyword">int</span> t,m;    ll p;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);        sort(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);        init();        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;p);            ll temp=<span class="hljs-number">0</span>;            ll l=<span class="hljs-number">1</span>,r=p;<span class="hljs-comment">//(p^(j-1),p^j]</span>            <span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">30</span>;j++)            &#123;                <span class="hljs-keyword">int</span> pos1=upper_bound(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,l)-a;                <span class="hljs-keyword">int</span> pos2=upper_bound(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,r)-a;                pos2--;                <span class="hljs-keyword">if</span>(a[pos1]&lt;=r)                    temp=(temp+pre[j][pos2]-pre[j][pos1<span class="hljs-number">-1</span>]+MOD)%MOD;                l=r;r*=p;                <span class="hljs-keyword">if</span>(l&gt;=a[n])<span class="hljs-keyword">break</span>;            &#125;            temp=(temp*i)%MOD;            ans=(ans+temp)%MOD;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bitset用法</title>
    <link href="/2018/04/27/bitset%E7%94%A8%E6%B3%95/"/>
    <url>/2018/04/27/bitset%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>参考博客：</p><p><a href="https://www.cnblogs.com/RabbitHu/p/bitset.html" target="_blank" rel="noopener">https://www.cnblogs.com/RabbitHu/p/bitset.html</a></p><p>bitset可以用来压位，可以用在开bool数组内存不够的时候。</p><p>bitset存储二进制数位。</p><p>bitset就像一个bool类型的数组一样，但是有空间优化——bitset中的一个元素一般只占1 bit，相当于一个char元素所占空间的八分之一。</p><p>bitset中的每个元素都能单独被访问，例如对于一个叫做foo的bitset，表达式foo[3]访问了它的第4个元素，就像数组一样。</p><p>bitset有一个特性：整数类型和布尔数组都能转化成bitset。</p><p>bitset的大小在编译时就需要确定。如果你想要不确定长度的bitset，请使用vector<bool>。</p><h5 id="定义一个bitset"><a href="#定义一个bitset" class="headerlink" title="定义一个bitset"></a>定义一个bitset</h5><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bitset&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-built_in">bitset</span>&lt;16&gt;foo;  <span class="hljs-built_in">bitset</span>&lt;16&gt;bar(<span class="hljs-number">0xfa2</span>);  <span class="hljs-built_in">bitset</span>&lt;16&gt;baz(<span class="hljs-built_in">string</span>(<span class="hljs-string">"0101111001"</span>));  <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"foo:"</span>&lt;&lt;foo&lt;&lt;<span class="hljs-built_in">endl</span>;  <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"bar:"</span>&lt;&lt;bar&lt;&lt;<span class="hljs-built_in">endl</span>;  <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"baz:"</span>&lt;&lt;baz&lt;&lt;<span class="hljs-built_in">endl</span>;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="bitset操作"><a href="#bitset操作" class="headerlink" title="bitset操作"></a>bitset操作</h5><div class="table-container"><table><thead><tr><th style="text-align:left">函数名</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">b.any()</td><td>b中是否存在置为1的二进制位？</td></tr><tr><td style="text-align:left">b.none()</td><td>b中不存在置为1的二进制位吗？</td></tr><tr><td style="text-align:left">b.count()</td><td>b中置为1的二进制位的个数</td></tr><tr><td style="text-align:left">b.size()</td><td>b中二进制位的个数</td></tr><tr><td style="text-align:left">b[pos]</td><td>访问b中在pos处的二进制位</td></tr><tr><td style="text-align:left">b.test(pos)</td><td>b中在pos处的二进制位是否为1？</td></tr><tr><td style="text-align:left">b.set()</td><td>把b中所有二进制位都置为1</td></tr><tr><td style="text-align:left">b.set(pos)</td><td>把b中在pos处的二进制位置为1</td></tr><tr><td style="text-align:left">b.reset()</td><td>把b中所有二进制位都置为0</td></tr><tr><td style="text-align:left">b.reset(pos)</td><td>把b中在pos处的二进制位置为0</td></tr><tr><td style="text-align:left">b.flip()</td><td>把b中所有二进制位逐位取反</td></tr><tr><td style="text-align:left">b.flip(pos)</td><td>把b中在pos处的二进制位取反</td></tr><tr><td style="text-align:left">b.to_ulong()</td><td>用b中同样的二进制位返回一个unsigned long值</td></tr><tr><td style="text-align:left">b.to_ullong()</td><td>用b中同样的二进制位返回一个unsigned long long值</td></tr><tr><td style="text-align:left">b.to_string()</td><td>返回它转换为string的结果</td></tr><tr><td style="text-align:left">cout&lt;&lt;b</td><td>输出b</td></tr><tr><td style="text-align:left">_Find_first()</td><td>找到第一个为1的数</td></tr><tr><td style="text-align:left">_Find_next()</td><td>找到下一个为1的数</td></tr></tbody></table></div>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZOJ3715 枚举+贪心</title>
    <link href="/2018/04/26/ZOJ3715-%E6%9E%9A%E4%B8%BE-%E8%B4%AA%E5%BF%83/"/>
    <url>/2018/04/26/ZOJ3715-%E6%9E%9A%E4%B8%BE-%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有n个小朋友竞选班长，1想当班长，每个人都必须选择一个人当班长，并且不可以选择自己，并且每个人都有一个权值ai，这个权值就是如果1想让这个人改变主意选择自己当班长就得给他ai个糖果，只有当1的票数是唯一最多的时候，1才能竞选班长，问1竞选班长的最小花费糖果数。(n&lt;=100)</p><p><strong>思路：</strong></p><p>想了直接贪心但是似乎没有完美的方案，都会有反例。</p><p>考虑n&lt;=100比较小，可以枚举+贪心。我第一次想的是枚举除1以外的人票数为i，如果其他人中有票数大于i的话，就贿赂投这个人的人，然后最后看1有多少票数，再根据会不会出现x,x-1,x-1…的情况分类讨论，就很麻烦，结果不对。对拍了一下发现这种做法本身就是错的，比如这一组例子，</p><p>8</p><p>3 4 3 2 4 2 7</p><p>35 13 19 2 70 98 7</p><p>其实只要13+2+7就可以竞选成功，但是如果用这种方法的话就大得多了。</p><p>正解的枚举是枚举1竞选成功的票数i，如果其他人中有票数大于i-1的话，就贿赂投这个人的人，最后如果1的票数大于i的话，不更新答案，等于i的话，更新答案，小于i的话，从还没贿赂的人里选最便宜的贿赂。但是1不是还要投一票吗？出现x,x-1,x-1…的情况那怎么办呢？其实这种情况是不可能出现的，因为x肯定大于2，总票数为x+(n-1)×(x-1)+1，2+(n-1)×1=n+2，但是总票数应该为n，相矛盾了，所以这种情况是不会出现的。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> f[<span class="hljs-number">110</span>],c[<span class="hljs-number">110</span>],num[<span class="hljs-number">110</span>];<span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt;s[<span class="hljs-number">110</span>];<span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt;ss;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(num));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;f[i]);            num[f[i]]++;            s[i].<span class="hljs-built_in">clear</span>();        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;c[i]);            <span class="hljs-keyword">if</span>(f[i]!=<span class="hljs-number">1</span>)s[f[i]].insert(c[i]);        &#125;        <span class="hljs-keyword">int</span> ans=INF;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//1竞选时候的票数</span>        &#123;            ss.<span class="hljs-built_in">clear</span>();            <span class="hljs-keyword">int</span> temp=<span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> sum=num[<span class="hljs-number">1</span>];<span class="hljs-comment">//当前1的票数</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;=n;j++)            &#123;                <span class="hljs-keyword">if</span>(num[j]&gt;i<span class="hljs-number">-1</span>)                &#123;                    <span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;                    <span class="hljs-keyword">int</span> need=num[j]-i+<span class="hljs-number">1</span>;                    <span class="hljs-keyword">for</span>(it=s[j].<span class="hljs-built_in">begin</span>();it!=s[j].<span class="hljs-built_in">end</span>();it++)                    &#123;                        <span class="hljs-keyword">if</span>(need!=<span class="hljs-number">0</span>)&#123;temp+=*it;need--;&#125;                        <span class="hljs-keyword">else</span> ss.insert(*it);                    &#125;                    sum+=num[j]-i+<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    <span class="hljs-keyword">if</span>(!s[j].empty())                    &#123;                        <span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;                        <span class="hljs-keyword">for</span>(it=s[j].<span class="hljs-built_in">begin</span>();it!=s[j].<span class="hljs-built_in">end</span>();it++)ss.insert(*it);                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span>(sum&gt;i)<span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum==i)ans=<span class="hljs-built_in">min</span>(ans,temp);            <span class="hljs-keyword">else</span>            &#123;                <span class="hljs-keyword">int</span> need=i-sum;                <span class="hljs-built_in">multiset</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;                <span class="hljs-keyword">for</span>(it=ss.<span class="hljs-built_in">begin</span>();it!=ss.<span class="hljs-built_in">end</span>()&amp;&amp;need!=<span class="hljs-number">0</span>;it++)                &#123;                    temp+=*it;                    need--;                &#125;                ans=<span class="hljs-built_in">min</span>(ans,temp);            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU5895 矩阵快速幂+欧拉降幂公式</title>
    <link href="/2018/04/24/HDU5895-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82%E5%85%AC%E5%BC%8F/"/>
    <url>/2018/04/24/HDU5895-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>有<script type="math/tex">g(n)=\sum_{i=0}^nf(i)^2</script>，其中<script type="math/tex">f(0)=0,f(1)=1,f(n)=f(n−2)+2f(n−1)(n≥2)</script>，给出n，y，x，s，求<script type="math/tex">x^{g(n*y)}mod(s+1)</script>。</p><p><strong>思路：</strong></p><p>有递推式：</p><script type="math/tex; mode=display">f(n)^2=f(n-2)^2+4f(n-1)^2+4f(n-2)f(n-1)</script><script type="math/tex; mode=display">f(n)f(n-1)=f(n-2)f(n-1)+2f(n-1)^2</script><script type="math/tex; mode=display">g(n)=g(n-1)+f(n)^2</script><p>因此可以构造矩阵：</p><script type="math/tex; mode=display">\left[ \begin{matrix}   f(n)^2 \\   f(n-1)^2 \\   f(n)f(n-1) \\   g(n) \\  \end{matrix}  \right] =  \left[ \begin{matrix}   4&1&4&0 \\   1&0&0&0 \\   2&0&1&0 \\   4&1&4&1  \end{matrix}  \right]\left[ \begin{matrix}   f(n-1)^2 \\   f(n-2)^2 \\   f(n-1)f(n-2) \\   g(n-1) \\  \end{matrix}  \right]\\  可得  \left[ \begin{matrix}   f(ny)^2 \\   f(ny-1)^2 \\   f(ny)f(ny-1) \\   g(ny) \\  \end{matrix}  \right] =  \left[ \begin{matrix}   4&1&4&0 \\   1&0&0&0 \\   2&0&1&0 \\   4&1&4&1  \end{matrix}  \right]^{ny-1}\left[ \begin{matrix}   f(1)^2 \\   f(0)^2 \\   f(1)f(0) \\   g(1) \\  \end{matrix}  \right]</script><p>但是这个结果是放在指数上的，这里就要用到欧拉降幂公式了。</p><script type="math/tex; mode=display">A^BmodC=A^{Bmodφ(C)+φ(C)}modC</script><p>还有另一种写法：可以推出<script type="math/tex">g(n)=\frac{f(n)f(n+1)}{2}</script>，</p><p>这里除以2不能直接用逆元处理，因为并没有保证2和s+1互质，所以可以用到公式<script type="math/tex">\frac{a}{b}modc=\frac{amod(b*c)}{b}</script>（b和c不一定要互质）。</p><p>还有其他公式<script type="math/tex">\frac{a}{b}modc=a*b^{φ(c)-1}modc</script>。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];&#125;m,r;ll MOD;<span class="hljs-function">ll <span class="hljs-title">euler</span><span class="hljs-params">(ll n)</span></span><span class="hljs-function"></span>&#123;    ll i,res=n;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)        &#123;            res=res/i*(i<span class="hljs-number">-1</span>);            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)                n=n/i;        &#125;    &#125;    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)res=res/n*(n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">mat <span class="hljs-title">mult</span><span class="hljs-params">(mat x,mat y)</span></span><span class="hljs-function"></span>&#123;    mat res=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)                res.a[i][j]=(res.a[i][j]+(x.a[i][k]*y.a[k][j])%MOD)%MOD;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">mat <span class="hljs-title">PowerMod</span><span class="hljs-params">(mat x,ll n)</span></span><span class="hljs-function"></span>&#123;    mat ans=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)        ans.a[i][i]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)            ans=mult(ans,x);        x=mult(x,x);        n=n/<span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">powermod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k;    k=a;    k=k%c;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)            ans=(ans*k)%c;        b&gt;&gt;=<span class="hljs-number">1</span>;        k=(k*k)%c;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    ll n,y,x,s;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld%lld"</span>,&amp;n,&amp;y,&amp;x,&amp;s);        MOD=euler(s+<span class="hljs-number">1</span>);        m.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">4</span>;m.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;m.a[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">4</span>;m.a[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">0</span>;        m.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;m.a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;m.a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;m.a[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">0</span>;        m.a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>;m.a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;m.a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;m.a[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">0</span>;        m.a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">4</span>;m.a[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;m.a[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">4</span>;m.a[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;        r=PowerMod(m,n*y<span class="hljs-number">-1</span>);        ll temp=(r.a[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]+r.a[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>])%MOD+MOD;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,powermod(x,temp,s+<span class="hljs-number">1</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调试用</title>
    <link href="/2018/04/22/%E4%B8%80%E4%BA%9B%E7%94%A8%E5%BE%97%E5%88%B0%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <url>/2018/04/22/%E4%B8%80%E4%BA%9B%E7%94%A8%E5%BE%97%E5%88%B0%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
    
    <content type="html"><![CDATA[<h4 id="计算程序运行时间"><a href="#计算程序运行时间" class="headerlink" title="计算程序运行时间"></a>计算程序运行时间</h4><h5 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h5><p><strong>GetTickCount函数</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    DWORD start_time=GetTickCount();    &#123;        <span class="hljs-comment">//此处为被测试代码</span>    &#125;    DWORD end_time=GetTickCount();    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"The run time is:"</span>&lt;&lt;(end_time-start_time)&lt;&lt;<span class="hljs-string">"ms!"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出运行时间</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>clock函数（精度较差）</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">clock_t</span> start_time=clock();    &#123;        <span class="hljs-comment">//被测试代码</span>    &#125;    <span class="hljs-keyword">clock_t</span> end_time=clock();    <span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">"Running time is: "</span>&lt;&lt;<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(end_time-start_time)/CLOCKS_PER_SEC*<span class="hljs-number">1000</span>&lt;&lt;<span class="hljs-string">"ms"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//输出运行时间</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h5><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/time.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10000000</span>;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">start</span>, <span class="hljs-title">end</span>;</span>    gettimeofday(&amp;start, <span class="hljs-literal">NULL</span>);    <span class="hljs-comment">// test code</span>    <span class="hljs-keyword">while</span>(i)    &#123;        i--;    &#125;    gettimeofday(&amp;<span class="hljs-built_in">end</span>, <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> total_time = (<span class="hljs-built_in">end</span>.tv_sec - start.tv_sec) * <span class="hljs-number">1000000</span> + (<span class="hljs-built_in">end</span>.tv_usec - start.tv_usec);    total_time /= <span class="hljs-number">1000</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"total time is %lld ms\n"</span>, total_time);&#125;</code></pre><h4 id="对拍"><a href="#对拍" class="headerlink" title="对拍"></a>对拍</h4><p>参考博客：<a href="https://blog.csdn.net/wlx65003/article/details/51149196" target="_blank" rel="noopener">https://blog.csdn.net/wlx65003/article/details/51149196</a></p><p><a href="http://www.cnblogs.com/shamman/p/7351233.html" target="_blank" rel="noopener">http://www.cnblogs.com/shamman/p/7351233.html</a></p><h5 id="Windows系统-1"><a href="#Windows系统-1" class="headerlink" title="Windows系统"></a>Windows系统</h5><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fqls2o9y8lj30m80gwq4n.jpg" srcset="/img/loading.gif" alt="avatar"></p><p>新建一个批处理文件，命名为循环对拍.bat。</p><pre><code class="hljs python"><span class="hljs-meta">@echo off  </span>:loop      rand.exe %random% &gt; data.<span class="hljs-keyword">in</span>    std.exe &lt; data.<span class="hljs-keyword">in</span> &gt; std.out    my.exe &lt; data.<span class="hljs-keyword">in</span> &gt; my.out    fc my.out std.out <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> errorlevel <span class="hljs-number">1</span> goto loop  pausegoto loop</code></pre><p>rand.cpp</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> random(a,b) ((a)+rand()%((b)-(a)+1))</span><span class="hljs-built_in">stringstream</span> ss;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[] )</span></span><span class="hljs-function"></span>&#123;     <span class="hljs-keyword">int</span> seed=time(<span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">if</span>(argc &gt; <span class="hljs-number">1</span>)<span class="hljs-comment">//如果有参数</span>    &#123;        ss.<span class="hljs-built_in">clear</span>();        ss&lt;&lt;argv[<span class="hljs-number">1</span>];        ss&gt;&gt;seed;<span class="hljs-comment">//把参数转换成整数赋值给seed</span>    &#125;    srand(seed);    <span class="hljs-comment">//以上为随机数初始化，请勿修改</span>    <span class="hljs-comment">//random(a,b)生成[a,b]的随机整数</span>    <span class="hljs-comment">//以下写你自己的数据生成代码 </span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);    <span class="hljs-keyword">int</span> n=<span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> m=<span class="hljs-built_in">random</span>(<span class="hljs-number">1</span>,<span class="hljs-number">20</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,n,m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i&lt;n ; ++i)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d "</span>,<span class="hljs-built_in">random</span>(<span class="hljs-number">0</span>,m));    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>只需把my.cpp和std.cpp放在和对拍程序相同的目录下 ，</p><p>my.cpp里放你自己的代码，编译成my.exe ，</p><p>std.cpp里放标程，编译成std.exe，</p><p>然后双击运行对拍程序，等待它暂停，然后打开data.in就能看到对拍出来的输入的数据，打开my.out和std.out就可以看到该组数据不同的输出。</p><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><p>rand.cpp与上面相同。</p><pre><code class="hljs c++">#!/bin/bash<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span>    ./data &gt; data.in    ./<span class="hljs-built_in">std</span> &lt;data.in &gt;<span class="hljs-built_in">std</span>.out    ./my &lt;data.in &gt;my.out    <span class="hljs-keyword">if</span> diff <span class="hljs-built_in">std</span>.out my.out; then        <span class="hljs-built_in">printf</span> <span class="hljs-string">"AC\n"</span>    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">printf</span> <span class="hljs-string">"Wa\n"</span>        <span class="hljs-built_in">exit</span> <span class="hljs-number">0</span>    fidone</code></pre><p>将代码存储为judge.sh</p><p>在终端运行 chmod +x judge.sh</p><p>在终端运行 ./judge.sh</p><p>保存为.sh后缀的文件（这里以test.sh为例），然后把三个程序放在一个目录下。</p><p>用的时候先Ctrl+Alt+T打开终端，然后输入cd 你的文件目录（右键文件属性可以看到路径，全部输进去，大小写也要完全一样，注意这里要全部是英文路径，不然无法识别），回车。</p><p>再输入sh test.sh，回车。</p><p>这个时候对拍就开始跑了，如果两个程序的输出没差别的话你会看到很多很多行AC，检测到差别时对拍会停下来，你可以在终端看到两个程序分别输出的内容，在目录下的data.in里可以找到出错的这组数据。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LOJ526 最大独立集</title>
    <link href="/2018/04/20/LOJ526-%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/"/>
    <url>/2018/04/20/LOJ526-%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>一个可重集合中包含n个元素 <script type="math/tex">a1,a2,……,an</script>，你需要选择一个子集，使得这个子集中任意两个元素 <script type="math/tex">a_i,a_j</script>均满足条件<script type="math/tex">gcd(ai,aj)*gcd(ai+1,aj+1)≠1</script>，且这个子集的元素个数是所有满足上述条件的子集中最多的。输出这个子集的元素个数。</p><p><strong>思路：</strong></p><p>挺经典的一道题。</p><p>看这道题就可以想到最大团。</p><p>最大团就是图的最大的完全子图（每两个点之间都有边相连）。</p><p>这里满足 <script type="math/tex">gcd(ai,aj)*gcd(ai+1,aj+1)≠1</script>的每两个<script type="math/tex">a_i,a_j</script>都用边相连，该图的最大团就是题目所求了。</p><p>如何求最大团呢？</p><p>最大团=补图的最大独立集。最大独立集数目=|V|−最大匹配数。</p><p>该图的补图就是对满足<script type="math/tex">gcd(ai,aj)*gcd(ai+1,aj+1)=1</script>的每两个<script type="math/tex">a_i,a_j</script>用边相连。</p><p>然后二分图匹配就可以了。</p><p>有一个小优化，奇数和奇数，偶数和偶数肯定是不用连边的，只要连奇数和偶数就好了。</p><p>看别人还有一种做法，多次random_shuffle取满足条件的一个一个加到答案里。</p><p>以后如果看到两两满足条件这种题目的的话，可以试着从这种角度来做。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;ll a[<span class="hljs-number">510</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">510</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">510</span>];<span class="hljs-keyword">int</span> link[<span class="hljs-number">510</span>];<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a&lt;b)&#123;ll temp;temp=a;a=b;b=temp;&#125;    <span class="hljs-keyword">while</span>(a%b)&#123;ll r=a%b;a=b;b=r;&#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[id][i];        <span class="hljs-keyword">if</span>(!vis[temp])        &#123;            vis[temp]=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(link[temp]==<span class="hljs-number">-1</span>||judge(link[temp]))            &#123;                link[temp]=id;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxmatch</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(link,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(link));    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));        <span class="hljs-keyword">if</span>(judge(i))            num++;    &#125;    <span class="hljs-keyword">return</span> num;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=n;j++)        &#123;            <span class="hljs-keyword">if</span>(gcd(a[i],a[j])*gcd(a[i]+<span class="hljs-number">1</span>,a[j]+<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)            &#123;                v[i].push_back(j);                v[j].push_back(i);            &#125;        &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,n-maxmatch()/<span class="hljs-number">2</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金马五校赛C 得到目标数字的最小操作数</title>
    <link href="/2018/04/16/%E9%87%91%E9%A9%AC%E4%BA%94%E6%A0%A1%E8%B5%9BC-%E5%BE%97%E5%88%B0%E7%9B%AE%E6%A0%87%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/"/>
    <url>/2018/04/16/%E9%87%91%E9%A9%AC%E4%BA%94%E6%A0%A1%E8%B5%9BC-%E5%BE%97%E5%88%B0%E7%9B%AE%E6%A0%87%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>给出两个数列a和b(1&lt;=n&lt;=9)，通过以下操作使a变成b，求最小操作数。</p><p>首先可以交换数列中任意两个数的位置。通过若干次这样的操作得到c。</p><p>若c[i]&gt;a[i]，则对a[i]乘2或者加1；若c[i]&lt;a[i]，则对a[i]除以2或者减1，如果是奇数，则不能除以2。</p><p><strong>思路：</strong></p><p>考虑到这里的n的范围很小，可以根据全排列来表示出所有c[i]可能的情况。</p><p>再算出从a到c所用的最小操作数，可以用判环的方法，也可以直接交换。遍历下去如果有不符合自己位置的，就向后找到这个位置该放的那个数，进行交换，计数即可。</p><p>考虑如何从一个数变成另一个数，如果c[i]小于a[i]的时候就进行除法或减法运算，尽量除，是没有问题的，但是如果c[i]大于a[i]进行乘法或加法运算的时候尽量乘的策略就有问题了，比如2-&gt;7，如果用尽量乘的策略，2×2=4，4+3=7，这里用这个策略要4步操作，但实际上，如果这样，2+1=3，3×2=6，6+1=7则只要3步操作，之所以会这样是因为*2如果超过了想要的值，之后一直往上加就会造成操作数变多。所以可以想到a[i]-&gt;c[i]也相当于c[i]-&gt;a[i]，所以就只用除法和减法运算即可。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">15</span>],b[<span class="hljs-number">15</span>],p[<span class="hljs-number">15</span>],tp[<span class="hljs-number">15</span>];<span class="hljs-keyword">int</span> cost[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trans</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        tp[i]=p[i];    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(tp[i]!=i)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)            &#123;                <span class="hljs-keyword">if</span>(tp[j]==i)                &#123;                    swap(tp[i],tp[j]);                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            ans++;        &#125;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span><span class="hljs-comment">//x-&gt;y</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x&lt;y)swap(x,y);    <span class="hljs-keyword">while</span>(x&gt;y)    &#123;        <span class="hljs-keyword">if</span>(x%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">if</span>(x<span class="hljs-number">-1</span>&gt;=y)&#123;x--;ans++;&#125;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>(x/<span class="hljs-number">2</span>&gt;=y)&#123;x/=<span class="hljs-number">2</span>;ans++;&#125;            <span class="hljs-keyword">else</span> &#123;ans+=x-y;x=y;<span class="hljs-keyword">break</span>;&#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);            p[i]=i;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;b[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//预处理出每个a[i]转化为b[j]需要几次操作</span>                cost[i][j]=cal(a[i],b[j]);        <span class="hljs-keyword">int</span> ans=INF;        <span class="hljs-keyword">do</span>        &#123;            <span class="hljs-keyword">int</span> temp=<span class="hljs-number">0</span>;            temp+=trans();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)                temp+=cost[p[i]][i];            ans=<span class="hljs-built_in">min</span>(ans,temp);        &#125;<span class="hljs-keyword">while</span>(next_permutation(p+<span class="hljs-number">1</span>,p+n+<span class="hljs-number">1</span>));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces842D 01Trie</title>
    <link href="/2018/04/12/CodeForces842D-%E5%BC%82%E6%88%96Trie/"/>
    <url>/2018/04/12/CodeForces842D-%E5%BC%82%E6%88%96Trie/</url>
    
    <content type="html"><![CDATA[<h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h5><p>mex为数列中没有出现过的第一个非负整数。给出一个数列，每次询问给出一个x，问每个数异或x后数列的mex。</p><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>又是一道知道怎么做但不会写的题…</p><p>之前就知道有01字典树来处理异或的这种操作，但一直没有写过，这是第一道01字典树吧…</p><p>字典树是高位在上，以保证每次都先满足高位最大。</p><p>对于每一次异或，如果这个位是0，就不变，如果是1，就对换左右子树。</p><p>这里可以用到一个懒标记，只有用到的时候进行标记下放。</p><p>mex的查询就尽量走左子树，如果左子树为空或者被访问的次数小于2^层数的话，就可以往左子树走（注意这里的层数是标在每一层结点的中间的）。</p><p>收获是知道了这种01字典树的操作的要怎么实现吧。</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">300010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    node *child[<span class="hljs-number">2</span>];    <span class="hljs-keyword">int</span> num;<span class="hljs-comment">//有几个数经过这个结点</span>    <span class="hljs-keyword">int</span> f;<span class="hljs-comment">//懒标记</span>    node()    &#123;        num=<span class="hljs-number">0</span>;        f=<span class="hljs-number">0</span>;        child[<span class="hljs-number">0</span>]=child[<span class="hljs-number">1</span>]=<span class="hljs-literal">NULL</span>;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(node *p,<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    p-&gt;num++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">20</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        <span class="hljs-keyword">int</span> id=(x&gt;&gt;i)&amp;<span class="hljs-number">1</span>;        <span class="hljs-comment">//printf("%d ",id);</span>        <span class="hljs-keyword">if</span>(p-&gt;child[id]==<span class="hljs-literal">NULL</span>)p-&gt;child[id]=<span class="hljs-keyword">new</span> node();        p=p-&gt;child[id];        p-&gt;num++;    &#125;    <span class="hljs-comment">//printf("\n");</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node *p,<span class="hljs-keyword">int</span> dep)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//printf("!\n");</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)        <span class="hljs-keyword">if</span>(p-&gt;child[i])            p-&gt;child[i]-&gt;f^=p-&gt;f;    <span class="hljs-keyword">if</span>((p-&gt;f&gt;&gt;dep)&amp;<span class="hljs-number">1</span>)        swap(p-&gt;child[<span class="hljs-number">0</span>],p-&gt;child[<span class="hljs-number">1</span>]);    p-&gt;f=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(node *p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">20</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        pushdown(p,i);        <span class="hljs-keyword">if</span>(p-&gt;child[<span class="hljs-number">0</span>]==<span class="hljs-literal">NULL</span>||p-&gt;child[<span class="hljs-number">0</span>]-&gt;num&lt;(<span class="hljs-number">1</span>&lt;&lt;i))<span class="hljs-comment">//下面有空的结点</span>        &#123;            <span class="hljs-comment">//if(p-&gt;child[0]!=NULL)printf("(%d,%d)",p-&gt;child[0]-&gt;num,1&lt;&lt;i);</span>            p=p-&gt;child[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-comment">//printf("[%d,%d]\n",1&lt;&lt;i,p-&gt;child[0]-&gt;num);</span>            p=p-&gt;child[<span class="hljs-number">1</span>];            ans+=<span class="hljs-number">1</span>&lt;&lt;i;        &#125;        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> ans;<span class="hljs-comment">//NULL是不能访问的，下面都为0</span>    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,n,x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    node *root=<span class="hljs-keyword">new</span> node();    <span class="hljs-keyword">while</span>(n--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        <span class="hljs-keyword">if</span>(!vis[x])        &#123;            vis[x]=<span class="hljs-literal">true</span>;            insert(root,x);        &#125;    &#125;    <span class="hljs-comment">//printf("[[%d]]\n",find(root));</span>    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        root-&gt;f^=x;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,<span class="hljs-built_in">find</span>(root));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZOJ3965 由两个dfs序还原二叉树</title>
    <link href="/2018/04/10/ZOJ3965-%E7%94%B1%E4%B8%A4%E4%B8%AAdfs%E5%BA%8F%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2018/04/10/ZOJ3965-%E7%94%B1%E4%B8%A4%E4%B8%AAdfs%E5%BA%8F%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h5><p>给出两个二叉树的DFS序列，输出每个结点的父结点编号。</p><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>我快要gg了…</p><p>知道要怎么做就是不知道怎么写…</p><p>真的…菜得一逼…递归都不会写（。</p><p>看题解写完就…情绪低落（。</p><p>容易知道如果之后一个结点相同，则说明这一定是当前结点的子结点；如果不同，说明这两个都是该结点的子结点，找到这两个结点分别在两个序列里的位置，然后递归下去。</p><p>考虑一个栗子：</p><p>1 2 4 7 8 9 5 3 6</p><p>1 2 5 4 7 8 9 3 6</p><p>4和5找到以后，3 6要怎么办呢？要把3当成1的子结点才行，所以这里要往上爬一下。</p><p>关于栗子的解释可以见代码。</p><p>这里有一个点很奇怪，son[0]如果为1的话，会TLE，但是如果为2就AC了，超时肯定是while(!son[fa])那里循环不出来了，但是不应该只有一个根结点吗？很奇怪，等下再想想。</p><p>update：注意这里while(!son[fa])fa=far[fa];如果son[0]设为1的话，如果son[0]=0了就循环不出来了，所以一定要设为2。</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>],b[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> hsa[<span class="hljs-number">100010</span>],hsb[<span class="hljs-number">100010</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> far[<span class="hljs-number">100010</span>],son[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> al,<span class="hljs-keyword">int</span> ar,<span class="hljs-keyword">int</span> bl,<span class="hljs-keyword">int</span> br,<span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//printf("%d,%d,%d,%d,%d\n",al,ar,bl,br,fa);</span>    <span class="hljs-keyword">if</span>(al&gt;ar||bl&gt;br||ar&gt;n||br&gt;n)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(a[al]==b[bl])    &#123;        <span class="hljs-keyword">if</span>(vis[a[al]])<span class="hljs-keyword">return</span>;        far[a[al]]=fa;        son[fa]--;        vis[a[al]]=<span class="hljs-literal">true</span>;        dfs(al+<span class="hljs-number">1</span>,ar,bl+<span class="hljs-number">1</span>,br,a[al]);    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">int</span> la=hsa[b[bl]]-al;        <span class="hljs-keyword">int</span> lb=hsb[a[al]]-bl;        <span class="hljs-comment">//printf("[%d,%d]\n",hsa[b[bl]],hsb[a[al]]);</span>        dfs(al,al+la<span class="hljs-number">-1</span>,hsb[a[al]],hsb[a[al]]+la<span class="hljs-number">-1</span>,fa);<span class="hljs-comment">//(3,6,4,7,2)</span>        dfs(hsa[b[bl]],hsa[b[bl]]+lb<span class="hljs-number">-1</span>,bl,bl+lb<span class="hljs-number">-1</span>,fa);<span class="hljs-comment">//(7,7,3,3,2)</span>        <span class="hljs-comment">//printf("[%d]\n",son[fa]);</span>        <span class="hljs-keyword">while</span>(!son[fa])fa=far[fa];        dfs(al+la+lb,ar,bl+la+lb,br,fa);<span class="hljs-comment">//(8,9,8,9,1)</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);            vis[i]=<span class="hljs-literal">false</span>;            hsa[a[i]]=i;            son[i]=<span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;b[i]);            hsb[b[i]]=i;        &#125;        son[<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>;        dfs(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,far[i]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,far[n]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注意</title>
    <link href="/2018/04/09/%E6%B3%A8%E6%84%8F/"/>
    <url>/2018/04/09/%E6%B3%A8%E6%84%8F/</url>
    
    <content type="html"><![CDATA[<p>能之前特判的尽量都先特判。</p><p>多组的时候能不memset的就尽量不memset 特别是时限比较紧的时候。</p><p>可以用sizeof预先估计内存。</p><p>等比数列求和用公式的时候注意要特判公比为1的情况。</p><p>有减的时候取模要加上模数，矩阵快速幂里有负数项，最后也要加模数直到为正。</p><p>找规律可以预先假设一个式子，然后待定系数。</p><p>%f输出是四舍五入的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>震惊.jpg</title>
    <link href="/2018/04/09/%E9%9C%87%E6%83%8A-jpg/"/>
    <url>/2018/04/09/%E9%9C%87%E6%83%8A-jpg/</url>
    
    <content type="html"><![CDATA[<p>记录一下各种之前不知道的point。</p><h5 id="std-set-lower-bound与std-lower-bound的效率问题"><a href="#std-set-lower-bound与std-lower-bound的效率问题" class="headerlink" title="std::set::lower_bound与std::lower_bound的效率问题"></a>std::set::lower_bound与std::lower_bound的效率问题</h5><p>参考博客：<a href="https://blog.csdn.net/CZWin32768/article/details/51752267" target="_blank" rel="noopener">https://blog.csdn.net/CZWin32768/article/details/51752267</a></p><p>set用lower_bound要这样用啊：s.lower_bound(x)。</p><h5 id="vector可定长"><a href="#vector可定长" class="headerlink" title="vector可定长"></a>vector可定长</h5><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v(n);</code></pre><p>这样写。</p><p><strong>%.1f输出是四舍五入的</strong></p><p>要截尾要这样写(int)(x*10000)/10000。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各处看来的姿势</title>
    <link href="/2018/04/07/%E5%90%84%E5%A4%84%E7%9C%8B%E6%9D%A5%E7%9A%84%E5%A7%BF%E5%8A%BF/"/>
    <url>/2018/04/07/%E5%90%84%E5%A4%84%E7%9C%8B%E6%9D%A5%E7%9A%84%E5%A7%BF%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<p>为什么要写这样一篇博文呢？</p><p>因为在知乎上看到了一个问题感觉思想有用？</p><h4 id="2016-的阶乘（2016-）末尾第一个非零数字是几？"><a href="#2016-的阶乘（2016-）末尾第一个非零数字是几？" class="headerlink" title="2016 的阶乘（2016!）末尾第一个非零数字是几？"></a>2016 的阶乘（2016!）末尾第一个非零数字是几？</h4><p>传送门：<a href="https://www.zhihu.com/question/47569759" target="_blank" rel="noopener">https://www.zhihu.com/question/47569759</a></p><p>不妨令2016!末尾有k个零， <img src="https://www.zhihu.com/equation?tex=n+%3D+%5Cfrac%7B2016%21%7D%7B10%5Ek%7D" srcset="/img/loading.gif" alt="n = \frac{2016!}{10^k}"></p><p>因为2016!因子里2肯定比5多，所以 <img src="https://www.zhihu.com/equation?tex=n+%5Cequiv+0+%5Cpmod+2" srcset="/img/loading.gif" alt="n \equiv 0 \pmod 2"></p><p>来数2016!因子5的个数</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7D+2016+%26%5Cdiv%26+5+%26%3D%26+403+%26...%26+1+%5C%5C+403+%26%5Cdiv%26+5+%26%3D%26+80+%26...%26+3+%5C%5C+80+%26%5Cdiv%26+5+%26%3D%26+16+%26...%26+0+%5C%5C+16+%26%5Cdiv%26+5+%26%3D%26+3+%26...%26+1%5C%5C+3+%26%5Cdiv%26+5+%26%3D%26+0+%26...%26+3+%5C%5C+%5Cend%7Barray%7D" srcset="/img/loading.gif" alt="\begin{array}{} 2016 &amp;\div&amp; 5 &amp;=&amp; 403 &amp;...&amp; 1 \\ 403 &amp;\div&amp; 5 &amp;=&amp; 80 &amp;...&amp; 3 \\ 80 &amp;\div&amp; 5 &amp;=&amp; 16 &amp;...&amp; 0 \\ 16 &amp;\div&amp; 5 &amp;=&amp; 3 &amp;...&amp; 1\\ 3 &amp;\div&amp; 5 &amp;=&amp; 0 &amp;...&amp; 3 \\ \end{array}"></p><blockquote><p>Notes:</p><p>考虑以前做过的一道题，k的阶乘的末尾有几个0，我们知道因子里2肯定比5多，所以看因子5的数量，我们的做法是用k去除5，25，125…这里就是一样的道理啦。</p></blockquote><p>因此<img src="https://www.zhihu.com/equation?tex=2%5Ek+%5Ccdot+n+%5Cequiv+%281+%5Ccdot+2+%5Ccdot+3+%5Ccdot+4%29%5Ek+%5Ccdot+1%5E2+%5Ccdot+%281+%5Ccdot+2+%5Ccdot+3%29%5E2+%5Cpmod+5%2C+k+%3D+403%2B80%2B16%2B3" srcset="/img/loading.gif" alt="2^k \cdot n \equiv (1 \cdot 2 \cdot 3 \cdot 4)^k \cdot 1^2 \cdot (1 \cdot 2 \cdot 3)^2 \pmod 5, k = 403+80+16+3"></p><blockquote><p>Notes:</p><p>这是为什么呢？左边是2016!/5^k，右边是2016!除去所有5以后的余数，因为是mod 5的，所以只有4中因子的可能，比如1 mod 5=1，2 mod 5=2，3 mod 5=3，4 mod 5=4，6 mod 5=1，是一直循环的，所以这里求了一下周期（减去有5因子的数后），其实我觉得可以直接找周期不这样做。</p></blockquote><p>有 <img src="https://www.zhihu.com/equation?tex=1+%5Ccdot+2+%5Ccdot+3+%5Cequiv+1+%5Cpmod+5" srcset="/img/loading.gif" alt="1 \cdot 2 \cdot 3 \equiv 1 \pmod 5"></p><p>所以， <img src="https://www.zhihu.com/equation?tex=n+%5Cequiv+2%5E%7B502%7D+%5Cpmod+5" srcset="/img/loading.gif" alt="n \equiv 2^{502} \pmod 5"></p><p>又有 <img src="https://www.zhihu.com/equation?tex=2%5E4+%5Cequiv+1+%5Cpmod+5" srcset="/img/loading.gif" alt="2^4 \equiv 1 \pmod 5"></p><p>于是 <img src="https://www.zhihu.com/equation?tex=n+%5Cequiv+2%5E2+%5Cpmod+5" srcset="/img/loading.gif" alt="n \equiv 2^2 \pmod 5">（利用周期）</p><p>用中国剩余定理求出<img src="https://www.zhihu.com/equation?tex=n+%5Cequiv+4+%5Cpmod+%7B10%7D" srcset="/img/loading.gif" alt="n \equiv 4 \pmod {10}"></p><blockquote><p>Notes：</p><p>结合之前的n≡0(mod 2)，由中国剩余定理，k=(4×2×inv(2,5)+0×5×inv(5,2))%(2×5)=4。</p></blockquote><hr><p>还看到了一个让我有启发的回答：</p><ol><li>小于2016的质数表</li><li>将2016！表示成质数表的指数积</li><li>消掉2，5</li><li>计算剩余质数指数积的尾数</li></ol><p>提示：每个数都表示成质数字典</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计蒜客题 前后缀和+二分答案</title>
    <link href="/2018/04/06/%E8%AE%A1%E8%92%9C%E5%AE%A2%E9%A2%98-%E5%89%8D%E5%90%8E%E7%BC%80-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    <url>/2018/04/06/%E8%AE%A1%E8%92%9C%E5%AE%A2%E9%A2%98-%E5%89%8D%E5%90%8E%E7%BC%80-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h5><p>有一个长度为n且由a和b组成的字符串，可以删除其中一个子串（可以不删），使得删除后的字符串的“变化”次数小于等于m次且最长。</p><p>变化：如果a[i]!=a[i+1]则为一次变化。</p><p>输出删除后最长的长度。</p><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>最近好像经常做前缀和+二分的题目？</p><p>题目里出现了最长这种词语，所以要往二分答案上想（然而我还是看了题解做的QAQ</p><p>所以枚举删除的子串的长度，其他就由前后缀和预处理出来就可以了。</p><p>复杂度是nlogn。</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">char</span> a[<span class="hljs-number">1000010</span>];<span class="hljs-keyword">int</span> pre[<span class="hljs-number">1000010</span>];<span class="hljs-comment">//前缀的变化次数（到自己为止）</span><span class="hljs-keyword">int</span> suf[<span class="hljs-number">1000010</span>];<span class="hljs-comment">//后缀的变化次数（到自己为止）</span><span class="hljs-keyword">int</span> n,m;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    pre[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">if</span>(a[i]!=a[i<span class="hljs-number">-1</span>])pre[i]=pre[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> pre[i]=pre[i<span class="hljs-number">-1</span>];    &#125;    suf[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        <span class="hljs-keyword">if</span>(a[i]!=a[i+<span class="hljs-number">1</span>])suf[i]=suf[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> suf[i]=suf[i+<span class="hljs-number">1</span>];    &#125;    <span class="hljs-comment">/*for(int i=0;i&lt;n;i++)</span><span class="hljs-comment">        printf("%d ",pre[i]);</span><span class="hljs-comment">    printf("\n");</span><span class="hljs-comment">    for(int i=0;i&lt;n;i++)</span><span class="hljs-comment">        printf("%d ",suf[i]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n-x;i++)    &#123;        <span class="hljs-keyword">int</span> temp=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)temp+=pre[i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(i+x&lt;n)temp+=suf[i+x];        <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;i+x&lt;n&amp;&amp;a[i<span class="hljs-number">-1</span>]!=a[i+x])temp++;        <span class="hljs-keyword">if</span>(temp&lt;=m)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);        init();        <span class="hljs-keyword">if</span>(pre[n<span class="hljs-number">-1</span>]&lt;=m)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,n);<span class="hljs-keyword">continue</span>;&#125;        <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=n,ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(l&lt;=r)        &#123;            <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(judge(mid))&#123;ans=mid;r=mid<span class="hljs-number">-1</span>;&#125;            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//printf("%d\n",ans);</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,n-ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计蒜客题 打表找规律</title>
    <link href="/2018/04/04/%E8%AE%A1%E8%92%9C%E5%AE%A2%E6%9F%90%E9%A2%98-%E6%89%93%E8%A1%A8%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    <url>/2018/04/04/%E8%AE%A1%E8%92%9C%E5%AE%A2%E6%9F%90%E9%A2%98-%E6%89%93%E8%A1%A8%E6%89%BE%E8%A7%84%E5%BE%8B/</url>
    
    <content type="html"><![CDATA[<h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h5><p>给定正整数a，b并且a与b互质且满足a&lt;b。</p><p>在所有小于b的自然数构成的集合A = {1，2，3，… ，b-1}中，称(c,d),c,d∈A中，为一个有序数对简称序偶。</p><p>求c和d相乘后模b等于a的序偶有多少对。</p><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>打表大法好。</p><p>打表之后可以发现跟a无关，然后看到数列是这样子的</p><p>1, 2, 2, 4, 2, 6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16, 6, 18, 8, 12, 10, 22, 8, 20, 12, 18, 12, 28, 8, 30, 16, 20, 16, 24, 12, 36, 18, 24, 16, 40, 12, 42, 20, 24, 22, 46, 16, 42, 20, 32, 24, 52, 18, 40, 24, 36, 28, 58, 16, 60, 30, 36, 32, 48, 20, 66, 32, 44…</p><p>在OEIS里查了一下，是欧拉函数，所以写一下就可以了。</p><p>那么如果没有OEIS那怎么办呢？或许应该积累一些常见数列？或许看了题目要互质和b-1就要想到欧拉函数？</p><p>正解：</p><p>考虑小于b的且与b互质的一个数x，那么x和1，2，…，b−1的乘积模b的结果必然还是1，2，…，b−1。</p><p>若x和b不互质，那么x和1，2，…，b−1的乘积模b的结果必然也与b不互质，而a与b互质，这说明此时对答案不成贡献。 </p><p>所以答案就是phi(b)。</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">euler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,res=n;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)        &#123;            res=res/i*(i<span class="hljs-number">-1</span>);            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)                n=n/i;        &#125;    &#125;    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)res=res/n*(n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,a,b;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;b);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,euler(b));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project Euler234 素数筛法+容斥原理</title>
    <link href="/2018/04/04/projecteuler234-%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
    <url>/2018/04/04/projecteuler234-%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h5><p>L(x)为小于等于sqrt(x)的最大素数，R(x)为大于等于sqrt(x)的最小素数。</p><p>若一个数x只能被L(x)和R(x)其中一个整除，我们称之为奇异数。</p><p>对于一个正整数n，求[4,n]中所有奇异数的总和。</p><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>首先sqrt(x)为素数的话肯定不符合条件。</p><p>而且一个非素数的L(x)和R(x)肯定是相邻的素数，所以就考虑每一个素数到下一个素数这个区间。</p><p>那么在这个区间就要求出只能被L整除或者只能被R整除的数的和，如何求呢？</p><p>可以用容斥原理，可以先求出区间内能被L整除的数的和，能被R整除的数的和，再减去2倍的能同时被L和R整除的数就可以啦。</p><p>我先是因为筛法的时候少筛了比sqrt(1e12)大的素数WA了一发，然后又因为筛法的时候数组开得不对又WA了好几发，要考虑周到啊。</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 1000000</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll pri[MAXN+<span class="hljs-number">100</span>];ll pp[MAXN+<span class="hljs-number">100</span>];<span class="hljs-keyword">int</span> num;<span class="hljs-keyword">bool</span> vis[MAXN+<span class="hljs-number">100</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    num=<span class="hljs-number">0</span>;    ll i,j;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=MAXN+<span class="hljs-number">10</span>;i++)    &#123;        <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-literal">false</span>)pri[num++]=i;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;num&amp;&amp;i*pri[j]&lt;=MAXN+<span class="hljs-number">10</span>;j++)            vis[i*pri[j]]=<span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)        pp[i]=pri[i]*pri[i];    <span class="hljs-comment">//printf("%d\n",num);</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    init();    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    ll n,ans;    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n);        ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> pos=lower_bound(pp,pp+num,n)-pp;        <span class="hljs-comment">//printf("%d\n",pos);</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;pos;i++)        &#123;            ll l=pri[i]*pri[i];            ll r=<span class="hljs-built_in">min</span>(n,pri[i+<span class="hljs-number">1</span>]*pri[i+<span class="hljs-number">1</span>]);            ll m=pri[i]*pri[i+<span class="hljs-number">1</span>];            ll ldl=l/pri[i],ldr=r/pri[i];            ll rdl=l/pri[i+<span class="hljs-number">1</span>],rdr=r/pri[i+<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span>(l&gt;=rdl*pri[i+<span class="hljs-number">1</span>])rdl++;            ll mdl=l/m,mdr=r/m;            <span class="hljs-keyword">if</span>(l&gt;=mdl*m)mdl++;            <span class="hljs-comment">//printf("(%lld,%lld)(%lld,%lld)(%lld,%lld)\n",ldl,ldr,rdl,rdr,mdl,mdr);</span>            ans+=(pri[i])*(ldl+ldr)*(ldr-ldl+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;            ans+=(pri[i+<span class="hljs-number">1</span>])*(rdl+rdr)*(rdr-rdl+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;            ans-=<span class="hljs-number">2</span>*m*(mdl+mdr)*(mdr-mdl+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;            ans-=l;            <span class="hljs-keyword">if</span>(r==pri[i+<span class="hljs-number">1</span>]*pri[i+<span class="hljs-number">1</span>])ans-=r;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ST表</title>
    <link href="/2018/04/02/ST%E8%A1%A8/"/>
    <url>/2018/04/02/ST%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>视频大法好：<a href="https://www.bilibili.com/video/av18735440?from=search&amp;seid=13498212845468537633qew" target="_blank" rel="noopener">https://www.bilibili.com/video/av18735440?from=search&amp;seid=13498212845468537633qew</a></p><h5 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h5><p>O(nlogn)预处理，O(1)查询。空间O(nlogn)。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> d[<span class="hljs-number">1000006</span>][<span class="hljs-number">25</span>];<span class="hljs-comment">//预处理得到的dp[i][j]表示从第i位开始长度为2^j当中最小的值</span><span class="hljs-keyword">int</span> mn[<span class="hljs-number">1000006</span>];<span class="hljs-comment">//预处理出比每个数小的最大的2^i的数字以便查询</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rmq_init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        d[i][<span class="hljs-number">0</span>]=a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=n;j++)      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=n;i++)        d[i][j]=<span class="hljs-built_in">min</span>(d[i][j<span class="hljs-number">-1</span>],d[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=<span class="hljs-number">1</span>;len&lt;=n;++len)&#123;        <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>((<span class="hljs-number">1</span>&lt;&lt;(k+<span class="hljs-number">1</span>))&lt;=len)            k++;        mn[len]=k;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rmq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> k=mn[R-L+<span class="hljs-number">1</span>];    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(d[L][k],d[R-(<span class="hljs-number">1</span>&lt;&lt;k)+<span class="hljs-number">1</span>][k]);&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces939E 三分</title>
    <link href="/2018/04/01/CodeForces939E-%E4%B8%89%E5%88%86/"/>
    <url>/2018/04/01/CodeForces939E-%E4%B8%89%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h5><p>有一个集合S，进行Q次操作。</p><p>第一种操作：在集合S中添加元素x，保证x不小于S中的任何元素。</p><p>第二种操作：选出一个S的子集s，让max(s)-mean(s)最大（max(s)表示这个子集的最大值，mean(s)表示这个子集的平均数），输出这个最大值。</p><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>经过多次举例，可以知道s中，当前的最大值一定是要选的，因为这个权重比较大，然后对于这个平均值，可以再举例分析。</p><p>肯定是从左往右取，比如1 3 5 8 9，假如取1，则平均值为5，加入3，则平均值为4.333，加入5，则平均值为4.5，加入8，则平均值为5.2，加入的过程用到前缀和。</p><p>举例大法好。</p><p>由此可见，平均值一个凹函数，要求得这个最小值，三分一下就可以啦。</p><p>所以答案就是max(s)-这个最小值。</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code class="hljs c++">ll a[<span class="hljs-number">500010</span>];ll pre[<span class="hljs-number">500010</span>];<span class="hljs-keyword">int</span> num;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>*(pre[x]+a[num])/(x+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> q,ope;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);    pre[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    num=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(q--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;ope);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)        &#123;            num++;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[num]);            pre[num]=pre[num<span class="hljs-number">-1</span>]+a[num];        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=num;            <span class="hljs-keyword">double</span> ans=<span class="hljs-built_in">min</span>(Calc(l),Calc(r));            <span class="hljs-keyword">while</span>(l&lt;r)            &#123;                <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;                <span class="hljs-keyword">int</span> rmid=(mid+r)&gt;&gt;<span class="hljs-number">1</span>;                <span class="hljs-keyword">double</span> t1=Calc(mid),t2=Calc(rmid);<span class="hljs-comment">//若求最大值则&gt;,min取max</span>                <span class="hljs-keyword">if</span>(t1&gt;t2) l=mid;                <span class="hljs-keyword">else</span> r=rmid;                ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">min</span>(t1,t2));            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f\n"</span>,<span class="hljs-number">1.0</span>*a[num]-ans);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三分查找</title>
    <link href="/2018/04/01/%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2018/04/01/%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="https://blog.csdn.net/beiyouyu/article/details/7875480" target="_blank" rel="noopener">https://blog.csdn.net/beiyouyu/article/details/7875480</a></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>在二分查找的基础上，在右区间（或左区间）再进行一次二分，这样的查找算法称为三分查找，也就是三分法。</p><p>三分查找通常用来迅速确定最值。</p><p>三分法所面向的搜索序列的要求是：序列为一个凸性函数。通俗来讲，就是该序列必须有一个最大值（或最小值），在最大值（最小值）的左侧序列，必须满足不严格单调递增（递减），右侧序列必须满足不严格单调递减（递增）。如下图，表示一个有最大值的凸性函数：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxdkcbjog4j30fm0ajq2u.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><p>1⃣️先取整个区间的中间值mid。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;</code></pre><p>2⃣️再取右侧区间的中间值rmid，从而把区间分为三个小区间。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> rmid=(mid+r)&gt;&gt;<span class="hljs-number">1</span>;</code></pre><p>3⃣️比较mid与rmid谁最靠近最值，只需要确定mid所在的函数值与rmid所在的函数值的大小。当最值为最小值时，mid与rmid中较小的那个自然更为靠近最值。最值为最大值时同理。</p><pre><code class="hljs c++">ll t1=Calc(mid),t2=Calc(rmid);<span class="hljs-comment">//若求最大值则&lt;,min取max</span><span class="hljs-keyword">if</span>(t1&gt;t2) l=mid;<span class="hljs-keyword">else</span> r=rmid;ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">min</span>(t1,t2));</code></pre><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>感谢学长的模板orz</p><pre><code class="hljs c++"><span class="hljs-function">ll <span class="hljs-title">Calc</span><span class="hljs-params">(ll x)</span><span class="hljs-comment">//取最小值</span></span><span class="hljs-function"></span>&#123;&#125;<span class="hljs-function">ll <span class="hljs-title">Tsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    ll ans=<span class="hljs-built_in">min</span>(Calc(l),Calc(r));    <span class="hljs-keyword">while</span>(l&lt;r)    &#123;        <span class="hljs-keyword">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> rmid=mid+r&gt;&gt;<span class="hljs-number">1</span>;        ll t1=Calc(mid),t2=Calc(rmid);        <span class="hljs-keyword">if</span>(t1&gt;t2) l=mid;<span class="hljs-comment">//若求最大值则&lt;,min取max</span>        <span class="hljs-keyword">else</span> r=rmid;        ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">min</span>(t1,t2));    &#125;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces954E 思维</title>
    <link href="/2018/03/28/CodeForces954E-%E6%80%9D%E7%BB%B4/"/>
    <url>/2018/03/28/CodeForces954E-%E6%80%9D%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong><img src="http://i4.bvimg.com/637695/e3a04df670f6b7e6.png" srcset="/img/loading.gif" alt="Markdown"></p><p><strong>思路：</strong></p><p>纯看题解的题QAQ</p><p>首先可以把题目中的式子化成这样<img src="http://i4.bvimg.com/637695/441648f1c4695b61.png" srcset="/img/loading.gif" alt="Markdown"></p><p>所以可以把每个(ti-T)分成两类，一类正，一类负。</p><p>用贪心的思想,可以发现有一半必须全选，另一半选最靠近T的那些，因为ti-T越小，xi越大。</p><p>所以排序之后贪心就可以了。</p><p>涨姿势了原来这题目是这么做的。</p><p>可是这道题我debug了很久QAQ到现在我也不知道之前WA的写法错哪儿了 我只不过把之前负的的计数改成了正的 就AC了 很奇怪 不知道错哪儿了 很迷QAQ</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    ll a,t;&#125; nd[<span class="hljs-number">200010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(node x,node y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x.t&lt;y.t;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(node x,node y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x.t&gt;y.t;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    ll T;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%lld"</span>,&amp;n,&amp;T);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;nd[i].a);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;nd[i].t);        nd[i].t-=T;    &#125;    <span class="hljs-keyword">double</span> ansn=<span class="hljs-number">0</span>,ansp=<span class="hljs-number">0</span>;    ll stn=<span class="hljs-number">0</span>,stp=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)    &#123;        <span class="hljs-keyword">if</span>(nd[i].t&lt;<span class="hljs-number">0</span>)&#123;stn-=nd[i].a*nd[i].t;ansn+=<span class="hljs-number">1.0</span>*nd[i].a;&#125;        <span class="hljs-keyword">else</span> &#123;stp+=nd[i].a*nd[i].t;ansp+=<span class="hljs-number">1.0</span>*nd[i].a;&#125;    &#125;    <span class="hljs-comment">//printf("%lld %lld\n",stn,stp);</span>    <span class="hljs-keyword">if</span>(stn&lt;stp)    &#123;        sort(nd,nd+n,cmp1);<span class="hljs-comment">//把负的当少的</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)        &#123;            <span class="hljs-keyword">if</span>(nd[i].t&gt;=<span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">if</span>(stn<span class="hljs-number">-1.0</span>*nd[i].a*nd[i].t&gt;=<span class="hljs-number">0</span>)                &#123;                    stn-=nd[i].a*nd[i].t;                    ansn+=<span class="hljs-number">1.0</span>*nd[i].a;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    ansn+=stn/(<span class="hljs-number">1.0</span>*nd[i].t);                    stn=<span class="hljs-number">0</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f\n"</span>,ansn);    &#125;    <span class="hljs-keyword">else</span>    &#123;        sort(nd,nd+n,cmp2);<span class="hljs-comment">//把正的当少的</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)        &#123;            <span class="hljs-keyword">if</span>(nd[i].t&lt;<span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">if</span>(stp<span class="hljs-number">-1.0</span>*nd[i].a*(-nd[i].t)&gt;=<span class="hljs-number">0</span>)                &#123;                    stp-=nd[i].a*(-nd[i].t);                    ansp+=<span class="hljs-number">1.0</span>*nd[i].a;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    ansp+=stp/(<span class="hljs-number">-1.0</span>*nd[i].t);                    stp=<span class="hljs-number">0</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.15f\n"</span>,ansp);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bzoj1853 容斥原理+dfs</title>
    <link href="/2018/03/27/bzoj1853-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86-dfs/"/>
    <url>/2018/03/27/bzoj1853-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86-dfs/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>所有只含6与8的数叫做幸运数字，幸运数字的倍数叫做近似幸运数字，幸运数字都是近似幸运数字。 给定区间[l,r]求其中近似幸运数字个数。<br>1 &lt; =l&lt; =r&lt; =10000000000 </p><p><strong>思路：</strong></p><p>类似以前做的能被3，5，7整除的数呀什么的。</p><p>首处理出所有的幸运数字， 然后找到这些数中的”幸运素数”(就是这些数组成的序列中不能被其他元素整除的数）。</p><p>找到这些数,那么 其实就把这个问题就是成求[a,b]内那些”幸运素数”的倍数有多少个就好了。</p><p>ans=[x/一个幸运素数的最小公倍数]−[x/两个幸运素数的最小公倍数]+[x/三个幸运素数的最小公倍数]−….</p><p>然后dfs一下就可以了。</p><p>这里有一个问题，因为这里如果lcm&gt;r的话就可以不再处理了，在dfs之前要把所有幸运素数从大到小排列，这是一个很重要的剪枝，可以减少回溯的次数。</p><p>此外，在中间判断lcm是否大于r的时候会爆long long，所以用double来判断。</p><p>如果要再快一点的话可以直接把幸运素数都直接打表打出来（doge.jpg</p><p>还有一个可以剪枝，每个大于上界/2的数字，倍数肯定是会超上界的，所以这里就直接加在ans，就可以少一些计算。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> num;ll a[<span class="hljs-number">2100</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">2100</span>];ll l,r;ll ans;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(ll x,ll y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&gt;y;&#125;<span class="hljs-function">ll <span class="hljs-title">gcd</span><span class="hljs-params">(ll a,ll b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a&lt;b)&#123;ll temp;temp=a;a=b;b=temp;&#125;    <span class="hljs-keyword">while</span>(a%b)&#123;ll r=a%b;a=b;b=r;&#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&gt;r)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(x!=<span class="hljs-number">0</span>)a[num++]=x;    init(x*<span class="hljs-number">10</span>+<span class="hljs-number">6</span>);    init(x*<span class="hljs-number">10</span>+<span class="hljs-number">8</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> tot,ll lcm)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos==num)    &#123;        <span class="hljs-comment">//printf("tot=%d lcm=%lld",tot,lcm);</span>        <span class="hljs-keyword">if</span>(tot!=<span class="hljs-number">0</span>&amp;&amp;tot%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)ans-=r/lcm-(l<span class="hljs-number">-1</span>)/lcm;<span class="hljs-comment">//这里注意和(r-l+1)/lcm是不同的</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tot!=<span class="hljs-number">0</span>)ans+=r/lcm-(l<span class="hljs-number">-1</span>)/lcm;        <span class="hljs-comment">//printf("(%lld)\n",(r-l+1)/lcm);</span>        <span class="hljs-keyword">return</span>;    &#125;    dfs(pos+<span class="hljs-number">1</span>,tot,lcm);    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">double</span>)(lcm/gcd(lcm,a[pos]))*a[pos]&lt;=r)<span class="hljs-comment">//long long会爆</span>        dfs(pos+<span class="hljs-number">1</span>,tot+<span class="hljs-number">1</span>,lcm/gcd(lcm,a[pos])*a[pos]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;l,&amp;r);    num=<span class="hljs-number">0</span>;    init(<span class="hljs-number">0</span>);    sort(a,a+num);    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=num<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        <span class="hljs-keyword">if</span>(!vis[i])<span class="hljs-comment">//不是某个数的倍数</span>        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)            &#123;                <span class="hljs-keyword">if</span>(a[i]%a[j]==<span class="hljs-number">0</span>)                    vis[i]=<span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)    &#123;        <span class="hljs-keyword">if</span>(!vis[i])            a[tot++]=a[i];    &#125;    num=tot;    sort(a,a+num,cmp);<span class="hljs-comment">//剪枝</span>    <span class="hljs-comment">//printf("%d\n",num);</span>    <span class="hljs-comment">/*for(int i=0;i&lt;num;i++)</span><span class="hljs-comment">        printf("%lld ",a[i]);</span><span class="hljs-comment">    printf("\n");*/</span>    ans=<span class="hljs-number">0</span>;    dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces954G 二分答案+差分数组</title>
    <link href="/2018/03/27/CodeForces954G/"/>
    <url>/2018/03/27/CodeForces954G/</url>
    
    <content type="html"><![CDATA[<h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h5><p>城墙上有n个连成一排的区域，每个区域中有一些弓箭手。弓箭手们都有r的防御半径，也就是说，弓箭手能够防守到向左或向右r个区域加上自己所处区域的范围。每个区域的防御等级为能够防守到该区域的弓箭手数量的总和，而城墙的防御等级为各区域防御等级的最小值。现在我们共有k名备用弓箭手可以增援这n个区域。问增援后城墙的防御等级的最大值能达到多少。</p><p><strong>思路：</strong></p><p>二分答案。</p><p>从左到右遍历这些区域，只要有区域i防御等级没有达到，就立即在相应的位置上布置弓箭手。自然是尽可能地布置在范围的最右边，这样就可以惠及更多的区域。</p><p>这里可以用到一个差分数组来标记。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll a[<span class="hljs-number">500010</span>];ll sum[<span class="hljs-number">500010</span>];ll b[<span class="hljs-number">500010</span>];<span class="hljs-comment">//防御等级</span>ll c[<span class="hljs-number">500010</span>];<span class="hljs-comment">//差分数组</span>ll n,r,k;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    ll tot=k;    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(c));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        c[i]+=c[i<span class="hljs-number">-1</span>];        ll now=b[i]+c[i];        <span class="hljs-keyword">if</span>(now&lt;x)        &#123;            ll need=x-now;            <span class="hljs-keyword">if</span>(tot&lt;need)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            tot-=need;            c[i]+=need;            c[<span class="hljs-built_in">min</span>(n+<span class="hljs-number">1</span>,i+<span class="hljs-number">2</span>*r+<span class="hljs-number">1</span>)]-=need;            <span class="hljs-comment">//因为前面是前缀和，从这里开始就脱离加的k的范围了，所以要减去need</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld"</span>,&amp;n,&amp;r,&amp;k);    sum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);        sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i];    &#125;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        ll lb=<span class="hljs-built_in">max</span>(<span class="hljs-number">1l</span>l,i-r);        ll rb=<span class="hljs-built_in">min</span>(n,i+r);        b[i]=sum[rb]-sum[lb<span class="hljs-number">-1</span>];    &#125;    ll low=<span class="hljs-number">0</span>,high=<span class="hljs-number">2e18</span>;    ll ans=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(low&lt;=high)    &#123;        ll mid=low+(high-low)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(judge(mid))        &#123;            ans=mid;            low=mid+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span> high=mid<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高斯消元</title>
    <link href="/2018/03/14/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    <url>/2018/03/14/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</url>
    
    <content type="html"><![CDATA[<h5 id="异或方程组模板（以HDU3364为例）"><a href="#异或方程组模板（以HDU3364为例）" class="headerlink" title="异或方程组模板（以HDU3364为例）"></a>异或方程组模板（以HDU3364为例）</h5><p>题意：给出n盏灯和m个操作，最开始灯都是关的状态，每次操作可以把k盏灯取反，给你n盏灯的最终状态，问达到这个状态有几种方案。</p><p>思路：解异或方程，这里要注意要有一个初始矩阵，因为在高斯消元的过程中矩阵会发生变化。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 55</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> equ, var;<span class="hljs-comment">///equ个方程 var个变量</span><span class="hljs-keyword">int</span> ori[MAXN][MAXN];<span class="hljs-comment">///初始矩阵</span><span class="hljs-keyword">int</span> a[MAXN][MAXN];<span class="hljs-comment">///增广矩阵</span><span class="hljs-keyword">int</span> x[MAXN];<span class="hljs-comment">///解集</span><span class="hljs-keyword">int</span> x_i[MAXN];<span class="hljs-keyword">bool</span> free_x[MAXN];<span class="hljs-comment">///判断是不是自由变元</span><span class="hljs-keyword">int</span> free_num;<span class="hljs-comment">///自由变元的个数</span><span class="hljs-function">ll <span class="hljs-title">PowerMod</span><span class="hljs-params">(ll a,ll b)</span></span><span class="hljs-function"></span>&#123;    ll ans=<span class="hljs-number">1</span>;    ll k;    k=a;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)        ans=ans*k;        b&gt;&gt;=<span class="hljs-number">1</span>;        k=k*k;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Gauss</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> Max_r;<span class="hljs-comment">///当前列绝对值最大的存在的行</span>    <span class="hljs-comment">///col：处理当前的列</span>    <span class="hljs-keyword">int</span> row,col = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> free_x_num;    <span class="hljs-keyword">int</span> free_index;    free_num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;=var; i++)    &#123;        x[i] = <span class="hljs-number">0</span>;        free_x[i] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span>(row=<span class="hljs-number">0</span>; row&lt;equ&amp;&amp;col&lt;var; row++,col++)    &#123;        Max_r = row;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=row+<span class="hljs-number">1</span>; i&lt;equ; i++)            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[i][col]) &gt; <span class="hljs-built_in">abs</span>(a[Max_r][col]))                Max_r = i;        <span class="hljs-keyword">if</span>(a[Max_r][col] == <span class="hljs-number">0</span>)        &#123;            free_x[col] = <span class="hljs-number">1</span>;            x_i[free_num++] = col;            row--;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span>(Max_r != row)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=col; i&lt;var+<span class="hljs-number">1</span>; i++)                swap(a[row][i], a[Max_r][i]);        <span class="hljs-comment">///消元</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=row+<span class="hljs-number">1</span>; i&lt;equ; i++)            <span class="hljs-keyword">if</span>(a[i][col])                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=col; j&lt;var+<span class="hljs-number">1</span>; j++)                    a[i][j] ^= a[row][j];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=row; i&lt;equ; i++)        <span class="hljs-keyword">if</span>(a[i][col])            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">///无解</span>    <span class="hljs-comment">///保证对角线主元非 0</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;  i&lt;equ; i++)    &#123;        <span class="hljs-keyword">if</span>(!a[i][i])        &#123;            <span class="hljs-keyword">int</span> j;            <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>; j&lt;var; j++)                <span class="hljs-keyword">if</span>(a[i][j])                    <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span>(j == var)                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; k&lt;equ; k++)                swap(a[k][i], a[k][j]);        &#125;    &#125;    <span class="hljs-keyword">if</span>(row &lt; var)        <span class="hljs-keyword">return</span> var - row;<span class="hljs-comment">///自由变元的个数</span>    <span class="hljs-comment">///回代，得到解集</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=var<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)    &#123;        x[i] = a[i][var];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;var; j++)            x[i] ^= (a[i][j] &amp;&amp; x[j]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">///唯一解</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case %d:\n"</span>,kase);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;equ,&amp;var);        <span class="hljs-built_in">memset</span>(ori,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ori));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;var;i++)        &#123;            <span class="hljs-keyword">int</span> k;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;k);            <span class="hljs-keyword">while</span>(k--)            &#123;                <span class="hljs-keyword">int</span> x;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);                x--;                ori[x][i]=<span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">int</span> q;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);        <span class="hljs-keyword">while</span>(q--)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;equ;i++)                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;var;j++)                a[i][j]=ori[i][j];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;equ;i++)            &#123;                <span class="hljs-keyword">int</span> x;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);                a[i][var]=x;            &#125;            <span class="hljs-keyword">int</span> temp=Gauss();            <span class="hljs-comment">//printf("(%d)\n",temp);</span>            <span class="hljs-keyword">if</span>(temp==<span class="hljs-number">-1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,PowerMod(<span class="hljs-number">2</span>,(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)temp));        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>给定一个线性方程组，对其求解。</p><p>输入格式：</p><p>第一行，一个正整数<script type="math/tex">n</script></p><p>第二至<script type="math/tex">n+1</script>行，每行<script type="math/tex">n+1</script>个整数，为<script type="math/tex">a_1,a_2⋯a_n</script>和<script type="math/tex">b</script>，代表一组方程。</p><p>输出格式：</p><p>共<script type="math/tex">n</script>行，每行一个数，第<script type="math/tex">i</script>行为<script type="math/tex">x_i</script>（保留2位小数）</p><p>如果不存在唯一解，在第一行输出”No Solution”。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">double</span> <span class="hljs-built_in">map</span>[<span class="hljs-number">111</span>][<span class="hljs-number">111</span>];<span class="hljs-keyword">double</span> ans[<span class="hljs-number">111</span>];<span class="hljs-keyword">double</span> eps=<span class="hljs-number">1e-7</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n+<span class="hljs-number">1</span>;j++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf"</span>,&amp;<span class="hljs-built_in">map</span>[i][j]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">int</span> r=i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(<span class="hljs-built_in">map</span>[r][i])&lt;<span class="hljs-built_in">fabs</span>(<span class="hljs-built_in">map</span>[j][i]))                r=j;<span class="hljs-comment">//find_the_biggest_number_of_the_first_row（at present) </span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(<span class="hljs-built_in">map</span>[r][i])&lt;eps)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No Solution"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span>(i!=r)swap(<span class="hljs-built_in">map</span>[i],<span class="hljs-built_in">map</span>[r]);<span class="hljs-comment">//对换一行或一列,属于找最大当前系数的其中一步。（这样就可以只处理当前行的系数啦！） </span>        <span class="hljs-keyword">double</span> div=<span class="hljs-built_in">map</span>[i][i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=n+<span class="hljs-number">1</span>;j++)            <span class="hljs-built_in">map</span>[i][j]/=div;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            div=<span class="hljs-built_in">map</span>[j][i];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=i;k&lt;=n+<span class="hljs-number">1</span>;k++)                <span class="hljs-built_in">map</span>[j][k]-=<span class="hljs-built_in">map</span>[i][k]*div;        &#125;    &#125;    ans[n]=<span class="hljs-built_in">map</span>[n][n+<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;        ans[i]=<span class="hljs-built_in">map</span>[i][n+<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)            ans[i]-=(<span class="hljs-built_in">map</span>[i][j]*ans[j]);    &#125;<span class="hljs-comment">//回带操作</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2lf\n"</span>,ans[i]);&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZOJ4006 找规律+组合数</title>
    <link href="/2018/03/11/ZOJ4006-%E6%89%BE%E8%A7%84%E5%BE%8B-%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2018/03/11/ZOJ4006-%E6%89%BE%E8%A7%84%E5%BE%8B-%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题意：一个人从坐标0开始，有1/4的概率向左走一格，1/4的概率向右走一格，1/2的概率不动，给出步数n，和最终的位置m，求到m的概率为多少。该概率可表示为p/q，p,q互质，求出p*q的逆元即可。</p><p>思路：类似规律题？</p><p>先画下图：</p><p><img src="http://i2.bvimg.com/637695/a62d93787dbdbe13.jpg" srcset="/img/loading.gif" alt="Markdown"></p><p><img src="http://i2.bvimg.com/637695/cc3003b893a7493b.jpg" srcset="/img/loading.gif" alt="Markdown"></p><p><img src="http://i2.bvimg.com/637695/697a93def3fd8c15.jpg" srcset="/img/loading.gif" alt="Markdown"></p><p>可以找规律得到这是一个杨辉三角。</p><p>杨辉三角的第n行第m个数可表示为C(m-1,n-1)。</p><p>所以题目要求的就是C(m+n,2*n)/4^n。</p><p>那如何求4^n的逆元呢？根据费马小定理+逆元的定义，可知a关于m的逆元是<img src="http://img.blog.csdn.net/20140613103413828" srcset="/img/loading.gif" alt="img">。</p><p>所以4^n的逆元就是4^(n×MOD-2×n)。</p><p>组合数可以用卢卡斯定理，这里要注意m可能是负的，所以要取绝对值！</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">PowerMod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k;    k=a;    k=k%c;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)        ans=(ans*k)%c;        b&gt;&gt;=<span class="hljs-number">1</span>;        k=(k*k)%c;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(m&gt;n)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a=(n+i-m)%p;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b=i%p;        ans=ans*(a*PowerMod(b,p<span class="hljs-number">-2</span>,p)%p)%p;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Lucas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    ll n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;n,&amp;m);        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>&amp;&amp;m==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>(m&lt;<span class="hljs-number">0</span>)m=-m;            ll x=Lucas(n*<span class="hljs-number">2</span>,m+n,MOD);            ll y=PowerMod(<span class="hljs-number">4</span>,(n*MOD<span class="hljs-number">-2</span>*n),MOD);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,(x*y)%MOD);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java高精度模板</title>
    <link href="/2018/03/11/java%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%A8%A1%E6%9D%BF/"/>
    <url>/2018/03/11/java%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>大数开平方模板（牛顿迭代法）：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">import</span> java.math.BigInteger;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Scanner cin=<span class="hljs-keyword">new</span> Scanner(System.in);        String a;        a=cin.next();        BigInteger n=<span class="hljs-keyword">new</span> BigInteger(a);        <span class="hljs-keyword">if</span>(n.toString().length()%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)            a=a.substring(<span class="hljs-number">0</span>,n.toString().length()/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);        <span class="hljs-keyword">else</span>            a=a.substring(<span class="hljs-number">0</span>,(<span class="hljs-number">1</span>+ n.toString().length())/<span class="hljs-number">2</span>);        BigInteger x=<span class="hljs-keyword">new</span> BigInteger(a);        BigInteger Two=<span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"2"</span>);        <span class="hljs-keyword">if</span>(a==<span class="hljs-string">"1"</span>)&#123;            System.out.println(<span class="hljs-number">1</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">while</span>(n.compareTo(x.multiply(x))&lt;<span class="hljs-number">0</span>)&#123;                x=(x.add(n.divide(x))).divide(Two);            &#125;            System.out.println(x);        &#125;        cin.close();    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SG函数</title>
    <link href="/2018/03/05/SG%E5%87%BD%E6%95%B0/"/>
    <url>/2018/03/05/SG%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="http://blog.csdn.net/luomingjun12315/article/details/45555495" target="_blank" rel="noopener">http://blog.csdn.net/luomingjun12315/article/details/45555495</a></p><p>对于某一类游戏（博弈），我们可以把游戏中的各个状态看作点，状态之间的转移看作有向边，构成一个有向无环图，把博弈的过程看成是两个人拿一个棋子轮流在图上面走，如果轮到某一方时走不动就算输。这可以看做ICG（公平组合游戏，Impartial Combinatorial Games）的一种抽象模型。</p><h4 id="必胜点与必败点"><a href="#必胜点与必败点" class="headerlink" title="必胜点与必败点"></a>必胜点与必败点</h4><p>P-position：先手必败的状态。</p><p>N-position：先手必胜。</p><p><strong>性质</strong></p><p>1.所有终结点是必败点P。</p><p>2.从任何必胜点N操作，至少有一种方式可以进入必败点P。</p><p>3.无论如何操作，必败点P都只能进入必胜点N（后续有必败态的当前一定是必胜态）。</p><p>（1.无法继续走的点是P-position；</p><p>2.有出边指向P-position的点是N-position；</p><p>3.任何出边都指向N-position的点是P-position。）</p><p><strong>分析必胜点和必败点都是以终结点进行逆序分析</strong></p><p>以<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1847" target="_blank" rel="noopener">hdu 1847 Good Luck in CET-4 Everybody!</a>为例：</p><p>总共n张牌，每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…）， 抓完牌，胜负结果也出来了，最后抓完牌的人为胜者。</p><p>当n=0时，为必败点。</p><p>当n=1时，为必胜点。</p><p>当n=2时，为必胜点。</p><p>当n=3时，要么就是剩一张要么剩两张，无论怎么取对方都将面对必胜点，故这一点为必败点。</p><p>以此类推，最后你就可以得到；</p><p>​      n    ：    0    1    2    3    4   5    6 …</p><p>position：  P    N   N    P   N   N   P …</p><p>使用了P/N来分析，使问题变简单了。</p><h4 id="Sprague-Grundy定理（SG定理）"><a href="#Sprague-Grundy定理（SG定理）" class="headerlink" title="Sprague-Grundy定理（SG定理）"></a>Sprague-Grundy定理（SG定理）</h4><p>一个有向无环图上的一个点i的SG函数g(i)定义如下：</p><p>如果该点没有出边，g(i)=0，否则定义一个mex操作，返回值为集合中所不包含的最小的非负整数，那么g(i)=mex{g(x)|i有出边指向x}。</p><p>游戏和的SG函数等于各个游戏SG函数的Nim和（异或和）。</p><p><strong>性质</strong></p><p>设g(i)=k，这就表示从点i可以走到一个SG函数值等于0,1,2,…,k−1的点。</p><p>SG值为0就是必败，SG大于0就是必胜。</p><p><strong>举例</strong></p><p>有1堆n个的石子，每次只能取{1,3,4}个石子，先取完石子者胜利，那么各个数的SG值为多少？</p><p>SG[0]=0，f[]={1,3,4}，</p><p>当x=1时，后继状态为0，所以SG[1]=mex{SG[0]}=mex{0}=1；</p><p>当x=2时，后继状态为1，所以SG[2]=mex{SG[1]}=0;</p><p>当x=3时，后继状态为0和2，所以SG[3]=mex{SG[0],SG[2]}=1;</p><p>当x=4时，后继状态为0和1和3，所以SG[4]=mex{SG[0],SG[1],SG[3]}=2;</p><p>当x=5时，后继状态为1和2和4，所以SG[5]=mex{SG[1],SG[2],SG[4]}=3。</p><p>以此类推，</p><p>   x        0  1  2  3  4  5  6  7  8….</p><p>SG[x]    0  1  0  1  2  3  2  0  1….</p><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p><strong>打表（首选）</strong></p><p>以HDU1848为例：</p><p>题意：给出m,n,p三堆石子，每次可以取斐波那契数个，给出m,n,q，判断先手赢还是后手赢。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> f[<span class="hljs-number">20</span>];<span class="hljs-comment">//可改变当前状态的方式</span><span class="hljs-keyword">int</span> sg[<span class="hljs-number">1010</span>];<span class="hljs-comment">//0~n的SG函数值</span><span class="hljs-keyword">bool</span> s[<span class="hljs-number">1010</span>];<span class="hljs-comment">//mex&#123;&#125;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;f[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">15</span>;i++)    &#123;        <span class="hljs-keyword">if</span>(f[i<span class="hljs-number">-2</span>]+f[i<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">1000</span>)<span class="hljs-keyword">break</span>;        f[i]=f[i<span class="hljs-number">-2</span>]+f[i<span class="hljs-number">-1</span>];    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(sg,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sg));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">memset</span>(s,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(s));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;f[j]&lt;=i&amp;&amp;j&lt;=<span class="hljs-number">15</span>;j++)            s[sg[i-f[j]]]=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)        &#123;            <span class="hljs-keyword">if</span>(!s[j])            &#123;                sg[i]=j;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,n,p;    init();    getsg(<span class="hljs-number">1000</span>);    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;p)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>&amp;&amp;n==<span class="hljs-number">0</span>&amp;&amp;p==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span>(sg[m]^sg[n]^sg[p])<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Fibo\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Nacci\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>DFS</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fstm2vwwmwj30k00qoabl.jpg" srcset="/img/loading.gif" alt=""></p><p>以POJ2425为例：</p><p>题意：给出一张图，有m个棋子，每个人可以任意移动一个棋子，最后不能移动的人为输，问先手赢还是输。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> sg[<span class="hljs-number">1010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(sg[x]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> sg[x];    <span class="hljs-keyword">bool</span> vis[<span class="hljs-number">1010</span>];  <span class="hljs-comment">//vis应该是局部变量，因为下面进行递归调用的时候会打乱vis</span>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[x].<span class="hljs-built_in">size</span>();i++)        vis[getsg(v[x][i])]=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(vis[i])        i++;    <span class="hljs-keyword">return</span> sg[x]=i;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,x;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            v[i].<span class="hljs-built_in">clear</span>();        <span class="hljs-built_in">memset</span>(sg,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(sg));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);            <span class="hljs-keyword">while</span>(m--)            &#123;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);                v[i].push_back(x);            &#125;        &#125;        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m)!=EOF)        &#123;            <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;            <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(m--)            &#123;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);                ans^=getsg(x);                <span class="hljs-comment">/*for(int i=0;i&lt;n;i++)</span><span class="hljs-comment">                    printf("%d ",sg[i]);</span><span class="hljs-comment">                printf("\n");*/</span>            &#125;            <span class="hljs-comment">//printf("%d\n",ans);</span>            <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"LOSE\n"</span>);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"WIN\n"</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPOJ GSS3 区间最大子段和</title>
    <link href="/2018/02/28/SPOJ-GSS3-%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/"/>
    <url>/2018/02/28/SPOJ-GSS3-%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><del>得了一种看到高级数据结构就害怕的病</del></p><p>但我们还是要迎♂而上（雾</p><p><strong>题意</strong>：有n个数，a[1]到a[n]。接下来q次操作，一种是将a[x]变为y，另一种是指定两个数l,r，求a[l]到a[r]的最大子段和。</p><p><strong>思路</strong>：</p><p><img src="https://images2015.cnblogs.com/blog/892758/201702/892758-20170202205949761-50665457.png" srcset="/img/loading.gif" alt="img"><img src="https://images2015.cnblogs.com/blog/892758/201702/892758-20170202210013339-911842200.png" srcset="/img/loading.gif" alt="img"><img src="https://images2015.cnblogs.com/blog/892758/201702/892758-20170202210032151-157808916.png" srcset="/img/loading.gif" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/892758/201702/892758-20170202210048651-1431813345.png" srcset="/img/loading.gif" alt="img"></p><p>gss的维护上面说到了；</p><p>lgss的维护：</p><p>1.左儿子的lgss   2.左儿子的sum+右儿子的lgss（如果跨过了左儿子区间，左边最长连续区间肯定要取到左区间的sum）。</p><p>rgss的维护：</p><p>1.右儿子的rgss   2.右儿子的sum+左儿子的rgg。</p><p>询问：</p><p>利用先遍历左儿子的性质。</p><p>ans：1.该区间的gss   2.之前所有区间的最大字段和+该区间的lgss。</p><p>所以设置一个变量pre用来记录之前所有区间的最大字段和。</p><p>pre的维护：1.该区间的rgss   2.pre+该区间的sum。</p><p><strong>代码</strong>：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> nl id&lt;&lt;1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> nr id&lt;&lt;1|1</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> left,right;    <span class="hljs-keyword">int</span> sum;<span class="hljs-comment">//区间和</span>    <span class="hljs-keyword">int</span> gss;<span class="hljs-comment">//最大子段和</span>    <span class="hljs-keyword">int</span> lgss,rgss;<span class="hljs-comment">//最大左右子段和</span>&#125;node[<span class="hljs-number">50000</span>&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> ans,pre;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    node[id].sum=node[nl].sum+node[nr].sum;    node[id].gss=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(node[nl].gss,node[nr].gss),node[nl].rgss+node[nr].lgss);    node[id].lgss=<span class="hljs-built_in">max</span>(node[nl].lgss,node[nl].sum+node[nr].lgss);    node[id].rgss=<span class="hljs-built_in">max</span>(node[nr].rgss,node[nr].sum+node[nl].rgss);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    node[id].left=l;node[id].right=r;    <span class="hljs-keyword">if</span>(l==r)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;node[id].sum);        node[id].lgss=node[id].rgss=node[id].gss=node[id].sum;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    build(l,m,nl);build(m+<span class="hljs-number">1</span>,r,nr);    up(id);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loc,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;<span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l==r)    &#123;        node[id].sum=c;        node[id].lgss=node[id].rgss=node[id].gss=node[id].sum;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(loc&lt;=m)update(loc,c,nl);    <span class="hljs-keyword">else</span> update(loc,c,nr);    up(id);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;<span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">max</span>(node[id].gss,pre+node[id].lgss));        pre=<span class="hljs-built_in">max</span>(node[id].rgss,pre+node[id].sum);<span class="hljs-comment">//之前所有区间的最大右字段和</span>        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)query(L,R,nl);    <span class="hljs-keyword">if</span>(R&gt;m)query(L,R,nr);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,q,ope,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);    <span class="hljs-keyword">while</span>(q--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;ope,&amp;x,&amp;y);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">0</span>)update(x,y,<span class="hljs-number">1</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)        &#123;            ans=-INF;            pre=-INF;            query(x,y,<span class="hljs-number">1</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一天一dp</title>
    <link href="/2018/02/26/%E4%B8%80%E5%A4%A9%E4%B8%80dp/"/>
    <url>/2018/02/26/%E4%B8%80%E5%A4%A9%E4%B8%80dp/</url>
    
    <content type="html"><![CDATA[<p>因为dp太菜所以（<del>其实哪儿都菜</del></p><p>嘛这就算是每天的做dp记录啦orz</p><p>为了省篇幅有些就一句话题解了吧大概（</p><p>记住要想清楚再写</p><p>想不出怎么设计状态的时候看看数据范围</p><p>想不出怎么转移的时候想想如果写暴力是怎么写的然后从记忆化搜索入手</p><h4 id="2-26"><a href="#2-26" class="headerlink" title="2.26"></a>2.26</h4><p>打算先把51nod的所有动规都做了 有一些之前就做过了就不写了</p><h5 id="51nod1270"><a href="#51nod1270" class="headerlink" title="51nod1270"></a>51nod1270</h5><p>题意：数组A包含N个元素A1, A2……AN。数组B包含N个元素B1, B2……BN。并且数组A中的每一个元素Ai，都满足1 &lt;= Ai &lt;= Bi。数组A的代价定义如下：</p><p><img src="http://img.51nod.com/upfile/000fbd1c/08d1910176cc80940000000000000007.gif" srcset="/img/loading.gif" alt="img"></p><p>（公式表示所有两个相邻元素的差的绝对值之和）</p><p>给出数组B，计算可能的最大代价S。</p><p>数组的长度N(1 &lt;= N &lt;= 50000)。数组元素Bi(1 &lt;= Bi &lt;= 10000)。</p><p>思路：看题目范围就知道不可能是O(N*Bi)的做法所以就肯定是取特殊值了，这里取的就是1或者Bi，dp(i)(j)表示第i个数字取最大值或者最小值的最大代价，然后状态转移就可以了。</p><h4 id="2-27"><a href="#2-27" class="headerlink" title="2.27"></a>2.27</h4><h5 id="51nod1201"><a href="#51nod1201" class="headerlink" title="51nod1201"></a>51nod1201</h5><p>题意：将N分为若干个不同整数的和，有多少种不同的划分方式，例如：n = 6，{6} {1,5} {2,4} {1,2,3}，共4种。由于数据较大，输出Mod 10^9 + 7的结果即可。</p><p>思路：这里是不同的整数，dp的话内存和循环次数都ojbk的，因为1+2+3+…+m=n（预处理部分，确定最多几个数字相加）。</p><p>dp(i)(j)：有i个数字相加和为j的方案数。</p><p>dp(i)(j)=dp(i-1)(j-i)+dp(i)(j-i)。</p><p>dp(i-1)(j-i)：i-1个数字相加再加一个i;</p><p>dp(i)(j-i)：i个数字每个数字都加1。</p><p>本来是想01背包（恰好装满的）做的qwq就是把每个数字当成物品，选或者不选，容量为n的背包，dp(i)(j)dp(i)(j)=(dp(i-1)(j)+dp(i-1)(j-i))%MOD;这样做的 然而不对又不知道怎么错了…</p><p>顺便这里提一下恰好装满的01背包的做法，把dp初始化为-INF，其他和可不装满的01背包一样。</p><h4 id="2-28"><a href="#2-28" class="headerlink" title="2.28"></a>2.28</h4><h5 id="51nod1020"><a href="#51nod1020" class="headerlink" title="51nod1020"></a>51nod1020</h5><p>题意：给出2个数n和k，求1-n的全排列中，逆序数为k的排列有多少种？</p><p>思路：</p><p>dp(i)(j)：1-i的全排列中逆序数为j的方案数。</p><p>从题目的栗子来看：</p><p>1 2 3 4的排列中逆序为3的共有6个，分别是：1 4 3 2；2 3 4 1；2 4 1 3；3 1 4 2；3 2 1 4；4 1 2 3。</p><p>考虑123排列有1 2 3；1 3 2；2 1 3；2 3 1；3 1 2；3 2 1。</p><p>比如1 2 3可以得到逆序数为0 1 2 3的1-4排列，因为只要考虑4开头的逆序数对就可以了，所以就知道dp(i)(j)=∑dp(i-1)(k)，再考虑一下，知道kmin=max(0,j-i+1),kmax=min(j,(i-1)*(i-2)/2)。然后dp就可以了。这里直接开1000乘20000的long long数组会爆内存，所以用两行的滚动数组即可。但是这样会超时…</p><p>想到了优化，要优化肯定是从dp(i)(j-1)来入手，因为max(0,j-i+1)&lt;=k&lt;=min(j,(i-1)*(i-2)/2)，右边可以直接写成j，因为如果(i-1)×(i-2)/2比较小，那么这个以后肯定都是0，加了也没有什么关系；左边呢，就写成j-i+1，因为如果0比较大，那这个是负数，也可以调整，那么j-i+1&lt;=k&lt;=j。所以dp(i)(j)=dp(i)(j-1)+dp(i-1)(j)-dp(i-1)(j-1-i+1)=dp(i)(j-1)+dp(i-1)(j)-dp(i-1)(j-i)。考虑到j=0的情况，dp(i)(0)=1；考虑到j-i+1可能是负数，当j-i&lt;0，最后一项不减。</p><p>注意这里是多组数据…所以预处理存下所有的dp(i)(j)就好了。</p><h4 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h4><p>想不到立着的flag这么快就倒了qwq我觉得不行（。</p><h5 id="51nod1154"><a href="#51nod1154" class="headerlink" title="51nod1154"></a>51nod1154</h5><p>题意：有一个字符串S，求S最少可以被划分为多少个回文串。</p><p>思路：dp[i]:前i个字母最少可以被划分为多少个回文串。</p><p>可以写写看。比如a，即dp[0]=1；当aa时，dp[1]=1，当ab时，dp[1]=dp[0]+1=2；当aba时，dp[2]=0+1=1，当abb时，dp[2]=dp[0]+1=2。由此可见，dp[i]=dp[j-1]+1(j&lt;=i&amp;&amp;j到i为回文串)。</p><p>那么如何知道j到i为回文串呢？</p><p>可以继续dp预处理一下，hw(i)(j)：i到j是否是回文串，只有当中间为回文串而且a[i]==a[j]，i到j才为回文串。</p><h4 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h4><p>一直做51nod的题有点吃不消QAQ做个记忆化搜索缓一缓w</p><h5 id="POJ1088"><a href="#POJ1088" class="headerlink" title="POJ1088"></a>POJ1088</h5><p>题意：给一张高度图，滑雪只能往低的地方滑，求最长的一条路。</p><p>思路：很简单的记忆化搜索…没啥好说的…因为题目看错WA了一发…要审清题意啊…</p><h5 id="HDU1428"><a href="#HDU1428" class="headerlink" title="HDU1428"></a>HDU1428</h5><p>题意：从(1,1)走到(n,n)，给出每个地点的费时，考虑从A区域到B区域仅当存在一条从B到机房的路线比任何一条从A到机房的路线更快，问总路线有几条。</p><p>思路：注意四个方向都可以走，刚开始以为只往右下走，直接两次dp了，所以WA了。先处理出每一点到机房的最短路，用bfs松弛的思想，之后记忆化搜索即可。</p><h4 id="3-11"><a href="#3-11" class="headerlink" title="3.11"></a>3.11</h4><h5 id="51nod1241"><a href="#51nod1241" class="headerlink" title="51nod1241"></a>51nod1241</h5><p>题意：一个数组的元素为1至N的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？</p><p>思路：只要考虑最长连续子序列即可，移动的时候，其他数字都可以按序每个数字移动一次即可，即答案为n-最长连续子序列的长度。</p><h4 id="3-12"><a href="#3-12" class="headerlink" title="3.12"></a>3.12</h4><h5 id="51nod-1636"><a href="#51nod-1636" class="headerlink" title="51nod 1636"></a>51nod 1636</h5><p>题意：一个学年由n天组成。A学校有m门课程，每天学生必须学习一门课，一门课程必须在一天内学习完。在学习完第i门课程后，学生们会收到 xi 个家庭作业，其中 xi是区间[ai,bi]里的一个整数 。每门课还有一个属性，就是复杂度 ci 。A学校现在要制他们的课程表，具体要求如下：在课程表中，随着天数的增加，课程的复杂度是严格递增的。</p><p>除了第1天，每天的作业量必须是前一天的k倍，或者比前一天多k个作业。（假设第i天的作业量为 xi ，则对于i(1＜i≤n)到满足 xi ＝ k+xi−1 或 xi ＝ k⋅xi−1 ）；</p><p>现在，给定天数n，系数k，和m门课程的ai，bi，ci（1≤i≤m）。要求计算一个学年可以安排最大的总作业量( 总作业量的表达式是∑ni=1xi )是多少。</p><p>思路：刚开始思路被背包束缚住了，这么设计状态：dp(i)(j)(k)表示选到第i门选了j门最后一门作业量是k，但是1≤ai≤bi≤10^16，数组存不下，因为有这个条件bi-ai≤100，又想跟l可以搭上关系，但是想想却不能确定前一门是哪一门，所以这样是不行的。考虑另一种状态设计：dp(i)(j)(k)表示第i天选了第j门作业量为a[j].l+k的最大作业量，先sort一下满足dp(i)(j)(k)=max(dp(i-1)(l)(a[j].l+k-z-a[l].l),dp(i-1)(l)((a[j].l+k)/z-a[l].l))(l&lt;j-1)。debug到意识模糊，这种三维的调试起来最麻烦…自己想样例也是很重要的啊…其实是忘了一个点，要转移还漏了一个条件，要注意转移的前一个状态要存在，并不是只要判断合理就可以了。</p><h4 id="3-14"><a href="#3-14" class="headerlink" title="3.14"></a>3.14</h4><h5 id="51nod1732"><a href="#51nod1732" class="headerlink" title="51nod1732"></a>51nod1732</h5><p>题意：给出一个字符串，求从i和从j开始的子串的最长公共前缀。</p><p>思路：dp(i)(j)：i和j的匹配度。根据样例的例子写写画画就知道有转移方程dp(i)(j)=dp(i+1)(j+1)+1，所以只要先预处理出来相同的a(i)和a(j)，然后倒着跑n^2的循环就可以了。</p><h4 id="3-15"><a href="#3-15" class="headerlink" title="3.15"></a>3.15</h4><h5 id="51nod1354"><a href="#51nod1354" class="headerlink" title="51nod1354"></a>51nod1354</h5><p>题意：给出n个数，输出当前子序列里面的所有元素乘起来恰好等于K的子序列数。</p><p>思路：很容易想到这是一个选与不选的问题，dp(i)(j):选到第i个数字乘积为j的方案数，但是这里2&lt;=K&lt;=100000000，所以要考虑存更小的，所以想到了可以存因数，预处理出来K的因数，map存一下，然后dp即可。这里要注意一个情况，当第一个数字为1时，dp(1)(1)应该是2，因为这可能是不选也可能是1，有两种情况。</p><h4 id="3-16"><a href="#3-16" class="headerlink" title="3.16"></a>3.16</h4><h5 id="51nod1055"><a href="#51nod1055" class="headerlink" title="51nod1055"></a>51nod1055</h5><p>题意：给出n个数，从中选出最长等差数列。</p><p>思路：这道题目想了很久然而还是gg，是看了题解做出来的qwq双指针什么的实在是没想到啊QAQ</p><p>首先想的是dp(i)(j):最后一个数为a[i]等差为j的最大长度，这样想很简单，可是就是数据存不下，而且还要考虑j的所有情况，我是开了两个map，map本来就慢，就gg了。</p><p>看了题解，发现它利用了等差数列2*a[j]=a[i]+a[k]的性质。它是这么设计状态的：dp(i)(j):第一个数为a[i]，第二个数为a[j]的最长等差数列的长度。有dp(i)(j)=dp(j)(k)+1(当满足性质时)，这么说是要O(n^3)的，但是这里很巧妙，用了双指针左右扫的方法。</p><p>这里还用了黑科技，10000*10000讲道理是开不下的，所以这里用了short int类型。</p><p>具体看代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10010</span>];short <span class="hljs-keyword">int</span> dp[<span class="hljs-number">10005</span>][<span class="hljs-number">10005</span>];<span class="hljs-comment">//以a[i]和a[j]为前两个数的最长的等差数列</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);    sort(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)            dp[i][j]=<span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">2</span>;j--)    &#123;        <span class="hljs-keyword">int</span> i=j<span class="hljs-number">-1</span>,k=j+<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">1</span>&amp;&amp;k&lt;=n)        &#123;            <span class="hljs-keyword">if</span>(a[i]+a[k]==<span class="hljs-number">2</span>*a[j])            &#123;                dp[i][j]=dp[j][k]+<span class="hljs-number">1</span>;                i--;k++;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]+a[k]&lt;<span class="hljs-number">2</span>*a[j])k++;            <span class="hljs-keyword">else</span> i--;        &#125;    &#125;    <span class="hljs-keyword">int</span> MAX=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)            <span class="hljs-keyword">if</span>(dp[i][j]&gt;MAX)MAX=dp[i][j];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,MAX);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="3-21"><a href="#3-21" class="headerlink" title="3.21"></a>3.21</h4><h5 id="51nod1274"><a href="#51nod1274" class="headerlink" title="51nod1274"></a>51nod1274</h5><p>题意：给出一张无向图，求最长严格递增路径。</p><p>思路：这道题看起来很简单记忆化搜索一下就ojbk了可是我debug得真的有点难受orz不过很好自从这个一天一dp计划开始就尽量不看题解了有进步hhh</p><p>刚开始想的是从每个点的最长路径入手，可是考虑到这和前一条边的长度有关系，所以就考虑dp(i):从i条边开始的最长路径。这里，我又没考虑周全，我直接把每条无向边当成一条边了，然后我还存了每条边的两个端点，然后再两个方向dfs，然而这是有问题的，因为会存在是从这个端点进入但是又从这个端点出的问题，我debug的时候模拟样例真的几乎要受不了了orz所以才要考虑把一条无向边当成两条有向边来存…这样就不会存在这种问题了…这样记忆化搜索写起来也很简单了…</p><p>哎这道题我写了好几个版本QAQ又一直纠错就很难受qwq</p><p>总结一点吧 一定要把所有细节都考虑好再写 否则debug的话心态会炸QAQ还有实在不行的时候 就一定要全部推翻重写 真的！</p><h4 id="3-25"><a href="#3-25" class="headerlink" title="3.25"></a>3.25</h4><h5 id="CodeForces934C"><a href="#CodeForces934C" class="headerlink" title="CodeForces934C"></a>CodeForces934C</h5><p>题意：给出一个只有1和2的串，允许翻转一个区间[l,r]，求翻转后最长的非递减子序列长度。</p><p>思路：很容易看出来是dp的题目但是题目看错真是要命QAQ以为是子串所以想着要求每个区间最左边/中间/右边连续最长非递减长度 想着这难道要区间合并什么的嘛QAQ然而 题目不是这样的 subsequence是子序列的意思 substring才是子串</p><p>因为数字只会出现1和2，所以把这个数列可以分成三部分，左部分找1的最长子序列，右部分找2的最长子序列，中间部分因为是翻转的，所以就找最长非递增子序列，枚举左右端点dp即可。</p><p>dp(i)(j)(k):[i,j]中以k结尾的最长非递增序列长度。</p><p>转移一下就可以了。</p><h4 id="3-29"><a href="#3-29" class="headerlink" title="3.29"></a>3.29</h4><h5 id="51nod1052"><a href="#51nod1052" class="headerlink" title="51nod1052"></a>51nod1052</h5><p>题意：N个整数组成的序列a[1],a[2],a[3],…,a[n]，将这N个数划分为互不相交的M个子段，并且这M个子段的和是最大的。如果M &gt;= N个数中正数的个数，那么输出所有正数的和。</p><p>思路：考虑dp(i)(j)：前i个数被分为j段的最大和（包括第i个数）。</p><p>可以知道有两种转移，一种是加在前一段里面，即dp(i-1)(j)+a[i]，还有一种是当成另外一段，即dp(k)(j-1)+a[j] (k&lt;i)。</p><p>所以dp(i)(j)=max(dp(i-1)(j)+a[i],max(dp(k)(j-1)+a[j])(k&lt;i))。</p><p>这里k遍历的话n^3会超时，所以要开个数组pre(j-1)来记录之前的所有dp(k)(j-1)，所以这个内层循环应该倒着来。</p><h4 id="3-30"><a href="#3-30" class="headerlink" title="3.30"></a>3.30</h4><p>做dp每次看到AC的时候就感觉好开心hhh（毕竟都是自己做的</p><p>不过每次写debug得有点多 注意写的时候要仔细啊</p><h5 id="51nod1503"><a href="#51nod1503" class="headerlink" title="51nod1503"></a>51nod1503</h5><p>题意：刚开始的时候猪站在(1,1),他的目标是走到(n,m)。他只会往(r+1,c)或(r,c+1)走。猪经过的路径要构成一个回文。数一数从(1,1)到(n,m)有多少条路径。答案可能非常巨大，请输出对 109+7 取余后的结果。</p><p><img src="https://img.51nod.com/upload/000FBF15/08D2AA138BF808260000000000000009.png" srcset="/img/loading.gif" alt="img"></p><p>思路：一看就知道是一道双线程的dp，就跟以前做的更难的矩阵取数问题一样。</p><p>所以当然也是开三维啦，dp(i)(j)(k)：走i步到(j,2+i-j)(k,n+m-i-k)的漂亮路径数。</p><p>边界条件是分奇偶的，就是搞个st来表示最长的步数，然后分奇偶来赋值1，这里也要注意偶数步数的时候，两个当前的位置应该是相邻的，要判一下。</p><p>转移也是很简单的，倒推就可以了。dp(i)(j)(k)=dp(i+1)(j)(k)+dp(i+1)(j-1)(k)+dp(i+1)(j)(k+1)+dp(i)(j-1)(k+1)。</p><p>因为三维而且用long long数组会很大所以当然是用滚动数组啦。</p><p>因为是滚动数组所以每次dp(i%2)(j)(k)要清零呀QAQ因为这个WA了一发QAQ</p><p>细节有点多越界啊啥的要注意呀qwq</p><p>听说这是CF DIV2的E题难度？那我做出了真是美滋滋hhh</p><h4 id="3-31"><a href="#3-31" class="headerlink" title="3.31"></a>3.31</h4><h5 id="51nod1043"><a href="#51nod1043" class="headerlink" title="51nod1043"></a>51nod1043</h5><p>题意：1个长度为2N的数，如果左边N个数的和 = 右边N个数的和，那么就是一个幸运号码。给出一个N，求长度为2N的幸运号码的数量。由于数量很大，输出数量 Mod 10^9 + 7的结果即可。</p><p>思路：今天做一个数位dp。</p><p>因为这个数字由两部分组成，所以考虑dp(i)(j):长度为i和为j的数字，则dp(i)(j)=∑dp(i)(j-k),0&lt;=k&lt;=9。</p><p>这里还要考虑是否有前导0，前半部分是不能有前导0的，后半部分是可以有的，可以分别统计dp1,dp2，区别就在于边界条件，如果可以有前导0的话dp1(1)(0)=1。</p><p>统计的时候用乘法原理。</p><h4 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h4><h5 id="CodeForces919D"><a href="#CodeForces919D" class="headerlink" title="CodeForces919D"></a>CodeForces919D</h5><p>题意：给出一张有向图，给每个结点一个字母，定义路径的值为这条路上的出现最多的字母出现的次数，求这张图中所有路径中路径的值的最大值，如果可以任意大的话，就输出-1。</p><p>思路：容易可以看出这是一个树形dp，因为每个结点都只是一个小写字母，所以dp(i)(j)：到i点j出现的最大次数，有转移方程dp(i)(j)=max(dp(k)(j)),k为i的子结点，而且当j==a[i]-‘a’时，有dp(i)(j)++，边界条件是叶子结点的dp(i)(a[i]-‘a’)为1。</p><p>考虑到任意大的情况就是有环，所以可以在dfs求dp的同时判环。</p><p>这里我智障了QAQ数组开小了导致一直WA…又查不出错 以后就</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 300010</span></code></pre><p>这样写吧。</p><p>也可以用拓扑排序的写法，这里状态转移指的就是父节点而不是子节点了。</p><p>因为拓扑排序的步骤：</p><p> (1)从有向图中选取一个没有前驱(即入度为0)的顶点，并输出之; </p><p> (2)从有向图中删去此顶点以及所有以它为尾的弧;</p><p>重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。</p><p>如何通过拓扑排序判断图中是否有环：拓扑排序之后，若还剩有点，则表示有环。</p><h4 id="4-6"><a href="#4-6" class="headerlink" title="4.6"></a>4.6</h4><h5 id="计蒜客题"><a href="#计蒜客题" class="headerlink" title="计蒜客题"></a>计蒜客题</h5><p>题意：有一个长度为n且由a和b组成的字符串，他把这个字符串划分成了若干段回文子串，如”abbaaba” =&gt; “abba” + “aba”是一种划分方案。每个划分方案对答案的贡献是，划分的不同部分的长度的乘积，上述贡献即为4*3=12。问所有有效划分方案贡献的总和是多少。对答案mod1000000007输出。</p><p>思路：回文的动态规划好像经常用的是一维的，而且转移方程也类似。</p><p>dp[i]:前i个字符的最大贡献。</p><p>以题目为例子，dp[0]=1，dp[1]=1，dp[2]=dp[1]×1，dp[3]=dp[2]×1+dp[1]×2，dp[4]=dp[3]×1+dp[0]×4（这里解释了为什么dp[0]=1），dp[5]=dp[4]×1+dp[3]×2。</p><p>所以有转移方程dp[i]=dp[j-1]×(i-j+1)(i到j为回文)。</p><p>预处理一下i到j是否为回文（见上文）。</p><h4 id="4-11"><a href="#4-11" class="headerlink" title="4.11"></a>4.11</h4><h5 id="ZOJ4019"><a href="#ZOJ4019" class="headerlink" title="ZOJ4019"></a>ZOJ4019</h5><p>最近一直在做其他题…所以之前的题到现在才补emmmm</p><p>题意：给出两类物品，这两类物品的单位价值分别是k1，k2，再给出这两类物品中每个物品所占的体积，现有体积为c的背包，定义价值为单位价值*当前背包剩余体积，问背包能装下的最大的价值。</p><p>思路：我刚开始想的是把两类物品直接dp，像这样dp(i)(j):选到第i个物品背包剩余体积为j，但是这样是不可行的，因为c&lt;1e7，所以考虑其他思路，看到只有两类，而且这两类价值都是一样的，所以这肯定是要利用的一个条件。</p><p>先贪心，因为每类物品价值是一样的，所以尽可能放体积小的，排序一下。</p><p>考虑dp(i)(j)：取前i个第一类，前j个第二类的最大价值。</p><p>所以有转移方程：dp(i)(j)=max(dp(i-1)(j)+k1×(c-prea[i]-preb[j]),dp(i)(j-1)+k2×(c-prea[i]-preb[j]))（prea,preb都是前缀和）。</p><p>边界条件就是dp(0)(i)和dp(i)(0)。</p><p>因为T有500组，500×2000×2000=2e9，所以肯定要剪枝。</p><p>由单调性容易想到如果一次c-prea[i]-preb[j]小于0，后面肯定都不用算了，这里我还犯了个小错误，我是直接退出两重循环了，其实并不是啊hhh，单调性是只属于每一重的。</p><p>dp也不要每次清零了，直接赋值就好了，所以ans每次算出dp(i)(j)后直接更新。</p><p>说一句，不要总是乱交，在submit之前再看看自己的程序，要确定没问题之后再交啊。</p><h4 id="4-18"><a href="#4-18" class="headerlink" title="4.18"></a>4.18</h4><h5 id="CodeForces940E"><a href="#CodeForces940E" class="headerlink" title="CodeForces940E"></a>CodeForces940E</h5><p>题意：给你一个数列，你可以划分成几个部分，每个部分的价值是除去前[len/k]小的数的和。求价值的最小值。</p><p>思路：因为总和不变，就是要让被删除的数字的总和尽可能大。</p><p>先是猜测分组的len肯定只有k和1，因为k可以保证不会浪费，尽可能使len/k整除，这样的贪心可以删除尽可能多的数字。</p><p>贪心之后就可以dp了，dp(i):到第i个数字删掉的元素的最大和。</p><p>转移方程：dp(i)=max(dp(i-1),dp(i-k)+min(a[i-k+1],a[i-k+2]…a[i]))，即该数字一个数一组和该数字所在的组(len=k)被删掉最小值的情况。</p><p>所以只要用各种方法查询最小值就可以了，我用的是ST表。</p><h5 id="CodeForces932E"><a href="#CodeForces932E" class="headerlink" title="CodeForces932E"></a>CodeForces932E</h5><p>题意：给定n,k,求</p><script type="math/tex; mode=display">\sum_{i=1}^nC_n^i*i^k</script><p>,其中n&lt;=1e9,k&lt;=5e3。</p><p>思路：没有思路的一道题…刚开始以为这是有公式的或者可以找规律的…等打出表发现自己太天真了…看了题解 有三种解决方法 一种是求导+dp 还有一种是组合数学+dp 还有一种斯科林数的方法 都好强啊orz。</p><p>看了一种自己能够接受的，组合+dp的思路。</p><p>其实这个式子可以转化成一个组合问题：把n种物品放入k个箱子（每个箱子只能放一种）的方案数。妙啊orz。</p><p>那么如何解决这个问题呢？</p><p>这里就要用dp了，dp(i)(j):到第i个箱子放j种的方案数。看起来n&lt;=1e9不能这样设计状态，实际上这是假的，箱子总共也就k个呀…</p><p>转移方程就可以写了：dp(i)(j)=dp(i-1)(j)×j+dp(i-1)(j-1)×(n-j+1)，即第i个箱子选哪一种的情况。</p><p>那么答案如何表示？</p><p>答案就是<script type="math/tex">\sum_{i=1}^n dp[k][i]*2^{n-i}</script>，为什么这里要乘<script type="math/tex">2^{n-i}</script>呢？因为考虑到问题里可能存在比如说预选了4种，但是实际上可能只用了2种的情况，所以这里也要存在这种情况，所以剩下的n-i种可能被选了可能没被选。</p><p>好厉害啊这道题居然还可以这么转化orz学到了hhh</p><h4 id="4-26"><a href="#4-26" class="headerlink" title="4.26"></a>4.26</h4><h5 id="CodeForces946F"><a href="#CodeForces946F" class="headerlink" title="CodeForces946F"></a>CodeForces946F</h5><p>题意：定义F(x)为F(x-1)与F(x-2)的连接（其中F(0) = ‘0’,F(1) = ‘1’）。<br>给出一个长度不超过100的字符串s，询问s在F(x)的所有子序列中出现了多少次。</p><p>思路：</p><p>没思路看题解做的QAQ</p><p>dp(i)(j)(k):s(j,k)在F(i)的所有子序列中出现的总次数。</p><p>一般情况，</p><p>dp(i)(j)(k)+=dp(i-1)(j)(k)，</p><p>dp(i)(j)(k)+=dp(i-2)(j)(k)，</p><p>dp(i)(j)(k)+=dp(i-1)(j)(l)*dp(i-2)(l)(k)，</p><p>在dp(i-1)(j)(k)中当k==n的时候，f(i-2)中可以随便选，</p><p>在dp(i-2)(j)(k)中当j==1的时候，f(i-1)中可以随便选，</p><p>所以，</p><p>dp(i)(j)(k)+=dp(i-1)(j)(k)*(k==n?(2^len(f(i-2))):1)，</p><p>dp(i)(j)(k)+=dp(i-2)(j)(k)*(j==1?(2^len(f(i-1))):1)，</p><p>dp(i)(j)(k)+=dp(i-1)(j)(l)*dp(i-2)(l)(k)。</p><h4 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h4><h5 id="luoguP1140"><a href="#luoguP1140" class="headerlink" title="luoguP1140"></a>luoguP1140</h5><p>题意：给出两个基因序列，根据<img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fszcufstnjj307s04q74a.jpg" srcset="/img/loading.gif" alt="img">求出基因相似度。不等长可以在其中加-，如<img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fszcujjm5sj308001nwec.jpg" srcset="/img/loading.gif" alt="img">。规定两个基因的相似度为所有对应方法中，相似度最大的那个。</p><p>思路：</p><p><script type="math/tex">dp[i][j]</script> :前i个与前j个匹配的最大基因相似度。</p><p><script type="math/tex">dp[i][j]=max\{dp[i][j],dp[i-1][j]+val(a[i],'-'\}</script>：a[i]与’-‘匹配。</p><p><script type="math/tex">dp[i][j]=max\{dp[i][j],dp[i][j-1]+val('-','b[j]'\}</script>：’-‘与b[j]匹配。</p><p><script type="math/tex">dp[i][j]=max\{dp[i][j],dp[i-1][j]+val(a[i-1],b[j-1]\}</script>：a[i]与b[j]匹配。</p><p>注意边界条件即可。</p><h4 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h4><h5 id="GCPC2015J"><a href="#GCPC2015J" class="headerlink" title="GCPC2015J"></a>GCPC2015J</h5><p>题意：有个地方只能用金币和银币，它们的汇率为g，刚开始你有c个金币，他要去n个商家那里买东西。每个商家找零只能用一整袋的银币，每袋银币的个数为pi，商家分为greed，honest和generous三种类型，greed找零的时候是向下取整的，honest是四舍五入的，generous是向上取整的，每个商品的价格为si(si&lt;g)，而且你很同情generous，你有银币可以直接付的话就直接付。问你最多可以买几个商品。</p><p>思路：</p><p><script type="math/tex">dp[i][j][k]</script>:处理完第i个商品还剩j个金币k个银币时能买到的最多商品。</p><p>有转移：</p><p>不买：<script type="math/tex">dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k])</script>；</p><p>用银币买：<script type="math/tex">dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k+s_i]+1)(k+s_i≤g*c)</script>；</p><p>用金币买:<script type="math/tex">dp[i][j][k]=max(dp[i][j][k],dp[i-1][j+1][k+找零]+1)</script>，</p><p>其中找零可以借助ceil,floor,round（四舍五入）函数计算，</p><p>因为对于generous如果银币可以付的话就不用金币付，所以当k+找零&gt;=si的话，就不能用金币买了。</p><p>这里注意初始化dp数组要为-INF而不是0，因为有些状态是不能到达的。</p><p>边界条件是<script type="math/tex">dp[0][c][0]=0</script>。</p><h4 id="8-21"><a href="#8-21" class="headerlink" title="8.21"></a>8.21</h4><h5 id="CTU2017F"><a href="#CTU2017F" class="headerlink" title="CTU2017F"></a>CTU2017F</h5><p>题意：给出n个数字，一对相同的数字里面可以包一对相同的数字，同理可以一直包下去，问这样的数字对数最多有多少。</p><p>思路：</p><p><script type="math/tex">dp[i][j]</script>：i到j这样的数字的最大对数。</p><p>有转移：</p><p><script type="math/tex">dp[i][j]=max(dp[i+1][j],dp[i][j-1])</script>;</p><p>如果<script type="math/tex">a[i]==a[j]</script>，有转移<script type="math/tex">dp[i][j]=max(dp[i][j],dp[i+1][j-1]+1)</script>。</p><h4 id="8-27"><a href="#8-27" class="headerlink" title="8.27"></a>8.27</h4><p>做几道区间DP，区间DP常常是外层循环是长度，内存循环是起点。</p><h5 id="POJ2955"><a href="#POJ2955" class="headerlink" title="POJ2955"></a>POJ2955</h5><p>题意：给出一个含’(‘，’)’，’[‘，’]’的括号序列，求最长的括号匹配子序列。</p><p>思路：区间dp的典型套路，<script type="math/tex">dp[i][j]</script>：[i,j]区间最长的括号匹配子序列。除了跟上题一样的转移外，还有<script type="math/tex">dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j])</script>，就是()()这种情况。</p><h5 id="POJ1651"><a href="#POJ1651" class="headerlink" title="POJ1651"></a>POJ1651</h5><p>题意：给出n个数字，每次取出一个数字a[i]，价值为<script type="math/tex">a[i-1]*a[i]*a[i+1]</script>，直到只剩下最前面一个数字和最后面一个数字。问最小价值为多少。</p><p>思路：<script type="math/tex">dp[i][j]</script>：[i,j]最小价值。</p><p><script type="math/tex">dp[i][j]=max(dp[i][k]+dp[k][j]+a[i]*a[k]*a[j])\ |\ i+1\le k \le j-1</script>。</p><p>从长度为3开始循环，外层是长度，内层是i，再枚举k。</p><p>如何理解？</p><p>如果有三个数字，<script type="math/tex">dp[1][3]=dp[1][2]+dp[2][3]+a[1]*a[2]*a[3]</script>。</p><p>如果有四个数字，<script type="math/tex">dp[1][4]=max(dp[1][2]+dp[2][4]+a[1]*a[2]*a[4],dp[1][3]+dp[3][4]+a[1]*a[3]*a[4])</script>。</p><p>如果有五个数字，</p><p><script type="math/tex">dp[1][5]=max(dp[1][2]+dp[2][5]+a[1]*a[2]*a[5],dp[1][3]+dp[3][5]+a[1]*a[3]*a[5],dp[1][4]+dp[4][5]+a[1]*a[4]*a[5])</script>。</p><p>画一画会明白。</p><p>因为对于一个区间来说，最后肯定只剩下最前面的数字和最后面的数字，所以对于<script type="math/tex">dp[i][k]</script>和<script type="math/tex">dp[k][j]</script>这两个区间剩下的数字肯定只有a[i],a[k],a[j]，所以转移是这样子的。</p><h5 id="LightOj1422"><a href="#LightOj1422" class="headerlink" title="LightOj1422"></a>LightOj1422</h5><p>题意：一个人要按顺序穿着n件衣服，身上的衣服可以穿好几件，但是如果脱掉以后这件衣服就报废了。问最少要几件衣服。</p><p>思路：<script type="math/tex">dp[i][j]</script>：从i到j天最少要穿的衣服。</p><p>对于第i件衣服，如果之后的区间不再重复利用了，这种情况的转移为<script type="math/tex">dp[i][j]=dp[i+1][j]+1</script>。</p><p>如果这件衣服在后面的区间可以重复利用，则选择区间的穿的衣服种类相同的天数，<script type="math/tex">dp[i][j]=dp[i][k-1]+dp[k+1][j]</script>，因为要选第k天作为重复利用，那么要把[i,k-1]的衣服一件一件脱下来，那么[i,k-1]和[k+1,j]的代价是要独立算的。</p><h4 id="9-25"><a href="#9-25" class="headerlink" title="9.25"></a>9.25</h4><h5 id="徐州网络赛B"><a href="#徐州网络赛B" class="headerlink" title="徐州网络赛B"></a>徐州网络赛B</h5><p>题意：有n轮游戏，有初始分数m，有A和B两个人，每轮游戏可以有三个选项，加某个数，减某个数，取相反数。A总是想得到GE，B总是想得到BE，GE即最后分数&gt;=k，BE即最后分数&lt;=l，其他都是NE。如果自己不能赢的话，那宁愿NE也不要对手赢。A先手。问最后的结果。其中<script type="math/tex">1≤n≤1000, −100≤m≤100</script>。</p><p>思路：可以想到可以用记忆化搜索。状态就是到第i轮分数为j的结果。1000*200是可以接受的。对于A来说，尽可能要GE，不行的话就NE，之后才是BE，对于B来说，尽可能要BE，不行的话就NE，之后才是GE。脑补一下写个记忆化搜索就可以了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod1019 树状数组求逆序数</title>
    <link href="/2018/02/26/51nod1019-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E9%80%86%E5%BA%8F%E6%95%B0/"/>
    <url>/2018/02/26/51nod1019-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E9%80%86%E5%BA%8F%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>题意</strong>：在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。</p><p>如2 4 3 1中，2 1，4 3，4 1，3 1是逆序，逆序数是4。给出一个整数序列，求该序列的逆序数。</p><p><strong>思路</strong>：</p><p><a href="https://www.nowcoder.com/live/153/11/1" target="_blank" rel="noopener">https://www.nowcoder.com/live/153/11/1</a> 53min开始</p><p>举个栗子：</p><p>有5个数，分别为5 3 4 2 1，</p><p>当读入数据a=5时，d为：0 0 0 0 0，前缀和为0，4-0=4，ans+=4然后d变成：0 0 0 0 1；</p><p>当读入数据a=3时，d为：0 0 0 0 1，前缀和为0，2-0=2，ans+=2，然后d变成：0 0 1 0 1；</p><p>当读入数据a=4时，d为：0 0 1 0 1，前缀和为1，3-1=2，ans+=2，然后d变成：0 0 1 1 1；</p><p>当读入数据a=2时，d为：0 0 1 1 1，前缀和为0，1-0=1，ans+=1，然后d变成：0 1 1 1 1；</p><p>当读入数据a=1时，d为：0 1 1 1 1，前缀和为0，0-0=0，然后d变成：1 1 1 1 1。</p><p>当数据a过大时，数组可能装不下，这时候就需要离散化，用sort+unique+二分离散即可。</p><p><strong>代码</strong>：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> a[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> b[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> d[<span class="hljs-number">50010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//查询前缀和</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        res+=d[x];        x-=lowbit(x);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span><span class="hljs-comment">//单点修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(x&lt;=n)    &#123;        d[x]+=v;        x+=lowbit(x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]),b[i]=a[i];    sort(b+<span class="hljs-number">1</span>,b+n+<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> len=unique(b+<span class="hljs-number">1</span>,b+n+<span class="hljs-number">1</span>)-b;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">int</span> pos=lower_bound(b+<span class="hljs-number">1</span>,b+len,a[i])-b;        ans+=pos<span class="hljs-number">-1</span>-query(pos);        add(pos,<span class="hljs-number">1</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces469D 并查集</title>
    <link href="/2018/02/25/CodeForces469D-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2018/02/25/CodeForces469D-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p><strong>题意</strong>：有n个互不相同的整数： p1,p2,…,pn 。把这些整数分到两个集合A和B里边。但是要符合下面两个条件。</p><p>如果x属于A，那么a-x也肯定属于A。</p><p>如果x属于B，那么b-x也肯定属于B。</p><p>判断一下是否存在一种方案来分配这些数字到集合A，B中。</p><p>注意：如果一个集合为空也是可以的。</p><p><strong>思路</strong>：思路是很简单的就是迷之WA…牛客上面的数据水得可以快排+二分都过了下标明明都不对…果然是用脚造的数据…然后用并查集做结果一直WA在第8组数据…可是找不出来哪儿错了…找题解结果都是千篇一律的代码 可怕难道你们的思路都一模一样的嘛qwq本弱找不出错哪儿了先放在这儿…</p><p><strong>update</strong>：查出错误了 a-num[i]可以不等于b-num[i]啊 少考虑了一种a-num[i]存在而且b-num[i]存在的情况</p><p>对于一个x来说，能分成以下4种情况（这里a!=b）：</p><p>1.a-x不存在，b-x不存在。这种情况直接输出NO。</p><p>2.a-x存在，b-x不存在。这种情况把x和a-x放在集合A中。</p><p>3.a-x不存在，b-x存在。这种情况把x和b-x放在集合B中。</p><p>4.a-x存在，b-x存在。这种情况比较我们就不能直接确定要放A还是要放B了。</p><p>1⃣把x和a-x放入集合A，那么b-x肯定也要放入集合A，那么就说明存在y使得y=a-b+x。</p><p>2⃣把x和b-x放入集合B，那么a-x肯定也要放入集合B，那么就说明存在y使得y=b-a+x。</p><p>假设有y=a-b+x和y=b-a+x同时存在，则有a=b，矛盾。所以上面两种情况只可能存在一种或都不存在。如果都不存在，那么我们就无法决定把x和a-x和b-x放到集合A中还是集合B中，因为放到那一边都会剩下另一个无法去放，所以就输出NO。这里用并查集来维护即可。</p><p><strong>代码</strong>：</p><p>WA代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> par[<span class="hljs-number">100010</span>],high[<span class="hljs-number">100010</span>],num[<span class="hljs-number">100010</span>];<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;mp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)    &#123;        par[i]=i;        high[i]=<span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> par[x]=<span class="hljs-built_in">find</span>(par[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    x=<span class="hljs-built_in">find</span>(x);    y=<span class="hljs-built_in">find</span>(y);    <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(high[x]&lt;high[y])par[x]=y;    <span class="hljs-keyword">else</span>    &#123;        par[y]=x;        <span class="hljs-keyword">if</span>(high[x]==high[y])high[x]++;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a,b,MAX=<span class="hljs-number">-1</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;a,&amp;b);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;num[i]);        MAX=<span class="hljs-built_in">max</span>(MAX,num[i]);        mp[num[i]]=i;    &#125;    <span class="hljs-keyword">if</span>(MAX&gt;=<span class="hljs-built_in">max</span>(a,b))&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;    init();    <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>&amp;&amp;flag==<span class="hljs-number">0</span>;i++)    &#123;        <span class="hljs-comment">//printf("i=%d par[i]=%d find(i)=%d\n",i,par[i],find(i));            //printf("i=%d\n",i);</span>        <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(mp[b-num[i]])        &#123;            <span class="hljs-comment">//printf("(%d)\n",par[1]);</span>            <span class="hljs-comment">//printf("!\n");</span>            unite(<span class="hljs-number">1</span>,i);            unite(<span class="hljs-number">1</span>,mp[b-num[i]]);            sign++;        &#125;        <span class="hljs-keyword">if</span>(sign==<span class="hljs-number">0</span>&amp;&amp;mp[a-num[i]])        &#123;            <span class="hljs-comment">//printf("?\n");</span>            unite(<span class="hljs-number">0</span>,i);            unite(<span class="hljs-number">0</span>,mp[a-num[i]]);            sign++;        &#125;        <span class="hljs-keyword">if</span>(sign==<span class="hljs-number">0</span>)flag++;    &#125;    <span class="hljs-keyword">if</span>(flag!=<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n+<span class="hljs-number">1</span>;i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,<span class="hljs-built_in">find</span>(i));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,<span class="hljs-built_in">find</span>(n+<span class="hljs-number">1</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>AC代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> par[<span class="hljs-number">100010</span>],high[<span class="hljs-number">100010</span>],num[<span class="hljs-number">100010</span>];<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;mp;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)    &#123;        par[i]=i;        high[i]=<span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> par[x]=<span class="hljs-built_in">find</span>(par[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    x=<span class="hljs-built_in">find</span>(x);    y=<span class="hljs-built_in">find</span>(y);    <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(high[x]&lt;high[y])par[x]=y;    <span class="hljs-keyword">else</span>    &#123;        par[y]=x;        <span class="hljs-keyword">if</span>(high[x]==high[y])high[x]++;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a,b,MAX=<span class="hljs-number">-1</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;a,&amp;b);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;num[i]);        MAX=<span class="hljs-built_in">max</span>(MAX,num[i]);        mp[num[i]]=i;    &#125;    <span class="hljs-keyword">if</span>(MAX&gt;=<span class="hljs-built_in">max</span>(a,b))&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;    init();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)    &#123;        <span class="hljs-keyword">if</span>(mp[b-num[i]])unite(i,mp[b-num[i]]);        <span class="hljs-keyword">else</span> unite(i,<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(mp[a-num[i]])unite(i,mp[a-num[i]]);        <span class="hljs-keyword">else</span> unite(i,<span class="hljs-number">1</span>);<span class="hljs-comment">//因为只能属于其中一类</span>    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>)==<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>))<span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)==<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>))<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0"</span>);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1"</span>);            <span class="hljs-keyword">if</span>(i!=n+<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wannafly挑战赛10</title>
    <link href="/2018/02/24/Wannafly%E6%8C%91%E6%88%98%E8%B5%9B10/"/>
    <url>/2018/02/24/Wannafly%E6%8C%91%E6%88%98%E8%B5%9B10/</url>
    
    <content type="html"><![CDATA[<h5 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h5><p>题意：给几个串，其中有空符号#，再给新串，问新串能否由这些串按顺序拿出一个字符得到（空符号直接忽略）。</p><p>思路：dp。其实这个dp可以由dfs转化而来 写个记忆化搜索也ojbk 可是我dp理解得不好做的时候不知道要存什么状态 其实我写的dfs那两个参数就是状态啊qwq其实是没理解好怎么会有状态被重复搜了啊qwq需要再深刻一点啊</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">char</span> a[<span class="hljs-number">310</span>];<span class="hljs-keyword">bool</span> ex[<span class="hljs-number">310</span>][<span class="hljs-number">30</span>];<span class="hljs-comment">//这个串是否存在这个字符</span><span class="hljs-keyword">char</span> s[<span class="hljs-number">10010</span>];<span class="hljs-keyword">bool</span> dp[<span class="hljs-number">310</span>][<span class="hljs-number">310</span>];<span class="hljs-comment">//匹配到第i个串和标准串的第j个字符的状态</span><span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> len;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> q;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)        &#123;            <span class="hljs-keyword">if</span>(a[j]!=<span class="hljs-string">'#'</span>)ex[i][a[j]-<span class="hljs-string">'a'</span>]=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">else</span> ex[i][<span class="hljs-number">26</span>]=<span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-keyword">while</span>(q--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s+<span class="hljs-number">1</span>);        len=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(len&gt;n)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);<span class="hljs-keyword">continue</span>;&#125;        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=len;j++)            &#123;                <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">0</span>&amp;&amp;ex[i][s[j]-<span class="hljs-string">'a'</span>])dp[i][j]|=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];                <span class="hljs-keyword">if</span>(ex[i][<span class="hljs-number">26</span>])dp[i][j]|=dp[i<span class="hljs-number">-1</span>][j];            &#125;        &#125;        <span class="hljs-keyword">if</span>(dp[n][len])<span class="hljs-built_in">printf</span>(<span class="hljs-string">"YES\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"NO\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录</title>
    <link href="/2018/02/23/%E6%AF%8F%E6%97%A5%E8%AE%A1%E5%88%92/"/>
    <url>/2018/02/23/%E6%AF%8F%E6%97%A5%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>把不会的算法尽量都补上吧。</p><p>虽说知道得多也不一定做得出题但是知道得少的话就连做出题的机会都没有了啊。</p><p>没有时间用来颓了啊。</p><p>我永远喜欢ACM.jpg</p><hr><p>近期list：</p><p>费用流</p><p>主席树</p><p>splay</p><hr><p>补题：</p><p>HDU：</p><p>HDU6304 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6304" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6304</a></p><p>HDU6305 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6305" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6305</a></p><p>HDU6311 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6311" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6311</a></p><p>HDU6313 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6313" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6313</a></p><p>HDU6326 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6326" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6326</a></p><p>HDU6338 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6338" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6338</a></p><p>HDU6357 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6357" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6357</a></p><p>HDU5445 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5445" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=5445</a></p><p>HDU5881 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5881" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=5881</a></p><p>HDU5889 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5889" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=5889</a></p><p>HDU6393 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6393" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6393</a></p><p>HDU6394 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6394" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6394</a></p><p>HDU6400 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6400" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6400</a></p><p>HDU6424 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6424" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6424</a></p><p>HDU6430 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6430" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6430</a></p><p>HDU6442 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6442" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6442</a></p><p>计蒜客：</p><p>BAPC2014 FinalD <a href="https://nanti.jisuanke.com/t/28314" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28314</a></p><p>ACM训练联盟周赛 <a href="https://www.jisuanke.com/contest/1444" target="_blank" rel="noopener">https://www.jisuanke.com/contest/1444</a></p><p>ACM-ICPC Programming Training Contest（Pro.WHU）<a href="https://www.jisuanke.com/contest/1483" target="_blank" rel="noopener">https://www.jisuanke.com/contest/1483</a></p><p>GCPC M<a href="https://nanti.jisuanke.com/t/28864" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28864</a></p><p>The 2018 ACM-ICPC Chinese Collegiate Programming Contest E <a href="https://nanti.jisuanke.com/t/28405" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28405</a></p><p>The 2018 ACM-ICPC Chinese Collegiate Programming Contest G <a href="https://nanti.jisuanke.com/t/28407" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28407</a></p><p>The 2018 ACM-ICPC Chinese Collegiate Programming Contest K <a href="https://nanti.jisuanke.com/t/28411" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28411</a></p><p>The 2018 ACM-ICPC Chinese Collegiate Programming Contest L <a href="https://nanti.jisuanke.com/t/28412" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28412</a></p><p>The 2018 ACM-ICPC China JiangSu Provincial Programming Contest H <a href="https://nanti.jisuanke.com/t/28872" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28872</a></p><p>ACM训练联盟周赛 C/URAL 1018 <a href="https://nanti.jisuanke.com/t/29228" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29228</a> （为什么j的循环是倒序的？）</p><p>ACM-ICPC 2017 Asia Urumqi C <a href="https://nanti.jisuanke.com/t/28962" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28962</a></p><p>ACM-ICPC 2017 Asia Urumqi H <a href="https://nanti.jisuanke.com/t/28967" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/28967</a></p><p>ACM-ICPC 2015 Shenyang Preliminary Contest C <a href="https://nanti.jisuanke.com/t/29122" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29122</a></p><p>ACM-ICPC 2015 Shenyang Preliminary Contest I <a href="https://nanti.jisuanke.com/t/29128" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29128</a></p><p>ACM Greater New York 2017 C <a href="https://nanti.jisuanke.com/t/29343" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29343</a></p><p>ACM Greater New York 2017 D <a href="https://nanti.jisuanke.com/t/29344" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/29344</a></p><p>CTU 2017 G <a href="https://nanti.jisuanke.com/t/30297" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/30297</a></p><p>NCPC2014 I <a href="https://nanti.jisuanke.com/t/30377" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/30377</a></p><p>沈阳网络赛B <a href="https://nanti.jisuanke.com/t/31443" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/31443</a></p><p>徐州网络赛J <a href="https://nanti.jisuanke.com/t/31462" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/31462</a></p><p>徐州网络赛C <a href="https://nanti.jisuanke.com/t/31455" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/31455</a></p><p>焦作网络赛E <a href="https://nanti.jisuanke.com/t/31714" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/31714</a></p><p>牛客网：</p><p>2018 ACM 国际大学生程序设计竞赛上海大都会赛重现赛 I <a href="https://www.nowcoder.com/acm/contest/163/I" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/163/I</a></p><p>牛客网暑期ACM多校训练营（第三场） E <a href="https://www.nowcoder.com/acm/contest/141/E" target="_blank" rel="noopener">https://www.nowcoder.com/acm/contest/141/E</a></p><hr><p>专题：</p><p>区间DP</p><p>概率DP</p><p>网络流</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大概是鸡血</title>
    <link href="/2018/02/23/%E5%A4%A7%E6%A6%82%E6%98%AF%E9%B8%A1%E8%A1%80/"/>
    <url>/2018/02/23/%E5%A4%A7%E6%A6%82%E6%98%AF%E9%B8%A1%E8%A1%80/</url>
    
    <content type="html"><![CDATA[<p><a href="http://davidzai.blog.163.com/blog/static/1871262120101823540952/" target="_blank" rel="noopener">http://davidzai.blog.163.com/blog/static/1871262120101823540952/</a></p><p><a href="http://blog.csdn.net/tmeteorj/article/details/17509089" target="_blank" rel="noopener">http://blog.csdn.net/tmeteorj/article/details/17509089</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>随感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mark下博客的某些操作</title>
    <link href="/2018/02/23/mark%E4%B8%8B%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%9F%90%E4%BA%9B%E6%93%8D%E4%BD%9C/"/>
    <url>/2018/02/23/mark%E4%B8%8B%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%9F%90%E4%BA%9B%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h5 id="文章加密插件"><a href="#文章加密插件" class="headerlink" title="文章加密插件"></a>文章加密插件</h5><p><a href="https://github.com/MikeCoder/hexo-blog-encrypt" target="_blank" rel="noopener">https://github.com/MikeCoder/hexo-blog-encrypt</a></p><p>什么是在 hexo 根目录的 <em>package.json</em> 中添加 ‘“hexo-blog-encrypt”: “1.1.*”‘ 依赖？</p><p>cd到blog 然后输入npm install hexo-blog-encrypt@^1.1.* —save 。</p><p><del>可是为啥我用了界面会缩小emmmm？？？</del></p><h5 id="首页显示部分文章"><a href="#首页显示部分文章" class="headerlink" title="首页显示部分文章"></a>首页显示部分文章</h5><p>markdown中加入</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--more--&gt;</span></code></pre><p><del>实测在这个模板下没有什么卵用</del> 其他一些模板下是有用的</p><h5 id="live2d插件"><a href="#live2d插件" class="headerlink" title="live2d插件"></a>live2d插件</h5><p><a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d</a></p><p>不知道为啥用不了可能是哪里没配置好吧 之后再试试</p><h5 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h5><p><a href="https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html" target="_blank" rel="noopener">https://www.cnblogs.com/penglei-it/p/hexo_domain_name.html</a></p><h5 id="图片外链"><a href="#图片外链" class="headerlink" title="图片外链"></a>图片外链</h5><p>只需要在基础语法的括号中填入图片的网络链接即可，现在已经有很多免费/收费图床和方便传图的小工具可选。</p><p>例如：</p><pre><code class="hljs markdown">![<span class="hljs-string">avatar</span>](<span class="hljs-link">http://baidu.com/pic/doge.png</span>)</code></pre><p>还是腾讯云的对象存储好用啊</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p><a href="https://blog.csdn.net/chwshuang/article/details/52350559" target="_blank" rel="noopener">https://blog.csdn.net/chwshuang/article/details/52350559</a></p><h5 id="支持-Mathjax"><a href="#支持-Mathjax" class="headerlink" title="支持 Mathjax"></a>支持 Mathjax</h5><p><a href="https://www.jianshu.com/p/e8d433a2c5b7" target="_blank" rel="noopener">https://www.jianshu.com/p/e8d433a2c5b7</a></p><h5 id="markdown数学公式"><a href="#markdown数学公式" class="headerlink" title="markdown数学公式"></a>markdown数学公式</h5><p>数学公式：<a href="https://blog.csdn.net/zdk930519/article/details/54137476" target="_blank" rel="noopener">https://blog.csdn.net/zdk930519/article/details/54137476</a></p><p>矩阵：<a href="https://blog.csdn.net/bendanban/article/details/44221279" target="_blank" rel="noopener">https://blog.csdn.net/bendanban/article/details/44221279</a></p><p>看个栗子就会用了</p><p>使用$ 符号包裹Tex命令，例如：</p><p><code>$$\sum_{i=1}^n a_i=0$$</code></p><p>输入以上那段代码后你敲一下键盘上的回车键，预览效果就会出现（即可看到如下的数学公式）：</p><script type="math/tex; mode=display">\sum_{i=1}^n a_i=0</script>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络流24题</title>
    <link href="/2018/02/22/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    <url>/2018/02/22/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>开坑开坑。</p><div class="table-container"><table><thead><tr><th>序号</th><th>题目标题</th><th>问题模型</th><th>转化模型</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.luogu.org/problemnew/show/P2756" target="_blank" rel="noopener">飞行员配对方案问题</a></td><td>二分图最大匹配</td><td>最大流</td></tr><tr><td>2</td><td><a href="https://www.luogu.org/problemnew/show/P2762" target="_blank" rel="noopener">太空飞行计划问题</a></td><td>最大权闭合子图</td><td>最小割</td></tr><tr><td>3</td><td><a href="https://www.luogu.org/problemnew/show/P2764" target="_blank" rel="noopener">最小路径覆盖问题</a></td><td>DAG的最小路径覆盖</td><td>最大流</td></tr><tr><td>4</td><td><a href="https://www.luogu.org/problemnew/show/P2765" target="_blank" rel="noopener">魔术球问题</a></td><td>DAG的最小路径覆盖</td><td>最大流</td></tr><tr><td>5</td><td><a href="https://www.luogu.org/problemnew/show/P3254" target="_blank" rel="noopener">圆桌问题</a></td><td>二分图多重匹配</td><td>最大流</td></tr><tr><td>6</td><td><a href="https://www.luogu.org/problemnew/show/P2766" target="_blank" rel="noopener">最长不下降子序列问题</a></td><td></td><td></td></tr><tr><td>7</td><td><a href="https://www.luogu.org/problemnew/show/P2763" target="_blank" rel="noopener">试题库问题</a></td><td>二分图多重匹配</td><td>最大流</td></tr><tr><td>8</td><td><a href="https://www.luogu.org/problemnew/show/P2775" target="_blank" rel="noopener">机器人路径规划问题</a></td><td></td><td></td></tr><tr><td>9</td><td><a href="https://www.luogu.org/problemnew/show/P2774" target="_blank" rel="noopener">方格取数问题</a></td><td>二分图点权最大独立集</td><td>最小割</td></tr><tr><td>10</td><td><a href="https://www.luogu.org/problemnew/show/P1251" target="_blank" rel="noopener">餐巾计划问题</a></td><td></td><td></td></tr><tr><td>11</td><td><a href="https://www.luogu.org/problemnew/show/P2770" target="_blank" rel="noopener">航空路线问题</a></td><td></td><td></td></tr><tr><td>12</td><td><a href="https://www.luogu.org/problemnew/show/P2761" target="_blank" rel="noopener">软件补丁问题</a></td><td></td><td></td></tr><tr><td>13</td><td><a href="https://www.luogu.org/problemnew/show/P2754" target="_blank" rel="noopener">星际转移问题</a></td><td></td><td></td></tr><tr><td>14</td><td><a href="https://www.luogu.org/problemnew/show/P4011" target="_blank" rel="noopener">孤岛营救问题</a></td><td></td><td></td></tr><tr><td>15</td><td><a href="https://www.luogu.org/problemnew/show/P4009" target="_blank" rel="noopener">汽车加油行驶问题</a></td><td></td><td></td></tr><tr><td>16</td><td><a href="https://www.luogu.org/problemnew/show/P4013" target="_blank" rel="noopener">数字梯形问题</a></td><td></td><td></td></tr><tr><td>17</td><td><a href="https://www.luogu.org/problemnew/show/P4015" target="_blank" rel="noopener">运输问题</a></td><td></td><td></td></tr><tr><td>18</td><td><a href="https://www.luogu.org/problemnew/show/P4014" target="_blank" rel="noopener">分配问题</a></td><td></td><td></td></tr><tr><td>19</td><td><a href="https://www.luogu.org/problemnew/show/P4016" target="_blank" rel="noopener">负载平衡问题</a></td><td></td><td></td></tr><tr><td>20</td><td><a href="https://www.luogu.org/problemnew/show/P4012" target="_blank" rel="noopener">深海机器人问题</a></td><td></td><td></td></tr><tr><td>21</td><td><a href="https://www.luogu.org/problemnew/show/P3358" target="_blank" rel="noopener">最长k可重区间集问题</a></td><td></td><td></td></tr><tr><td>22</td><td><a href="https://www.luogu.org/problemnew/show/P3357" target="_blank" rel="noopener">最长k可重线段集问题</a></td><td></td><td></td></tr><tr><td>23</td><td><a href="https://www.luogu.org/problemnew/show/P3356" target="_blank" rel="noopener">火星探险问题</a></td><td></td><td></td></tr><tr><td>24</td><td><a href="https://www.luogu.org/problemnew/show/P3355" target="_blank" rel="noopener">骑士共存问题</a></td><td></td></tr></tbody></table></div><h5 id="飞行员配对方案问题"><a href="#飞行员配对方案问题" class="headerlink" title="飞行员配对方案问题"></a>飞行员配对方案问题</h5><p><strong>题意：</strong></p><p>飞行员匹配二分图最大匹配，并输出匹配方案。</p><p><strong>思路：</strong></p><p>以前是用匈牙利算法，现在用最大流做一做。</p><p>设一个超级源点和一个超级汇点，源点向正飞行员建容量为1的边，正飞行员向匹配的副飞行员建容量为1的边，副飞行员向汇点建容量为1的边，跑一下最大流即可。</p><p>将原图中所有的无向边变为有向边，容量为1。源点连接U,V连接汇点，容量都为1，最大流即为最大匹配。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> s,e;<span class="hljs-comment">//源点、汇点</span><span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">20010</span>];<span class="hljs-comment">//邻接表要开边数的两倍</span><span class="hljs-keyword">int</span> head[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> par[<span class="hljs-number">110</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                par[id]=temp;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;m,&amp;n);    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-built_in">memset</span>(par,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(par));    s=<span class="hljs-number">0</span>;e=n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        add(s,i,<span class="hljs-number">1</span>);        add(i,s,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m+<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        add(i,e,<span class="hljs-number">1</span>);        add(e,i,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">-1</span>&amp;&amp;y==<span class="hljs-number">-1</span>)<span class="hljs-keyword">break</span>;        add(x,y,<span class="hljs-number">1</span>);        add(y,x,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=dinic();    <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"No Solution!\n"</span>);    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)            <span class="hljs-keyword">if</span>(par[i]!=<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,i,par[i]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="太空飞行计划问题"><a href="#太空飞行计划问题" class="headerlink" title="太空飞行计划问题"></a>太空飞行计划问题</h5><p><strong>题意：</strong></p><p>有一些实验可以做，给出每个实验的收益，每个实验需要几个仪器（多个实验可以用同一个仪器），给出每个仪器所需的钱，问最大利润为多少，并输出要做的实验和要买的仪器。</p><p><strong>思路：</strong></p><p>参考博客：<a href="https://www.cnblogs.com/dilthey/p/7565206.html" target="_blank" rel="noopener">https://www.cnblogs.com/dilthey/p/7565206.html</a></p><p>最大权闭合子图。</p><p>定义：</p><p>一个子图（点集）， 如果它的所有的出边都在这个子图当中，那么它就是闭合子图（有一些点，每个点有一些点权（正负都有），要选一个点，就必须要选它所连向的点）。<br>点权和最大的闭合子图就是最大闭合子图。</p><p>构图：</p><p>设s为源点，t为汇点。</p><p>使s连向所有的正权点（非负权点），边权为点权。</p><p>使所有非正权点（负权点）连向t，边权为点权的绝对值。</p><p>若需要选y才能选x，连一条由x到y的边，边权是∞。</p><p>最大点权和=正权点和-最小割。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fsvzv6ymo7j30jm0700t5.jpg" srcset="/img/loading.gif" alt=""></p><p>证明：</p><p>1.最小割一定是简单割</p><p>简单割：割集中所有的边，都与s或t相连接。</p><p>2.简单割一定和一个闭合子图对应</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fsvzv7nrz7j30j4061t90.jpg" srcset="/img/loading.gif" alt=""></p><center>一个简单割</center><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fsvzzi9rhij30p70aat8w.jpg" srcset="/img/loading.gif" alt=""></p><center>记含有点s的是图S，含有点t的是图T，则图S是闭合子图</center><p>由上面两个引理可以知道，最小割也对应了一个闭合子图，接下来证明最小割就是最大权的闭合子图。</p><p>割的容量C(S,T)=T中所有正权点的权值之和+S中所有负权点的权值绝对值之和（这张图中与s相连的点都为正权点，与t相连的点都为负权点，因为在图中，割边为5和3和1，T中所有正权点就相当于最左边的那个点即5，S中所有负权点相当于最右边的点即-3和右边第二个点即-1）。</p><p>闭合子图的权值W=S中所有正权点的权值之和-S中所有负权点的权值绝对值之和。</p><p>则有C(S,T)+W=T中所有正权点的权值之和+S中所有正权点的权值之和=所有正权点的权值之和。</p><p>所以W=所有正权点的权值之和-C(S,T)。</p><p>要使W最大，C(S,T)要最小，即最小割。</p><p>关于求方案，最小割把图分为了s集和t集，求一下s集即可。因为与s相连的都是方案，如果需要这个方案，那么它的结余一定为正，即从s到它的流仍有流量。满流的话结余为0，即dis=-1。</p><p>为什么这样可以求出割呢？因为最小割中的边必定满流，它的逆否命题：不满流的边必定不是最小割的边也一定成立，因此不满流的边连接的两个点一定在同一个集之中，证毕。</p><p>另一种理解：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fswstzckwjj30kd0ebgn8.jpg" srcset="/img/loading.gif" alt="img"></p><p>取值为1就是有流量就割，取值为+∞就是保证不被割。</p><p>求最小割其实就是求最少的花费，设sum是所有实验的带来的收益和，那么sum把所有的收益加起来了，减去花费就是最大获益了，这就是为什么求最小割了。</p><p>所以：最小割是花费，要让花费尽量小。</p><p>那么求最小割了，设最小割是mincut花费，随后要用sum-mincut：</p><ul><li>首先中间的是一定不能切的，切一条绿边的花费就是正无穷了。</li><li>切右边的橙色的边表示：要用该仪器。</li><li>切左边的蓝边：不做该实验。</li></ul><p>画一下图就知道每个割都满足如果一个实验要选，那么它所有对应的仪器要买，或者这个实验不选，那么直接失去这个实验的收入。  </p><p>如S-&gt;a1,b1-&gt;T,b4-&gt;T,b6-&gt;T为一个割，表示不做第一个实验（能不买的仪器不买），做第二个实验。如b1-&gt;T,b2-&gt;T,b3-&gt;T,b4-&gt;T,b5-&gt;T,b6-&gt;T,b7-&gt;T也为一个割，表示两个实验都做。</p><p>关于求方案，因为最小割中的边必定满流，最小割的与s相连的结点是不做的实验，所以做的实验是与s相连的有结余的结点，即dis!=-1的结点，最小割的与t相连的结点是要买的器材，所以买的器材是与t相连的满流的结点，那么从s开始有结余，即dis!=-1。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> s,e;<span class="hljs-comment">//源点、汇点</span><span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">20010</span>];<span class="hljs-comment">//邻接表要开边数的两倍</span><span class="hljs-keyword">int</span> head[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">110</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,x;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">char</span> tools[<span class="hljs-number">1000</span>];    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;m,&amp;n);    n+=m;    s=<span class="hljs-number">0</span>;e=n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        sum+=x;        add(<span class="hljs-number">0</span>,i,x);add(i,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">cin</span>.getline(tools,<span class="hljs-number">1000</span>);        <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>,tool;        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">sscanf</span>(tools+pos,<span class="hljs-string">"%d"</span>,&amp;tool)==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-comment">//printf("%d\n",tool);</span>            add(i,tool+m,INF);add(tool+m,i,<span class="hljs-number">0</span>);            <span class="hljs-keyword">if</span>(tool==<span class="hljs-number">0</span>)pos++;            <span class="hljs-keyword">else</span>            &#123;                <span class="hljs-keyword">while</span>(tool)                &#123;                    tool/=<span class="hljs-number">10</span>;                    pos++;                &#125;            &#125;            pos++;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m+<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        add(i,e,x);add(e,i,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=dinic();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        <span class="hljs-keyword">if</span>(dis[i]!=<span class="hljs-number">-1</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,i);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m+<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-keyword">if</span>(dis[i]!=<span class="hljs-number">-1</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,i-m);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,sum-ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="最小路径覆盖问题"><a href="#最小路径覆盖问题" class="headerlink" title="最小路径覆盖问题"></a>最小路径覆盖问题</h5><p><strong>题意：</strong></p><p>对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。给出一个DAG，求最小路径覆盖并输出每条路径。</p><p><strong>思路：</strong></p><p>最小路径覆盖=N-最大二分匹配。</p><p>比如一个例子：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fsy89hx70qj309v05n0sn.jpg" srcset="/img/loading.gif" alt=""></p><p>对于一条路径，起点的入度为0，终点的出度为0，中间节点的出入度都为1。</p><p>每一个点最多只能有1个后继，同时每一个点最多只能有1个前驱。</p><p>假如我们选择了一条边(u,v)，也就等价于把前驱u和后继v匹配上了。这样前驱u和后继v就不能和其他节点匹配。</p><p>利用这个性质可以进行构图：</p><p>将每一个点拆分成2个，分别表示它作为前驱节点和后继节点。将所有的前驱节点作为A部，所有后继节点作为B部。若原图中存在一条边(u,v)，则连接A部的u和B部的v。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fsy8brulxwj305i0brwen.jpg" srcset="/img/loading.gif" alt=""></p><p>然后进行二分图最大匹配即可。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fsy8d1tp5ej305h0brabz.jpg" srcset="/img/loading.gif" alt="5.jpg"></p><p>其中实线表示被选中的匹配，虚线表示未被选中的。</p><p>有没有发现，和原图刚好有着对应的关系。未被选中的匹配也正好对应了原图中没有选择的黑色边。</p><p>如何保证这样就能得到最小的路径覆盖呢？</p><p>如果一个点是路径起点的话，起点的入度为0，它在B部的节点一定是没有匹配上的。</p><p>经过最大匹配算法后，B部剩下没有被匹配的点一定是最少的，也就对应了最小需要的路径数。</p><p>所以最小路径覆盖的结果才是N-最大匹配数。</p><p>类似于最大二分匹配的网络流做法做就可以了。</p><p>输出路径，对于每个A部的点，在dinic进行的过程中记录下对应的B部的点，每条路径从起点开始直接循环输出即可。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> s,e;<span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">20010</span>];<span class="hljs-keyword">int</span> head[<span class="hljs-number">310</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">310</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">310</span>];<span class="hljs-keyword">int</span> tto[<span class="hljs-number">310</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">310</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                tto[id]=temp;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s;i&lt;=e;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-built_in">memset</span>(tto,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(tto));    s=<span class="hljs-number">0</span>;e=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        add(s,i,<span class="hljs-number">1</span>);        add(i,s,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;i++)    &#123;        add(i,e,<span class="hljs-number">1</span>);        add(e,i,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        add(x,n+y,<span class="hljs-number">1</span>);        add(n+y,x,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">int</span> ans=dinic();    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        printf("%d ",tto[i]);</span><span class="hljs-comment">    printf("\n");*/</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(!vis[i])        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,i);            vis[i]=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">int</span> temp=tto[i];            <span class="hljs-keyword">if</span>(temp!=<span class="hljs-number">-1</span>)temp-=n;            <span class="hljs-keyword">while</span>(temp!=<span class="hljs-number">-1</span>&amp;&amp;!vis[temp])            &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,temp);                vis[temp]=<span class="hljs-literal">true</span>;                temp=tto[temp];                <span class="hljs-keyword">if</span>(temp!=<span class="hljs-number">-1</span>)temp-=n;            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,n-ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="魔术球问题"><a href="#魔术球问题" class="headerlink" title="魔术球问题"></a>魔术球问题</h5><p><strong>题意：</strong></p><p>假设有n根柱子，现要按下述规则在这n根柱子中依次放入编号为1，2，3，…的球。要求每次只能在某根柱子的最上面放球。在同一根柱子中，任何2个相邻球的编号之和为完全平方数。计算出在n根柱子上最多能放多少个球。</p><p><strong>思路：</strong></p><p>这是最小路径覆盖反过来做。</p><p>我先打了个表，因为n的范围小于等于55，球最多是1567个，dinic的复杂度理论上限为<script type="math/tex">O(n^2*m)</script>，所以枚举是ojbk的，因为是从小到大枚举，所以直接在残余网络上继续加边就可以，这里要注意要设一个前驱和后继这个拆点的分界，否则会发生覆盖。打表也可发现，n越大球越多，所以二分也可以，那么就每次都要重新建图了。</p><p>其实每个n最多能放几个球是有公式的，我会打表然而不会推呀QAQ</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> num;<span class="hljs-keyword">int</span> s,e;<span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">200010</span>];<span class="hljs-keyword">int</span> head[<span class="hljs-number">4010</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">4010</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">4010</span>];<span class="hljs-keyword">int</span> tto[<span class="hljs-number">4010</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">4010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                tto[id]=temp;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s;i&lt;=e;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-built_in">memset</span>(tto,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(tto));    s=<span class="hljs-number">0</span>;e=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        add(s,i,<span class="hljs-number">1</span>);        add(i,s,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;i++)    &#123;        add(i,e,<span class="hljs-number">1</span>);        add(e,i,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)        &#123;            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(i+j)*(<span class="hljs-keyword">int</span>)<span class="hljs-built_in">sqrt</span>(i+j)==i+j)            &#123;                add(i,j+n,<span class="hljs-number">1</span>);                add(j+n,i,<span class="hljs-number">0</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">int</span> ans=dinic();    <span class="hljs-keyword">return</span> n-ans;    <span class="hljs-comment">/*printf("n=%d ans=%d\n",n,n-ans);</span><span class="hljs-comment">     if(n-ans==num)&#123;printf("%d\n",n);return true;&#125;</span><span class="hljs-comment">     return false;*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;num);    <span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=<span class="hljs-number">1600</span>,ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(l&lt;=r)    &#123;        <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(judge(mid)&lt;=num)        &#123;            ans=mid;            l=mid+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    judge(ans);    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-comment">/*for(int i=1;i&lt;=ans;i++)</span><span class="hljs-comment">     printf("%d ",tto[i]);</span><span class="hljs-comment">     printf("\n");*/</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=ans;i++)    &#123;        <span class="hljs-keyword">if</span>(!vis[i])        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,i);            vis[i]=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">int</span> temp=tto[i];            <span class="hljs-keyword">if</span>(temp!=<span class="hljs-number">-1</span>)temp-=ans;            <span class="hljs-keyword">while</span>(temp!=<span class="hljs-number">-1</span>&amp;&amp;!vis[temp])            &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,temp);                vis[temp]=<span class="hljs-literal">true</span>;                temp=tto[temp];                <span class="hljs-keyword">if</span>(temp!=<span class="hljs-number">-1</span>)temp-=ans;            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="圆桌问题"><a href="#圆桌问题" class="headerlink" title="圆桌问题"></a>圆桌问题</h5><p><strong>题意：</strong></p><p>假设有来自m 个不同单位的代表参加一次国际会议。每个单位的代表数分别为ri (i =1,2,……,m)。</p><p>会议餐厅共有n 张餐桌，每张餐桌可容纳ci (i =1,2,……,n)个代表就餐。</p><p>要求从同一个单位来的代表不在同一个餐桌就餐。试设计一个算法，给出满足要求的代表就餐方案。</p><p><strong>思路：</strong></p><p>建图很容易。</p><p>单位为左部，餐桌为右部。源点到左部的容量为每个单位的代表数，右部到汇点的容量为每张餐桌可容纳的代表数，每个单位到餐桌的流的容量为1，然后跑一下最大流看是不是所有单位的总人数就可以了。</p><p>输出方案的话，循环左部到右部的流的容量，容量是0的就输出。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> s,e;<span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> head[<span class="hljs-number">510</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">510</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">510</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s;i&lt;=e;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,n,x,sum;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;m,&amp;n);    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    s=<span class="hljs-number">0</span>;e=m+n+<span class="hljs-number">1</span>;    sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        sum+=x;        add(s,i,x);        add(i,s,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m+<span class="hljs-number">1</span>;i&lt;=m+n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        add(i,e,x);        add(e,i,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m+<span class="hljs-number">1</span>;j&lt;=m+n;j++)        &#123;            add(i,j,<span class="hljs-number">1</span>);            add(j,i,<span class="hljs-number">0</span>);        &#125;    <span class="hljs-keyword">int</span> temp=dinic();    <span class="hljs-keyword">if</span>(temp!=sum)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=head[i];j!=<span class="hljs-number">-1</span>;j=eg[j].next)            &#123;                <span class="hljs-keyword">int</span> temp=eg[j].to;                <span class="hljs-keyword">if</span>(eg[j].cap==<span class="hljs-number">0</span>)                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,temp-m);            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="试题库问题"><a href="#试题库问题" class="headerlink" title="试题库问题"></a>试题库问题</h5><p><strong>题意：</strong></p><p>假设一个试题库中有n道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。共有k个类型。现要从题库中抽取m道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。</p><p><strong>思路：</strong></p><p>建图很容易。</p><p>k个类型为左部，n道试题为右部，源点到左部的权值为每个类型的题数，右部到汇点的权值为1，所属的类型到试题的权值为1。</p><p>输出的时候对于每个类型枚举每条边残余容量为0的输出即可。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> s,e;<span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> head[<span class="hljs-number">1510</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">1510</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">1510</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s;i&lt;=e;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,n,x,sum,num;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;m,&amp;n);    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    s=<span class="hljs-number">0</span>;e=m+n+<span class="hljs-number">1</span>;    sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        sum+=x;        add(s,i,x);        add(i,s,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m+<span class="hljs-number">1</span>;i&lt;=m+n;i++)    &#123;        add(i,e,<span class="hljs-number">1</span>);        add(e,i,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m+<span class="hljs-number">1</span>;i&lt;=m+n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;num);        <span class="hljs-keyword">while</span>(num--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            add(x,i,<span class="hljs-number">1</span>);            add(i,x,<span class="hljs-number">0</span>);        &#125;    &#125;    <span class="hljs-keyword">int</span> temp=dinic();    <span class="hljs-keyword">if</span>(temp!=sum)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"No Solution!"</span>);    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d:"</span>,i);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=head[i];j!=<span class="hljs-number">-1</span>;j=eg[j].next)            &#123;                <span class="hljs-keyword">if</span>(eg[j].cap==<span class="hljs-number">0</span>&amp;&amp;eg[j].to&gt;=m+<span class="hljs-number">1</span>)                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,eg[j].to-m);            &#125;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="方格取数问题"><a href="#方格取数问题" class="headerlink" title="方格取数问题"></a>方格取数问题</h5><p><strong>题意：</strong></p><p>在一个有 m*n 个方格的棋盘中，每个方格中有一个正整数。现要从方格中取数，使任意2个数所在方格没有公共边，且取出的数的总和最大。试设计一个满足要求的取数算法。对于给定的方格棋盘，按照取数要求编程找出总和最大的数。</p><p><strong>思路：</strong></p><p>刚开始自己xjb建图…能凑出答案来，但是还是不是很清楚为什么，看了<a href="https://www.cnblogs.com/cjyyb/p/8191095.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjyyb/p/8191095.html</a> 这位dalao的博客结合之前那道最大权闭合子图就豁然开朗了hhh</p><p>这跟以前做的匹配中的黑白匹配很像。</p><p>所以仍然把它先黑白染色（横坐标+纵坐标%2==0的点设为黑点）。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft02l4srs5j306n06oq2v.jpg" srcset="/img/loading.gif" alt="img"></p><p>因为相邻的点只能出现一个，要么选，要么不选，所以可以想到最小割。</p><p>将矩阵黑白染色后，源点到黑格的权值为该矩阵上的数，白格到汇点的权值为该数，相邻的黑格和白格相连，权值为INF，因为这些不能割开。</p><p>这样连边之后，如果选一个数，相邻的点到汇点的边就会被割掉。换句话说，由于割的性质，相邻的黑格和白格之间有连边，这个黑格和它相邻的任意白格不能同时存在，所以肯定有一边是被割掉的。</p><p>这样求出来最小割=最大流。</p><p>因为要求的是最大值，所以答案是sum-最小割。</p><p>来复习一下最大权闭合子图，</p><p>每个实验和它所需的仪器连边以后，实验和对应的仪器不能同时存在，所以实验那边被割掉表示的是不做了这个实验了，仪器那边被割掉表示的是这个仪器要买（即对应的实验要做），这也是一个选与不选的问题。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> s,e;<span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">200010</span>];<span class="hljs-keyword">int</span> head[<span class="hljs-number">10100</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">10100</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">10100</span>];<span class="hljs-keyword">bool</span> bw[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> mp[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s;i&lt;=e;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> r,c,x;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;r,&amp;c);    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    s=<span class="hljs-number">0</span>;e=r*c+<span class="hljs-number">1</span>;    <span class="hljs-built_in">memset</span>(bw,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(bw));    <span class="hljs-keyword">int</span> num1=<span class="hljs-number">0</span>,num2=<span class="hljs-number">0</span>;   <span class="hljs-comment">//true/false</span>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=c;i++)    &#123;        bw[<span class="hljs-number">1</span>][i]=!bw[<span class="hljs-number">1</span>][i<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(bw[<span class="hljs-number">1</span>][i])        &#123;            num1++;            mp[<span class="hljs-number">1</span>][i]=num1;        &#125;        <span class="hljs-keyword">else</span>        &#123;            num2++;            mp[<span class="hljs-number">1</span>][i]=num2;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=r;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=c;j++)        &#123;            bw[i][j]=!bw[i<span class="hljs-number">-1</span>][j];            <span class="hljs-keyword">if</span>(bw[i][j])            &#123;                num1++;                mp[i][j]=num1;            &#125;            <span class="hljs-keyword">else</span>            &#123;                num2++;                mp[i][j]=num2;            &#125;        &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=c;j++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            sum+=x;            <span class="hljs-keyword">if</span>(bw[i][j])            &#123;                add(s,mp[i][j],x);                add(mp[i][j],s,<span class="hljs-number">0</span>);            &#125;            <span class="hljs-keyword">else</span>            &#123;                add(mp[i][j]+num1,e,x);                add(e,mp[i][j]+num1,<span class="hljs-number">0</span>);            &#125;        &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=r;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=c;j++)        &#123;            <span class="hljs-keyword">if</span>(bw[i][j])            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> dx=<span class="hljs-number">-1</span>;dx&lt;=<span class="hljs-number">1</span>;dx++)                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> dy=<span class="hljs-number">-1</span>;dy&lt;=<span class="hljs-number">1</span>;dy++)                    &#123;                        <span class="hljs-keyword">if</span>(dx!=<span class="hljs-number">0</span>&amp;&amp;dy!=<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;                        <span class="hljs-keyword">if</span>(dx==<span class="hljs-number">0</span>&amp;&amp;dy==<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;                        <span class="hljs-keyword">if</span>(i+dx&gt;=<span class="hljs-number">1</span>&amp;&amp;i+dx&lt;=r&amp;&amp;j+dy&gt;=<span class="hljs-number">1</span>&amp;&amp;j+dy&lt;=c)                        &#123;                            add(mp[i][j],mp[i+dx][j+dy]+num1,INF);                            add(mp[i+dx][j+dy]+num1,mp[i][j],<span class="hljs-number">0</span>);                        &#125;                    &#125;            &#125;        &#125;    <span class="hljs-comment">/*printf("%d,%d\n",num1,num2);</span><span class="hljs-comment">    for(int i=s;i&lt;=e;i++)</span><span class="hljs-comment">    &#123;</span><span class="hljs-comment">        printf("%d:",i);</span><span class="hljs-comment">        for(int j=head[i];j!=-1;j=eg[j].next)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            printf("(%d,%d)",eg[j].to,eg[j].cap);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        printf("\n");</span><span class="hljs-comment">    &#125;*/</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,sum-dinic());    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bzoj1878 离线处理+树状数组</title>
    <link href="/2018/02/21/bzoj1878-%E7%A6%BB%E7%BA%BF%E5%A4%84%E7%90%86-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2018/02/21/bzoj1878-%E7%A6%BB%E7%BA%BF%E5%A4%84%E7%90%86-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><strong>题意</strong>：查询某一段区间中有多少不同的数字。</p><p><strong>思路</strong>：可以想到把每个数字第一次出现的位置标记为1，不是的则为0，然后前缀和。但是这里是区间查询，有些数在整个数列里不一定是第一个，但是在区间里可能就是第一个了，所以这里要离线处理。</p><p>第一次做离线的题，先说一下什么是离线吧。离线就是要知道所有输入以后再处理，最后一次性输出全部。</p><p>这里把输入的区间按左端点排序，然后一个一个处理询问，这样相当于在模拟一个类似滑动窗口的东西，当滑动窗口滑到某个区间后，把在上一个区间但不在这个区间的数字取nxt[]（nxt[i]表示的是下一个与a[i]相同的数字（预处理）），即这种颜色不再计算时（单点修改该数字为0），我们再添加在区间中的下一个和它颜色相同的元素（单点修改该数字为1），然后查询前缀和即可。</p><p><strong>代码</strong>：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> a[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> d[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> nxt[<span class="hljs-number">50010</span>];<span class="hljs-comment">//下一个与它相同的数</span><span class="hljs-keyword">int</span> now[<span class="hljs-number">1000010</span>];<span class="hljs-comment">//上一个值为i的数的位置</span><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">1000010</span>];<span class="hljs-comment">//判断之前是否出现过</span><span class="hljs-keyword">int</span> ans[<span class="hljs-number">200010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qur</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> l,r;    <span class="hljs-keyword">int</span> ans,id;&#125;q[<span class="hljs-number">200010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(qur x,qur y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x.l&lt;y.l;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//查询前缀和</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        res+=d[x];        x-=lowbit(x);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span><span class="hljs-comment">//单点修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(x&lt;=n)    &#123;        d[x]+=v;        x+=lowbit(x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);        <span class="hljs-keyword">if</span>(!vis[a[i]])add(i,<span class="hljs-number">1</span>);        vis[a[i]]=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span>(now[a[i]]!=<span class="hljs-number">-1</span>)nxt[now[a[i]]]=i;        now[a[i]]=i;    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        printf("%d ",nxt[i]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-built_in">memset</span>(nxt,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(nxt));    <span class="hljs-built_in">memset</span>(now,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(now));    init();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        q[i].id=i;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;q[i].l,&amp;q[i].r);    &#125;    sort(q+<span class="hljs-number">1</span>,q+m+<span class="hljs-number">1</span>,cmp);    q[<span class="hljs-number">0</span>].l=<span class="hljs-number">1</span>;    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        printf("%d ",query(i)-query(i-1));*/</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=q[i<span class="hljs-number">-1</span>].l;j&lt;q[i].l;j++)        &#123;            <span class="hljs-keyword">int</span> pos=j;            <span class="hljs-keyword">while</span>(pos!=<span class="hljs-number">-1</span>&amp;&amp;pos&lt;q[i].l)                pos=nxt[pos];            <span class="hljs-keyword">if</span>(pos!=<span class="hljs-number">-1</span>)add(pos,<span class="hljs-number">1</span>);            add(j,<span class="hljs-number">0</span>);        &#125;        ans[q[i].id]=query(q[i].r)-query(q[i].l<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ2352 树状数组</title>
    <link href="/2018/02/21/POJ2352-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2018/02/21/POJ2352-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><strong>题意</strong>：给你n个点代表n个星星，以该点为起点向x，y轴作垂线，会得到一个矩形，这个矩形里面所包含的星星数（不包括它本身）称为该星星的等级，要求输出在0-n-1等级各有多少个星星。注意给出的点的顺序很有讲究，是按照y坐标升序给出，如果y坐标相同，则按照x坐标升序给出。</p><p><strong>思路</strong>：</p><p>可以运用前缀和的思想，因为本身输入是按y坐标升序给出的，已经满足了两个条件之一，那么只要查询这个输入之前有多少个星星，所以要记录每个坐标x上有几颗星星。</p><p>这里要注意x不能为0，否则会死循环，所以输入的时候x++，add()中x&lt;=MAXN+1。</p><p><strong>代码</strong>：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> d[<span class="hljs-number">32010</span>];<span class="hljs-comment">//记录星星在x=i有多少颗</span><span class="hljs-keyword">int</span> lev[<span class="hljs-number">15010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//查询前缀和</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        res+=d[x];        x-=lowbit(x);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span><span class="hljs-comment">//单点修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(x&lt;=<span class="hljs-number">32001</span>)<span class="hljs-comment">//这里应该小于32001（因为横坐标+1）</span>    &#123;        d[x]+=v;        x+=lowbit(x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));    <span class="hljs-built_in">memset</span>(lev,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(lev));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        x++;<span class="hljs-comment">//x不能为0，lowbit(0)=0会造成死循环</span>        <span class="hljs-comment">//printf("(%d)",query(x));</span>        lev[query(x)]++;        add(x,<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,lev[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2018/02/20/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2018/02/20/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>以前就听说线段树的适用范围比树状数组要广 所以就一直没有学 昨天碰到了处理前缀和的问题 发现树状数组可以更方便 所以就有点好奇了 同样 我还是选择了看视频w</p><p>传送门：<a href="https://www.bilibili.com/video/av18735440/" target="_blank" rel="noopener">https://www.bilibili.com/video/av18735440/</a></p><p>参考博客：<a href="http://blog.csdn.net/largecub233/article/details/56666971" target="_blank" rel="noopener">http://blog.csdn.net/largecub233/article/details/56666971</a></p><p>区间修改：<a href="http://blog.csdn.net/qq_21841245/article/details/43956633" target="_blank" rel="noopener">http://blog.csdn.net/qq_21841245/article/details/43956633</a></p><p>模板：</p><p>（下标都从1开始）</p><h5 id="区间查询-单点修改"><a href="#区间查询-单点修改" class="headerlink" title="区间查询 单点修改"></a>区间查询 单点修改</h5><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> d[<span class="hljs-number">500010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//查询前缀和</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        res+=d[x];        x-=lowbit(x);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span><span class="hljs-comment">//单点修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(x&lt;=n)    &#123;        d[x]+=v;        x+=lowbit(x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,x,y,ope;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        add(i,x);    &#125;    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;ope,&amp;x,&amp;y);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)add(x,y);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">2</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,query(y)-query(x<span class="hljs-number">-1</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="单点查询-区间修改"><a href="#单点查询-区间修改" class="headerlink" title="单点查询 区间修改"></a>单点查询 区间修改</h5><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> c[<span class="hljs-number">500010</span>];<span class="hljs-comment">//差分数组</span><span class="hljs-comment">//这里运用了差分思想，假设原本的数据存在a数组中，</span><span class="hljs-comment">//那么c数组储存的就是c[i]=a[i]-a[i-1]，如果c[1]=a[1]，那么很明显</span><span class="hljs-comment">//a[i]=c[i]+c[i-1]+c[i-2]+...+c[2]+c[1].</span><span class="hljs-comment">//这样我们每次单点查询的时候只要加上c数组的前缀就可以了。</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//单点查询</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        res+=c[x];        x-=lowbit(x);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span><span class="hljs-comment">//区间修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(x&lt;=n)    &#123;        c[x]+=v;        x+=lowbit(x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,x,y,k,ope,ls;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(c));    ls=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        add(i,x-ls);        ls=x;    &#125;    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;ope);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;k);            add(x,k);            add(y+<span class="hljs-number">1</span>,-k);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">2</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,query(x));        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="加了区间修改的万能模板"><a href="#加了区间修改的万能模板" class="headerlink" title="加了区间修改的万能模板"></a>加了区间修改的万能模板</h5><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;ll n;ll sum[<span class="hljs-number">200010</span>];<span class="hljs-comment">//原数列的前缀和</span>ll c[<span class="hljs-number">200010</span>];<span class="hljs-comment">//差分数组</span>ll ci[<span class="hljs-number">200010</span>];<span class="hljs-comment">//差分*i数组</span><span class="hljs-function">ll <span class="hljs-title">lowbit</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll arr[],ll x)</span><span class="hljs-comment">//查询前缀和</span></span><span class="hljs-function"></span>&#123;    ll res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        res+=arr[x];        x-=lowbit(x);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll arr[],ll x,ll v)</span><span class="hljs-comment">//单点修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(x&lt;=n)    &#123;        arr[x]+=v;        x+=lowbit(x);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m,x,y,k,ope;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n);    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(c));    sum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;x);        sum[i]=sum[i<span class="hljs-number">-1</span>]+x;    &#125;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;m);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;ope);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;k);            add(c,x,k);            add(c,y+<span class="hljs-number">1</span>,-k);            add(ci,x,k*x);            add(ci,y+<span class="hljs-number">1</span>,-k*(y+<span class="hljs-number">1</span>));        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">2</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;x,&amp;y);            ll sum1=sum[x<span class="hljs-number">-1</span>]+x*query(c,x<span class="hljs-number">-1</span>)-query(ci,x<span class="hljs-number">-1</span>);            ll sum2=sum[y]+(y+<span class="hljs-number">1</span>)*query(c,y)-query(ci,y);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,sum2-sum1);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h5><p>（以bzoj1452为例）</p><p>题意：一个n*m的方格，初始时每个格子有一个整数权值。接下来每次有2种操作：</p><p>改变一个格子的权值；</p><p>求一个子矩阵中某种特定权值出现的个数。</p><p>思路：加个权值的维度即可。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> row,clo;<span class="hljs-keyword">int</span> mp[<span class="hljs-number">310</span>][<span class="hljs-number">310</span>];<span class="hljs-keyword">int</span> c[<span class="hljs-number">310</span>][<span class="hljs-number">310</span>][<span class="hljs-number">110</span>];<span class="hljs-comment">//差分数组</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span><span class="hljs-comment">//单点查询</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&gt;<span class="hljs-number">0</span>;i-=lowbit(i))        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=y;j&gt;<span class="hljs-number">0</span>;j-=lowbit(j))            res+=c[i][j][z];    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z,<span class="hljs-keyword">int</span> v)</span><span class="hljs-comment">//区间修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&lt;=row;i+=lowbit(i))        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=y;j&lt;=clo;j+=lowbit(j))            c[i][j][z]+=v;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,ope,x,y,z,x1,y1,x2,y2;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;row,&amp;clo);    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(c));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=row;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=clo;j++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;mp[i][j]);            add(i,j,mp[i][j],<span class="hljs-number">1</span>);        &#125;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;ope);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);            add(x,y,mp[x][y],<span class="hljs-number">-1</span>);            mp[x][y]=z;            add(x,y,z,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">2</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d%d"</span>,&amp;x1,&amp;x2,&amp;y1,&amp;y2,&amp;z);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,query(x1<span class="hljs-number">-1</span>,y1<span class="hljs-number">-1</span>,z)+query(x2,y2,z)-query(x1<span class="hljs-number">-1</span>,y2,z)-query(x2,y1<span class="hljs-number">-1</span>,z));        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>（以poj2155为例）</p><p>题意：给出矩阵左上角和右下角坐标，矩阵里的元素1变0，0 变1，给出询问，问某个点是多少。</p><p>思路：</p><p>区间修改的时候，(x1,y1)为左上角的点，(x2,y2)是右下角的点。<img src="http://img.blog.csdn.net/20170409165447611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQUNNX0Zpc2g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>修改的应该是add(x1,y1,1),add(x2+1,y1,-1),add(x1,y2+1,-1),add(x2+1,y2+1,1)。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> c[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<span class="hljs-comment">//差分数组</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x&amp;(-x);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span><span class="hljs-comment">//单点查询</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&gt;<span class="hljs-number">0</span>;i-=lowbit(i))        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=y;j&gt;<span class="hljs-number">0</span>;j-=lowbit(j))            res+=c[i][j];    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> v)</span><span class="hljs-comment">//区间修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=x;i&lt;=n;i+=lowbit(i))        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=y;j&lt;=n;j+=lowbit(j))            c[i][j]+=v;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,m,x,y,x1,y1,x2,y2;<span class="hljs-comment">//左上角右下角</span>    <span class="hljs-keyword">char</span> ope[<span class="hljs-number">5</span>];    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">0</span>;kase&lt;t;kase++)    &#123;        <span class="hljs-keyword">if</span>(kase!=<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);        <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(c));        <span class="hljs-keyword">while</span>(m--)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,ope);            <span class="hljs-keyword">if</span>(ope[<span class="hljs-number">0</span>]==<span class="hljs-string">'C'</span>)            &#123;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);                add(x1,y1,<span class="hljs-number">1</span>);                add(x2+<span class="hljs-number">1</span>,y1,<span class="hljs-number">-1</span>);                add(x2+<span class="hljs-number">1</span>,y2+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);                add(x1,y2+<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope[<span class="hljs-number">0</span>]==<span class="hljs-string">'Q'</span>)            &#123;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,(query(x,y))%<span class="hljs-number">2</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces899F 线段树中前缀和的查找</title>
    <link href="/2018/02/19/CodeForces899F-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%AD%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2018/02/19/CodeForces899F-%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%AD%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>题意</strong>：给定只含小写字母、大写字母和数字的字符串，每次给定一个范围要求删除[l,r]内的字符c（l和r具体位置随删除变动），求m次操作后的字符串。n&lt;=2*10^5。</p><p><strong>思路</strong>：这里l和r的位置会随删除变动，所以要先知道l和r的原本位置，这里可以将序列中存在记为1，删除记为0，转化为找前缀和恰好为l和r的位置，就是原本的位置了，可以维护每个区间剩余字符的个数num和区间中每个字符的个数sum，通过num来求出每个l,r对应的在线段树上的l,r。 这里涉及到线段树上的前缀和的位置的求法，然后区间更新即可。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//二分查找前缀和</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l==r)<span class="hljs-keyword">return</span> l;    <span class="hljs-keyword">if</span>(x&lt;=node[id&lt;&lt;<span class="hljs-number">1</span>].num)<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(id&lt;&lt;<span class="hljs-number">1</span>,x);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,x-node[id&lt;&lt;<span class="hljs-number">1</span>].num);&#125;</code></pre><p><strong>代码</strong>：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">char</span> a[<span class="hljs-number">200010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> left,right;    <span class="hljs-keyword">int</span> sum[<span class="hljs-number">65</span>];    <span class="hljs-keyword">int</span> num;<span class="hljs-comment">//区间有多少个没被删除的数字 0:被删除 1:没被删除</span>&#125;node[<span class="hljs-number">200010</span>&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> ans;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-keyword">char</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-string">'A'</span>&amp;&amp;x&lt;=<span class="hljs-string">'Z'</span>)<span class="hljs-keyword">return</span> x-<span class="hljs-string">'A'</span>;    <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-string">'a'</span>&amp;&amp;x&lt;=<span class="hljs-string">'z'</span>)<span class="hljs-keyword">return</span> x-<span class="hljs-string">'a'</span>+<span class="hljs-number">26</span>;    <span class="hljs-keyword">return</span> x-<span class="hljs-string">'0'</span>+<span class="hljs-number">52</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> id)</span><span class="hljs-comment">//建树</span></span><span class="hljs-function"></span>&#123;    node[id].left=l;    node[id].right=r;    <span class="hljs-keyword">if</span>(l==r)    &#123;        node[id].sum[trans(a[l])]=<span class="hljs-number">1</span>;        node[id].num=<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    build(l,m,id&lt;&lt;<span class="hljs-number">1</span>);    build(m+<span class="hljs-number">1</span>,r,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    node[id].num=node[id&lt;&lt;<span class="hljs-number">1</span>].num+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].num;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">62</span>;i++)       node[id].sum[i]=node[id&lt;&lt;<span class="hljs-number">1</span>].sum[i]+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum[i];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//二分查找前缀和</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l==r)<span class="hljs-keyword">return</span> l;    <span class="hljs-keyword">if</span>(x&lt;=node[id&lt;&lt;<span class="hljs-number">1</span>].num)<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(id&lt;&lt;<span class="hljs-number">1</span>,x);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,x-node[id&lt;&lt;<span class="hljs-number">1</span>].num);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(node[id].sum[c]==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l==r)    &#123;        node[id].num=<span class="hljs-number">0</span>;        node[id].sum[c]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)update(L,R,c,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)update(L,R,c,(id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>));    node[id].num=node[id&lt;&lt;<span class="hljs-number">1</span>].num+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].num;    node[id].sum[c]=node[id&lt;&lt;<span class="hljs-number">1</span>].sum[c]+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum[c];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l==r)    &#123;        <span class="hljs-comment">//printf("%d:%d\n",id,node[id].num);</span>        <span class="hljs-keyword">if</span>(node[id].num==<span class="hljs-number">1</span>)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,a[l]);        <span class="hljs-keyword">return</span>;    &#125;    output(id&lt;&lt;<span class="hljs-number">1</span>);    output(id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a+<span class="hljs-number">1</span>);    build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);    <span class="hljs-keyword">int</span> l,r;    <span class="hljs-keyword">char</span> c;    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d %c"</span>,&amp;l,&amp;r,&amp;c);        l=<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>,l);        r=<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>,r);        update(l,r,trans(c),<span class="hljs-number">1</span>);    &#125;    output(<span class="hljs-number">1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces899E 模拟链表+优先队列+pair</title>
    <link href="/2018/02/19/CodeForces899E-%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-pair/"/>
    <url>/2018/02/19/CodeForces899E-%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-pair/</url>
    
    <content type="html"><![CDATA[<p><strong>题意</strong>：给定长度为N的序列，每次将序列中长度最大部分相等的区间删去（若有多种情况删去最左端的区间），问多少次操作可以将删完。</p><p><strong>思路</strong>：</p><p>怎样知道前后区间表示的数字能否合并？</p><p>模拟链表，用两个数组pre和nxt。</p><p>删掉之后前后区间合并之后，放在本来的优先队列里的原前后区间该怎么处理？</p><p>再开一个优先队列用来放置被删除的区间，优先级与原优先队列相同，如果堆顶等于堆顶就删掉。</p><p>pair在优先队列中的优先级：</p><p>如果是大顶堆，first从大到小，first相等，second从大到小，所以这里second（第几个）要取相反数。</p><p>这里注意合并区间之后，pos后面的后面一个的前驱应该是pre[pos]，不要改了nxt就觉得pre不用改了，这里不是单向链表从前往后遍历，而是双向的。</p><p><strong>代码</strong>：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> pre[<span class="hljs-number">200010</span>],nxt[<span class="hljs-number">200010</span>];<span class="hljs-comment">//每一块的前驱和后续（模拟链表）</span><span class="hljs-keyword">int</span> num[<span class="hljs-number">200010</span>],len[<span class="hljs-number">200010</span>];<span class="hljs-comment">//每一块的数字和长度</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> x,ls=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        <span class="hljs-keyword">if</span>(x!=ls)num[++cnt]=x,len[cnt]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> len[cnt]++;        ls=x;    &#125;    pre[<span class="hljs-number">1</span>]=<span class="hljs-number">-1</span>;nxt[cnt]=<span class="hljs-number">-1</span>;    priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt;q,del;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)    &#123;        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>)pre[i]=i<span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span>(i!=cnt)nxt[i]=i+<span class="hljs-number">1</span>;        q.push(make_pair(len[i],-i));<span class="hljs-comment">//因为是大顶堆</span>    &#125;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(cnt)    &#123;        <span class="hljs-keyword">while</span>(!del.empty()&amp;&amp;q.top()==del.top())q.pop(),del.pop();<span class="hljs-comment">//把原队列中该删除的删除</span>        pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;temp;        temp=q.top();        <span class="hljs-comment">//printf("%d %d\n",temp.first,-temp.second);</span>        ans++;        q.pop();        <span class="hljs-keyword">int</span> pos=-temp.second;        <span class="hljs-keyword">if</span>(pre[pos]!=<span class="hljs-number">-1</span>&amp;&amp;nxt[pos]!=<span class="hljs-number">-1</span>&amp;&amp;num[pre[pos]]==num[nxt[pos]])<span class="hljs-comment">//向前合并</span>        &#123;            <span class="hljs-comment">//printf("!\n");</span>            del.push(make_pair(len[pre[pos]],-pre[pos]));            del.push(make_pair(len[nxt[pos]],-nxt[pos]));            q.push(make_pair(len[pre[pos]]+len[nxt[pos]],-pre[pos]));            len[pre[pos]]+=len[nxt[pos]];            nxt[pre[pos]]=nxt[nxt[pos]];pre[nxt[nxt[pos]]]=pre[pos];<span class="hljs-comment">//注意pos后面的后面一个的前驱应该是pre[pos]</span>            cnt-=<span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">else</span><span class="hljs-comment">//在链表中删除该块</span>        &#123;            nxt[pre[pos]]=nxt[pos];pre[nxt[pos]]=pre[pos];            cnt--;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces899D 构造</title>
    <link href="/2018/02/19/CodeForces899D-%E6%9E%84%E9%80%A0/"/>
    <url>/2018/02/19/CodeForces899D-%E6%9E%84%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<p>题意：输入一个n，求从中任选两个数，使得其尾部9的个数最多的数对有多少个。（也可能存在0个9） <em>n</em> ≤ 10^9</p><p>例：n=14：1 and 8;2 and 7;3 and 6;4 and 5;5 and 14;6 and 13;7 and 12;8 and 11;9 and 10。</p><p>思路：刚开始我是想找规律的，然后发现规律是有的，太难表述出来了。看了别人的题解知道，这应该从另一角度来思考，比如最多的9的个数是2，那么就要构造出99,199,299,…,899，考虑满足和是这些的数对有几个，然后发现自己读错题了…是可以出现一个数被选多次的…</p><p>以两个9为例：</p><p>99:1+98…49+50——50～98都可以凑出99</p><p>199——100～198都可以凑出199</p><p>……</p><p>899——450～898都可以凑出899</p><p>然后就可以写了，注意特判2～4。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n);    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//9的最大个数</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> zs=<span class="hljs-number">5</span>;    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">4</span>)    &#123;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">3</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"3\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">4</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"6\n"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++)    &#123;        <span class="hljs-keyword">if</span>(n&lt;zs)<span class="hljs-keyword">break</span>;        zs=zs*<span class="hljs-number">10</span>;num++;    &#125;    <span class="hljs-comment">//printf("num=%d\n",num);</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> l=<span class="hljs-number">5</span>;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> r=<span class="hljs-number">10</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num<span class="hljs-number">-1</span>;i++)        l=l*<span class="hljs-number">10</span>,r=r*<span class="hljs-number">10</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sl=l,sr=r;    r=r<span class="hljs-number">-2</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)    &#123;        <span class="hljs-keyword">if</span>(n&lt;l)<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n&gt;=r)ans+=r-l+<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n&gt;=l)ans+=(n-l)+<span class="hljs-number">1</span>;        l=l+sl;r=r+sr;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ3784 动态插入求中位数</title>
    <link href="/2018/02/17/POJ-3784-%E5%8A%A8%E6%80%81%E6%8F%92%E5%85%A5%E6%B1%82%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2018/02/17/POJ-3784-%E5%8A%A8%E6%80%81%E6%8F%92%E5%85%A5%E6%B1%82%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题意：输入M个数，当已输入的个数为奇数个时输出此时的中位数。</p><p>一共有M/2+1个中位数要输出，每一行10个。</p><p>思路：用两个优先队列，一个是大顶堆，一个小顶堆，大顶堆中存放比中位数小的数，小顶堆中存放比中位数大的数，把第一个数放入大顶堆，如果当前数比上个中位数小就放入大顶堆，否则就就放入小顶堆。当大顶堆比小顶堆多2个元素或者小顶堆比大顶堆多2个元素的时候，就把多的那个顶堆的堆顶放到另一个堆。要求中位数时，如果是奇数时，就是元素多的堆顶，偶数时是两个堆顶的平均数。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-keyword">int</span> kase;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;kase);        <span class="hljs-keyword">int</span> n;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        priority_queue&lt;<span class="hljs-keyword">int</span>&gt;q1;<span class="hljs-comment">//大顶堆：比中位数小</span>        priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt;q2;<span class="hljs-comment">//小顶堆：比中位数大</span>        <span class="hljs-keyword">double</span> ls;<span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,kase,(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,kase,n/<span class="hljs-number">2</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">int</span> x;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            <span class="hljs-comment">//printf("(%.1f)\n",ls);</span>            <span class="hljs-keyword">if</span>(q1.empty()||<span class="hljs-number">1.0</span>*x&lt;ls)q1.push(x);            <span class="hljs-keyword">else</span> q2.push(x);            <span class="hljs-keyword">if</span>(q1.<span class="hljs-built_in">size</span>()-q2.<span class="hljs-built_in">size</span>()==<span class="hljs-number">2</span>)            &#123;                <span class="hljs-comment">//printf("!\n");</span>                <span class="hljs-keyword">int</span> temp=q1.top();                q1.pop();                q2.push(temp);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q2.<span class="hljs-built_in">size</span>()-q1.<span class="hljs-built_in">size</span>()==<span class="hljs-number">2</span>)            &#123;                <span class="hljs-comment">//printf("?\n");</span>                <span class="hljs-keyword">int</span> temp=q2.top();                q2.pop();                q1.push(temp);            &#125;            <span class="hljs-comment">//if(!q1.empty())printf("q1:%d\n",q1.top());</span>            <span class="hljs-comment">//if(!q2.empty())printf("q2:%d\n",q2.top());</span>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)            &#123;                <span class="hljs-keyword">if</span>(q1.<span class="hljs-built_in">size</span>()&gt;q2.<span class="hljs-built_in">size</span>())                    ls=q1.top(),<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,q1.top());                <span class="hljs-keyword">else</span>                    ls=q2.top(),<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,q2.top());                cnt++;                <span class="hljs-keyword">if</span>(cnt%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);            &#125;            <span class="hljs-keyword">else</span> ls=(q1.top()+q2.top())/<span class="hljs-number">2.0</span>;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补不动的题的一些思想QAQ</title>
    <link href="/2018/02/15/%E8%A1%A5%E4%B8%8D%E5%8A%A8%E7%9A%84%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E6%83%B3QAQ/"/>
    <url>/2018/02/15/%E8%A1%A5%E4%B8%8D%E5%8A%A8%E7%9A%84%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E6%83%B3QAQ/</url>
    
    <content type="html"><![CDATA[<h5 id="CodeForces898F"><a href="#CodeForces898F" class="headerlink" title="CodeForces898F"></a>CodeForces898F</h5><p>题意：给你一个字符串，把它表示成a+b=c的形式。</p><p>12345168</p><p>123+45=168</p><p>思路：（这里的a,b,c表示长度）c=n-a-b，而且max(a,b)-1&lt;=c&lt;=max(a,b)，所以两重循环即可</p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len/<span class="hljs-number">2</span>&amp;&amp;sign==<span class="hljs-number">0</span>;i++)<span class="hljs-comment">//a的长度/b的长度</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=len<span class="hljs-number">-2</span>*i<span class="hljs-number">-1</span>;j&lt;=len<span class="hljs-number">-2</span>*i&amp;&amp;sign==<span class="hljs-number">0</span>;j++)<span class="hljs-comment">//b的长度/a的长度</span></code></pre><p>那么如何判断是否正确呢？先可以哈希（取模）判断一下是否正确，再大数加法，这个思想跟之前有一道斐波那契的差不多。</p><h5 id="ACM竞赛高校联盟训练赛-第8场-J"><a href="#ACM竞赛高校联盟训练赛-第8场-J" class="headerlink" title="ACM竞赛高校联盟训练赛 第8场 J"></a>ACM竞赛高校联盟训练赛 第8场 J</h5><p>哇这道题并不是补不动 只是不能补</p><p>就说一种思想吧 原来括号匹配还可以转化为1和-1然后求前缀和的 将左括号’(‘视为1，右括号’)’视为-1则序列合法等价于所有前缀和非负且最后为零。</p><p>哇 如果早知道这么想就不会做不出了啊qwq</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分块思想</title>
    <link href="/2018/02/14/%E5%88%86%E5%9D%97%E6%80%9D%E6%83%B3/"/>
    <url>/2018/02/14/%E5%88%86%E5%9D%97%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>以前一直听说分块啥的…感觉不明觉厉…昨天晚上突发奇想想学习一下然后搜博客的时候发现了qscqesze的bilbili视频…讲得真好orz虽然很久之前就关注他了但是没有好好看过他的视频orz</p><p>传送门：<a href="https://www.bilibili.com/video/av6445624/" target="_blank" rel="noopener">https://www.bilibili.com/video/av6445624/</a></p><p>昨天晚上看完的今天早上就迫不及待敲一发找到了loj上hzwer的数列分块入门打算都做一遍hhh</p><p>分块是什么呢？就是把一个大块拆成若干个小块进行计算，每个小块有可能有一些共同特点，或者每个小块内部是有顺序的，这样，在修改操作的时候，只需要算出两边的节点所属的小块的编号分别是什么，然后两边的散块可以进行暴力修改，而中间的由于题目不同，可以进行不同的操作，比如说区间加，那么就可以在中间的每个小块上面直接像线段树一样打一个lazy标记，标记区间增加了多少。然后在查询的时候就可以直接对散块进行暴力查询，然后对整块运用之前设置的lazy标记，或者保证有序后用二分进行从O（n）进行到O（log（n））的优化。</p><h5 id="build函数"><a href="#build函数" class="headerlink" title="build函数"></a>build函数</h5><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> num;<span class="hljs-comment">//分块的个数</span><span class="hljs-keyword">int</span> belong[<span class="hljs-number">50010</span>];<span class="hljs-comment">//每个数属于哪个分块</span><span class="hljs-keyword">int</span> block;<span class="hljs-comment">//每个块的大小</span><span class="hljs-keyword">int</span> lef[<span class="hljs-number">50010</span>],rig[<span class="hljs-number">50010</span>];<span class="hljs-comment">//该块的左/右端点位置</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    block=<span class="hljs-built_in">sqrt</span>(n);    num=n/block;<span class="hljs-keyword">if</span>(n%block)num++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        belong[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)        lef[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>,rig[i]=i*block;    rig[num]=n;<span class="hljs-comment">//最后一块不满的情况</span>&#125;</code></pre><h5 id="LOJ-6277"><a href="#LOJ-6277" class="headerlink" title="LOJ 6277"></a>LOJ 6277</h5><p>题意：若 opt=0，表示将位于[l,r]的之间的数字都加c。</p><p>若 opt=1，表示询问ar的值（l和c忽略）。</p><p>思路：加一个数组表示每个块一起又加了多少即可。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> num;<span class="hljs-comment">//分块的个数</span><span class="hljs-keyword">int</span> belong[<span class="hljs-number">50010</span>];<span class="hljs-comment">//每个数属于哪个分块</span><span class="hljs-keyword">int</span> block;<span class="hljs-comment">//每个块的大小</span><span class="hljs-keyword">int</span> lef[<span class="hljs-number">50010</span>],rig[<span class="hljs-number">50010</span>];<span class="hljs-comment">//该块的左/右端点位置</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d[<span class="hljs-number">50010</span>];<span class="hljs-comment">//每个块一起又加了多少</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    block=<span class="hljs-built_in">sqrt</span>(n);    num=n/block;<span class="hljs-keyword">if</span>(n%block)num++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)        lef[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>,rig[i]=i*block;    rig[num]=n;<span class="hljs-comment">//最后一块不满的情况</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        belong[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c)</span><span class="hljs-comment">//区间更新</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)            a[i]+=c;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-comment">//printf("%d %d %d %d\n",belong[l],belong[r],rig[belong[l]],lef[belong[r]]);</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)            a[i]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)            d[i]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)            a[i]+=c;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//单点询问</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,a[x]+d[belong[x]]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);    build();    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));    <span class="hljs-keyword">int</span> ope,l,r,c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;ope,&amp;l,&amp;r,&amp;c);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">0</span>)update(l,r,c);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)ask(r);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="LOJ-6278"><a href="#LOJ-6278" class="headerlink" title="LOJ 6278"></a>LOJ 6278</h5><p>题意：若 opt=0，表示将位于[l,r] 的之间的数字都加 c。</p><p>若 opt=1，表示询问 [l,r] 中，小于 c^2 的数字的个数。</p><p>思路：</p><p>对于每次区间操作：</p><p>1.不完整的块 的O(√n)个元素怎么处理？</p><p>2.O(√n)个 整块 怎么处理？</p><p>3.要预处理什么信息（复杂度不能超过后面的操作）？</p><p>在块内维护升序数组b。</p><p>考虑到加c之后，块内的升序是不会发生改变的，但是块外是会有改变的，所以要维护块外的升序。</p><p>当询问时，块外的顺序已经乱了，b[i]的编号与询问的编号是不同的，所以不能直接根据b[i]来二分，而要暴力查询；而块内则无所谓顺序，因为都在[l,r]的范围之内，只需知道有几个，直接在b上二分即可。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">50010</span>];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b[<span class="hljs-number">50010</span>];<span class="hljs-comment">//块内排序</span><span class="hljs-keyword">int</span> num;<span class="hljs-comment">//分块的个数</span><span class="hljs-keyword">int</span> belong[<span class="hljs-number">50010</span>];<span class="hljs-comment">//每个数属于哪个分块</span><span class="hljs-keyword">int</span> block;<span class="hljs-comment">//每个块的大小</span><span class="hljs-keyword">int</span> lef[<span class="hljs-number">50010</span>],rig[<span class="hljs-number">50010</span>];<span class="hljs-comment">//该块的左/右端点位置</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d[<span class="hljs-number">50010</span>];<span class="hljs-comment">//每个块一起又加了多少</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    block=<span class="hljs-built_in">sqrt</span>(n);    num=n/block;<span class="hljs-keyword">if</span>(n%block)num++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        belong[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;        b[i]=a[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)    &#123;        lef[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>,rig[i]=i*block;        <span class="hljs-keyword">if</span>(i==num)rig[i]=n;<span class="hljs-comment">//最后一块不满的情况</span>        sort(b+lef[i],b+rig[i]+<span class="hljs-number">1</span>);<span class="hljs-comment">//块内维护升序</span>    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        printf("%lld ",b[i]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span><span class="hljs-comment">//区间更新</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)            a[i]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[l]];i&lt;=rig[belong[l]];i++)<span class="hljs-comment">//更新b[i]</span>            b[i]=a[i];        sort(b+lef[belong[l]],b+rig[belong[l]]+<span class="hljs-number">1</span>);<span class="hljs-comment">//块内维护升序</span>    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-comment">//printf("%d %d %d %d\n",belong[l],belong[r],rig[belong[l]],lef[belong[r]]);</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)            a[i]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[l]];i&lt;=rig[belong[l]];i++)<span class="hljs-comment">//更新b[i]</span>            b[i]=a[i];        sort(b+lef[belong[l]],b+rig[belong[l]]+<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)            d[i]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)            a[i]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=rig[belong[r]];i++)            b[i]=a[i];        sort(b+lef[belong[r]],b+rig[belong[r]]+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        printf("%lld ",b[i]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> st)</span><span class="hljs-comment">//区间询问</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)            <span class="hljs-keyword">if</span>(a[i]+d[belong[l]]&lt;st)                ans++;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)            <span class="hljs-keyword">if</span>(a[i]+d[belong[l]]&lt;st)                ans++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)        &#123;            <span class="hljs-keyword">int</span> pos=lower_bound(b+lef[i],b+rig[i]+<span class="hljs-number">1</span>,st-d[i])-b;            ans+=pos-lef[i];        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)            <span class="hljs-keyword">if</span>(a[i]+d[belong[r]]&lt;st)                ans++;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("input.txt","r",stdin);</span>    <span class="hljs-comment">//freopen("output.txt","w",stdout);</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);    build();    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));    <span class="hljs-keyword">int</span> ope,l,r;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%lld"</span>,&amp;ope,&amp;l,&amp;r,&amp;c);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">0</span>)update(l,r,c);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)ask(l,r,c*c);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="LOJ-6279"><a href="#LOJ-6279" class="headerlink" title="LOJ 6279"></a>LOJ 6279</h5><p>题意：给出一个长为 n 的数列，以及 n 个操作，操作涉及区间加法，询问区间内小于某个值x的前驱（比其小的最大元素）。</p><p>思路：跟上一题差不多区间询问的地方稍微改一下就可以了。</p><p>可以在块内维护其它结构使其更具有拓展性，比如放一个set，这样如果还有插入、删除元素的操作，会更加的方便。</p><p>分块的调试检测技巧：可以生成一些大数据，然后用两份分块大小不同的代码来对拍，还可以根据运行时间尝试调整分块大小，减小常数。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">100010</span>];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b[<span class="hljs-number">100010</span>];<span class="hljs-comment">//块内排序</span><span class="hljs-keyword">int</span> num;<span class="hljs-comment">//分块的个数</span><span class="hljs-keyword">int</span> belong[<span class="hljs-number">100010</span>];<span class="hljs-comment">//每个数属于哪个分块</span><span class="hljs-keyword">int</span> block;<span class="hljs-comment">//每个块的大小</span><span class="hljs-keyword">int</span> lef[<span class="hljs-number">100010</span>],rig[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该块的左/右端点位置</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d[<span class="hljs-number">100010</span>];<span class="hljs-comment">//每个块一起又加了多少</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    block=<span class="hljs-built_in">sqrt</span>(n);    num=n/block;<span class="hljs-keyword">if</span>(n%block)num++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        belong[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;        b[i]=a[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)    &#123;        lef[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>,rig[i]=i*block;        <span class="hljs-keyword">if</span>(i==num)rig[i]=n;<span class="hljs-comment">//最后一块不满的情况</span>        sort(b+lef[i],b+rig[i]+<span class="hljs-number">1</span>);<span class="hljs-comment">//块内维护升序</span>    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        printf("%lld ",b[i]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span><span class="hljs-comment">//区间更新</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)            a[i]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[l]];i&lt;=rig[belong[l]];i++)<span class="hljs-comment">//更新b[i]</span>            b[i]=a[i];        sort(b+lef[belong[l]],b+rig[belong[l]]+<span class="hljs-number">1</span>);<span class="hljs-comment">//块内维护升序</span>    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-comment">//printf("%d %d %d %d\n",belong[l],belong[r],rig[belong[l]],lef[belong[r]]);</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)            a[i]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[l]];i&lt;=rig[belong[l]];i++)<span class="hljs-comment">//更新b[i]</span>            b[i]=a[i];        sort(b+lef[belong[l]],b+rig[belong[l]]+<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)            d[i]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)            a[i]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=rig[belong[r]];i++)            b[i]=a[i];        sort(b+lef[belong[r]],b+rig[belong[r]]+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        printf("%lld ",a[i]+d[belong[i]]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> st)</span><span class="hljs-comment">//区间询问</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cur=-INF;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)        &#123;            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> zs=a[i]+d[belong[l]];            <span class="hljs-keyword">if</span>(zs&lt;st&amp;&amp;zs&gt;cur)                cur=zs;        &#125;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)        &#123;            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> zs=a[i]+d[belong[l]];            <span class="hljs-keyword">if</span>(zs&lt;st&amp;&amp;zs&gt;cur)                cur=zs;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)        &#123;            <span class="hljs-keyword">int</span> pos=lower_bound(b+lef[i],b+rig[i]+<span class="hljs-number">1</span>,st-d[i])-b;            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> zs=b[pos<span class="hljs-number">-1</span>]+d[i];            <span class="hljs-keyword">if</span>(pos<span class="hljs-number">-1</span>&gt;=lef[i]&amp;&amp;zs&lt;st&amp;&amp;zs&gt;cur)                cur=zs;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)        &#123;            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> zs=a[i]+d[belong[r]];            <span class="hljs-keyword">if</span>(zs&lt;st&amp;&amp;zs&gt;cur)                cur=zs;        &#125;    &#125;    <span class="hljs-keyword">if</span>(cur==-INF)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,cur);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("input.txt","r",stdin);</span>    <span class="hljs-comment">//freopen("output.txt","w",stdout);</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);    build();    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));    <span class="hljs-keyword">int</span> ope,l,r;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%lld"</span>,&amp;ope,&amp;l,&amp;r,&amp;c);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">0</span>)update(l,r,c);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)ask(l,r,c);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="LOJ-6280"><a href="#LOJ-6280" class="headerlink" title="LOJ 6280"></a>LOJ 6280</h5><p>题意：给出一个长为 n 的数列，以及 n 个操作，操作涉及区间加法，区间求和。</p><p>思路：加两个数组表示每个块的总和（用前缀和处理），表示每个块又加了多少，维护区间和即可。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> num;<span class="hljs-comment">//分块的个数</span><span class="hljs-keyword">int</span> belong[<span class="hljs-number">50010</span>];<span class="hljs-comment">//每个数属于哪个分块</span><span class="hljs-keyword">int</span> block;<span class="hljs-comment">//每个块的大小</span><span class="hljs-keyword">int</span> lef[<span class="hljs-number">50010</span>],rig[<span class="hljs-number">50010</span>];<span class="hljs-comment">//该块的左/右端点位置</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pre[<span class="hljs-number">50010</span>];<span class="hljs-comment">//前缀和</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum[<span class="hljs-number">50010</span>];<span class="hljs-comment">//每个块的总和</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d[<span class="hljs-number">50010</span>];<span class="hljs-comment">//每个块一起又加了多少</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    block=<span class="hljs-built_in">sqrt</span>(n);    num=n/block;<span class="hljs-keyword">if</span>(n%block)num++;    pre[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        belong[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;        pre[i]=pre[i<span class="hljs-number">-1</span>]+a[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)    &#123;        lef[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>,rig[i]=i*block;        <span class="hljs-keyword">if</span>(i==num)rig[i]=n;<span class="hljs-comment">//最后一块不满的情况</span>        sum[i]=pre[rig[i]]-pre[lef[i]<span class="hljs-number">-1</span>];    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=num;i++)</span><span class="hljs-comment">        printf("%lld ",sum[i]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span><span class="hljs-comment">//区间更新</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)            a[i]+=c,sum[belong[l]]+=c;<span class="hljs-comment">//维护区间和</span>    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-comment">//printf("%d %d %d %d\n",belong[l],belong[r],rig[belong[l]],lef[belong[r]]);</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)            a[i]+=c,sum[belong[l]]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)            d[i]+=c;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)            a[i]+=c,sum[belong[r]]+=c;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> modd)</span><span class="hljs-comment">//区间询问</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)            ans=(ans+a[i]+d[belong[l]])%modd;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)            ans=(ans+a[i]+d[belong[l]])%modd;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)            ans=(ans+sum[i]+(d[i]*block)%modd)%modd;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)            ans=(ans+a[i]+d[belong[r]])%modd;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("input.txt","r",stdin);</span>    <span class="hljs-comment">//freopen("output.txt","w",stdout);</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);    build();    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(d));    <span class="hljs-keyword">int</span> ope,l,r;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%lld"</span>,&amp;ope,&amp;l,&amp;r,&amp;c);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">0</span>)update(l,r,c);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)ask(l,r,c+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="LOJ-6281"><a href="#LOJ-6281" class="headerlink" title="LOJ 6281"></a>LOJ 6281</h5><p>题意：给出一个长为 n 的数列，以及 n 个操作，操作涉及区间开方，区间求和。</p><p>思路：跟以前做过的一道线段树差不多，那道线段树没有用到lazy标记，这里也差不多，不能直接像上面那题区间求和，要利用开方，开个bool数组标记每个块是否还可以开方，如果都是0或1的话就不能开方了，这里还是用到sum数组，查询的时候会快点。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> num;<span class="hljs-comment">//分块的个数</span><span class="hljs-keyword">int</span> belong[<span class="hljs-number">50010</span>];<span class="hljs-comment">//每个数属于哪个分块</span><span class="hljs-keyword">int</span> block;<span class="hljs-comment">//每个块的大小</span><span class="hljs-keyword">int</span> lef[<span class="hljs-number">50010</span>],rig[<span class="hljs-number">50010</span>];<span class="hljs-comment">//该块的左/右端点位置</span><span class="hljs-keyword">bool</span> can[<span class="hljs-number">50010</span>];<span class="hljs-comment">//每个块是否还可以开方</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pre[<span class="hljs-number">50010</span>];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum[<span class="hljs-number">50010</span>];<span class="hljs-comment">//每个块的和</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    block=<span class="hljs-built_in">sqrt</span>(n);    num=n/block;<span class="hljs-keyword">if</span>(n%block)num++;    pre[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        belong[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;        can[i]=<span class="hljs-literal">true</span>;        pre[i]=pre[i<span class="hljs-number">-1</span>]+a[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)    &#123;        lef[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>,rig[i]=i*block;        <span class="hljs-keyword">if</span>(i==num)rig[i]=n;<span class="hljs-comment">//最后一块不满的情况</span>        sum[i]=pre[rig[i]]-pre[lef[i]<span class="hljs-number">-1</span>];    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=num;i++)</span><span class="hljs-comment">        printf("%lld ",sum[i]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span><span class="hljs-comment">//区间更新</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">if</span>(can[belong[l]])        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)            &#123;                sum[belong[l]]=sum[belong[l]]-a[i]+<span class="hljs-built_in">sqrt</span>(a[i]);                a[i]=<span class="hljs-built_in">sqrt</span>(a[i]);            &#125;            <span class="hljs-keyword">bool</span> sign=<span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[l]];i&lt;=rig[belong[l]]&amp;&amp;!sign;i++)                <span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-number">0</span>&amp;&amp;a[i]!=<span class="hljs-number">1</span>)sign=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(!sign)can[belong[l]]=<span class="hljs-literal">false</span>;        &#125;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">if</span>(can[belong[l]])        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)            &#123;                sum[belong[l]]=sum[belong[l]]-a[i]+<span class="hljs-built_in">sqrt</span>(a[i]);                a[i]=<span class="hljs-built_in">sqrt</span>(a[i]);            &#125;            <span class="hljs-keyword">bool</span> sign=<span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[l]];i&lt;=rig[belong[l]]&amp;&amp;!sign;i++)                <span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-number">0</span>&amp;&amp;a[i]!=<span class="hljs-number">1</span>)sign=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(!sign)can[belong[l]]=<span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)        &#123;            <span class="hljs-keyword">if</span>(can[i])            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=lef[i];j&lt;=rig[i];j++)                &#123;                    sum[i]=sum[i]-a[j]+<span class="hljs-built_in">sqrt</span>(a[j]);                    a[j]=<span class="hljs-built_in">sqrt</span>(a[j]);                &#125;                <span class="hljs-keyword">bool</span> sign=<span class="hljs-literal">false</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=lef[i];j&lt;=rig[i]&amp;&amp;!sign;j++)                    <span class="hljs-keyword">if</span>(a[j]!=<span class="hljs-number">0</span>&amp;&amp;a[j]!=<span class="hljs-number">1</span>)sign=<span class="hljs-literal">true</span>;                <span class="hljs-keyword">if</span>(!sign)can[i]=<span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(can[belong[r]])        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)            &#123;                sum[belong[r]]=sum[belong[r]]-a[i]+<span class="hljs-built_in">sqrt</span>(a[i]);                a[i]=<span class="hljs-built_in">sqrt</span>(a[i]);            &#125;            <span class="hljs-keyword">bool</span> sign=<span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=rig[belong[r]]&amp;&amp;!sign;i++)                <span class="hljs-keyword">if</span>(a[i]!=<span class="hljs-number">0</span>&amp;&amp;a[i]!=<span class="hljs-number">1</span>)sign=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(!sign)can[belong[r]]=<span class="hljs-literal">false</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span><span class="hljs-comment">//区间询问</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)            ans+=a[i];    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)            ans+=a[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)            ans+=sum[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)            ans+=a[i];    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("input.txt","r",stdin);</span>    <span class="hljs-comment">//freopen("output.txt","w",stdout);</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);    build();    <span class="hljs-keyword">int</span> ope,l,r;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%lld"</span>,&amp;ope,&amp;l,&amp;r,&amp;c);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">0</span>)update(l,r,c);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)ask(l,r,c+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="LOJ-6282"><a href="#LOJ-6282" class="headerlink" title="LOJ 6282"></a>LOJ 6282</h5><p>题意：给出一个长为 n 的数列，以及 n 个操作，操作涉及单点插入，单点询问，数据随机生成。</p><p>思路：每个块放入vector内，插入的时候用insert函数实现，但是如果先在一个块有大量单点插入，这个块的大小会大大超过√n，块内的插入就很慢了，所以还需要引入一个操作：重新分块（重构），每√n次插入后，重新把数列平均分一下块。</p><p>我这里有个很奇怪的地方，rebuild()这个函数里面，我直接用覆盖n的方法会WA，但是另外用个变量就AC了，不知道错在哪里，真的很奇怪…</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> num;<span class="hljs-keyword">int</span> block;<span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> zs[<span class="hljs-number">200010</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">100010</span>];<span class="hljs-comment">//每块内的元素</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    block=<span class="hljs-built_in">sqrt</span>(n);    num=n/block;<span class="hljs-keyword">if</span>(n%block)num++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        v[(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>].push_back(a[i]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rebuild</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;v[i].<span class="hljs-built_in">size</span>();j++)            zs[++tot]=v[i][j];        v[i].<span class="hljs-built_in">clear</span>();    &#125;    block=<span class="hljs-built_in">sqrt</span>(tot);    num=tot/block;<span class="hljs-keyword">if</span>(tot%block)num++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;i++)        v[(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>].push_back(zs[i]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span><span class="hljs-comment">//在l前面加入r</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)    &#123;        <span class="hljs-keyword">int</span> can=l-v[i].<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(can&gt;<span class="hljs-number">0</span>)            l=l-v[i].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//x不在这块</span>        <span class="hljs-keyword">else</span>        &#123;            v[i].insert(v[i].<span class="hljs-built_in">begin</span>()+l<span class="hljs-number">-1</span>,r);            <span class="hljs-keyword">if</span>(v[i].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">20</span>*block)rebuild();            <span class="hljs-comment">/*for(int j=1;j&lt;=num;j++)</span><span class="hljs-comment">            &#123;</span><span class="hljs-comment">                for(int k=0;k&lt;v[j].size();k++)</span><span class="hljs-comment">                    printf("%d ",v[j][k]);</span><span class="hljs-comment">                printf("\n");</span><span class="hljs-comment">            &#125;*/</span>            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)    &#123;        <span class="hljs-keyword">int</span> can=x-v[i].<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(can&gt;<span class="hljs-number">0</span>)x=x-v[i].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//x不在这块</span>        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,v[i][x<span class="hljs-number">-1</span>]);            <span class="hljs-comment">//printf("v[%d]\n",i);</span>            <span class="hljs-keyword">return</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("/Users/apple/Desktop/input.txt","r",stdin);</span>   <span class="hljs-comment">//freopen("/Users/apple/Desktop/output.txt","w",stdout);</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);    build();    <span class="hljs-keyword">int</span> ope,l,r,c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;ope,&amp;l,&amp;r,&amp;c);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">0</span>)update(l,r);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)ask(r);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="LOJ-6283"><a href="#LOJ-6283" class="headerlink" title="LOJ 6283"></a>LOJ 6283</h5><p>题意：给出一个长为 n 的数列，以及 n 个操作，操作涉及区间乘法，区间加法，单点询问。</p><p>思路：之前线段树专题里做过差不多的题目，lazy标记变成ax+b形式即可。这里每次更新a[i]，即块外的时候，要把标记下放，否则会打乱乘除的顺序，在块内则不需要，因为块内并没有改变a[i]，如果块内之后变成块外的话，会下放。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> num;<span class="hljs-comment">//分块的个数</span><span class="hljs-keyword">int</span> belong[<span class="hljs-number">100010</span>];<span class="hljs-comment">//每个数属于哪个分块</span><span class="hljs-keyword">int</span> block;<span class="hljs-comment">//每个块的大小</span><span class="hljs-keyword">int</span> lef[<span class="hljs-number">100010</span>],rig[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该块的左/右端点位置</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d[<span class="hljs-number">100010</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">//每个块的增量ax+b</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    block=<span class="hljs-built_in">sqrt</span>(n);    num=n/block;<span class="hljs-keyword">if</span>(n%block)num++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        belong[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)    &#123;        lef[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>,rig[i]=i*block;        d[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;d[i][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    &#125;    rig[num]=n;<span class="hljs-comment">//最后一块不满的情况</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[x];i&lt;=rig[x];i++)    &#123;        a[i]=(a[i]*d[x][<span class="hljs-number">0</span>])%MOD;        a[i]=(a[i]+d[x][<span class="hljs-number">1</span>])%MOD;    &#125;    d[x][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;d[x][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">if</span>(d[belong[l]][<span class="hljs-number">0</span>]!=<span class="hljs-number">1</span>||d[belong[l]][<span class="hljs-number">1</span>]!=<span class="hljs-number">0</span>)pushdown(belong[l]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)            a[i]=(a[i]+c)%MOD;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-comment">//printf("belong:%d %d\n",belong[l],belong[r]);</span>        <span class="hljs-keyword">if</span>(d[belong[l]][<span class="hljs-number">0</span>]!=<span class="hljs-number">1</span>||d[belong[l]][<span class="hljs-number">1</span>]!=<span class="hljs-number">0</span>)pushdown(belong[l]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)            a[i]=(a[i]+c)%MOD;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)            d[i][<span class="hljs-number">1</span>]=(d[i][<span class="hljs-number">1</span>]+c)%MOD;<span class="hljs-comment">//a[i]没有改变，不需要pushdown</span>        <span class="hljs-keyword">if</span>(d[belong[r]][<span class="hljs-number">0</span>]!=<span class="hljs-number">1</span>||d[belong[r]][<span class="hljs-number">1</span>]!=<span class="hljs-number">0</span>)pushdown(belong[r]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)            a[i]=(a[i]+c)%MOD;    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        printf("%lld ",a[i]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">if</span>(d[belong[l]][<span class="hljs-number">0</span>]!=<span class="hljs-number">1</span>||d[belong[l]][<span class="hljs-number">1</span>]!=<span class="hljs-number">0</span>)pushdown(belong[l]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)            a[i]=(a[i]*c)%MOD;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-comment">//printf("belong:%d %d\n",belong[l],belong[r]);</span>        <span class="hljs-keyword">if</span>(d[belong[l]][<span class="hljs-number">0</span>]!=<span class="hljs-number">1</span>||d[belong[l]][<span class="hljs-number">1</span>]!=<span class="hljs-number">0</span>)pushdown(belong[l]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)            a[i]=(a[i]*c)%MOD;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)            d[i][<span class="hljs-number">0</span>]=(d[i][<span class="hljs-number">0</span>]*c)%MOD,d[i][<span class="hljs-number">1</span>]=(d[i][<span class="hljs-number">1</span>]*c)%MOD;        <span class="hljs-keyword">if</span>(d[belong[r]][<span class="hljs-number">0</span>]!=<span class="hljs-number">1</span>||d[belong[r]][<span class="hljs-number">1</span>]!=<span class="hljs-number">0</span>)pushdown(belong[r]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)            a[i]=(a[i]*c)%MOD;    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><span class="hljs-comment">        printf("%lld ",a[i]);</span><span class="hljs-comment">    printf("\n");*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=a[r];    ans=(ans*d[belong[r]][<span class="hljs-number">0</span>])%MOD;    ans=(ans+d[belong[r]][<span class="hljs-number">1</span>])%MOD;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("/Users/apple/Desktop/input.txt","r",stdin);</span>    <span class="hljs-comment">//freopen("/Users/apple/Desktop/output.txt","w",stdout);</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);    build();    <span class="hljs-keyword">int</span> ope,l,r;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%lld"</span>,&amp;ope,&amp;l,&amp;r,&amp;c);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">0</span>)update1(l,r,c);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)update2(l,r,c);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">2</span>)ask(r);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="LOJ-6284"><a href="#LOJ-6284" class="headerlink" title="LOJ 6284"></a>LOJ 6284</h5><p>题意：给出一个长为 n 的数列，以及 n 个操作，操作涉及区间询问等于一个数 c 的元素，并将这个区间的所有元素改为 c。</p><p>思路：维护每个分块是否只有一种权值，区间操作的时候，对于同权值的一个块就O(1)统计答案，否则暴力统计答案，并修改标记，不完整的块也暴力。</p><p>假设初始序列都是同一个值，那么查询是O(√n)，如果这时进行一个区间操作，它最多破坏首尾2个块的标记，所以只能使后面的询问至多多2个块的暴力时间，所以均摊每次操作复杂度还是O(√n)。换句话说，要想让一个操作耗费O(n)的时间，要先花费√n个操作对数列进行修改。pushdown操作类似上题。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> num;<span class="hljs-comment">//分块的个数</span><span class="hljs-keyword">int</span> belong[<span class="hljs-number">100010</span>];<span class="hljs-comment">//每个数属于哪个分块</span><span class="hljs-keyword">int</span> block;<span class="hljs-comment">//每个块的大小</span><span class="hljs-keyword">int</span> lef[<span class="hljs-number">100010</span>],rig[<span class="hljs-number">100010</span>];<span class="hljs-comment">//该块的左/右端点位置</span><span class="hljs-keyword">int</span> same[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    block=<span class="hljs-built_in">sqrt</span>(n);    num=n/block;<span class="hljs-keyword">if</span>(n%block)num++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        belong[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)        lef[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>,rig[i]=i*block;    rig[num]=n;<span class="hljs-comment">//最后一块不满的情况</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[x];i&lt;=rig[x];i++)        a[i]=same[x];    same[x]=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">if</span>(same[belong[l]]!=<span class="hljs-number">-1</span>)pushdown(belong[l]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)        &#123;            <span class="hljs-keyword">if</span>(a[i]==c)ans++;            <span class="hljs-keyword">else</span> a[i]=c;        &#125;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">if</span>(same[belong[l]]!=<span class="hljs-number">-1</span>)pushdown(belong[l]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)        &#123;            <span class="hljs-keyword">if</span>(a[i]==c)ans++;            <span class="hljs-keyword">else</span> a[i]=c;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=belong[l]+<span class="hljs-number">1</span>;i&lt;=belong[r]<span class="hljs-number">-1</span>;i++)        &#123;            <span class="hljs-keyword">if</span>(same[i]!=<span class="hljs-number">-1</span>)            &#123;                <span class="hljs-keyword">if</span>(same[i]==c)ans+=block;                <span class="hljs-keyword">else</span> same[i]=c;            &#125;            <span class="hljs-keyword">else</span><span class="hljs-comment">//不同</span>            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=lef[i];j&lt;=rig[i];j++)                &#123;                    <span class="hljs-keyword">if</span>(a[j]==c)ans++;                    <span class="hljs-keyword">else</span> a[j]=c;                &#125;                same[i]=c;            &#125;        &#125;        <span class="hljs-keyword">if</span>(same[belong[r]]!=<span class="hljs-number">-1</span>)pushdown(belong[r]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)        &#123;            <span class="hljs-keyword">if</span>(a[i]==c)ans++;            a[i]=c;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("/Users/apple/Desktop/input.txt","r",stdin);</span>    <span class="hljs-comment">//freopen("/Users/apple/Desktop/output.txt","w",stdout);</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);    <span class="hljs-built_in">memset</span>(same,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(same));    build();    <span class="hljs-keyword">int</span> l,r,c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;c);        solve(l,r,c);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="LOJ-6285"><a href="#LOJ-6285" class="headerlink" title="LOJ 6285"></a>LOJ 6285</h5><p>题意：给出一个长为 n 的数列，以及 n 个操作，操作涉及询问区间的最小众数。</p><p>思路：</p><p>解法一：</p><p>众数应该是完整的所有块的众数，和不完整块中出现的数。</p><p>所以我们可以预处理f(i,j)表示第 i 块到第 j 块的众数（枚举 i 开个桶扫一遍）。</p><p>对于块内的众数就用预处理出来的；对于块外的，给每个数 x 开个vector，按顺序存下 x 出现的位置，每次询问 x 时把区间的左右端点放进对应 vector 二分一下即可。</p><p>为了不爆内存，所以要先离散化。</p><p>我第一次是直接用map映射，每次读取都是mp[a[i]]这样，结果TLE到怀疑人生。看了别人的代码，发现别人的map不是这样用的，而是开了val数组来保存离散后的编号所对应的原来的数字，然后把原数列变成离散后的样子。原来map这么慢啊…涨姿势…（其实还有一种离散的方式来着吧…</p><p>解法二：</p><p>查询之前，先预处理一下，统计出两个东西：cnt(i)(j)和ans(i)(j)。<br>cnt(i)(j)表示i这个数在前j块出现的次数；<br>ans(i)(j)表示从i块到j块的答案，统计的都是整块的答案。<br>搞定这些的时间复杂度是O(nn√)的。<br>对于cnt(i)(j)的统计，先做出每一块i出现的次数，然后一遍前缀和搞定。对于ans(i)(j)的统计，先确定起点l，就是第i块的起点，然后r向后暴力移动统计，当r等于一个块的终点时，记录答案。<br>对于统计ans(i)(j)时，别忘了清数组，看好r……</p><p>对于块外的，用前缀和处理，不够的地方暴力统计。</p><p>因为这里数据范围有1e5，cnt数组如果在块大为√n时会爆内存（看到最快的用这种方法100000*500居然没爆内存？？？我以为1e6就要爆内存了？？？（迷）），或许把块搞得大一点可以？</p><p>代码（解法一）：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> num;<span class="hljs-comment">//分块的个数</span><span class="hljs-keyword">int</span> belong[<span class="hljs-number">100010</span>];<span class="hljs-comment">//每个数属于哪个分块</span><span class="hljs-keyword">int</span> block;<span class="hljs-comment">//每个块的大小</span><span class="hljs-keyword">int</span> lef[<span class="hljs-number">400</span>],rig[<span class="hljs-number">400</span>];<span class="hljs-comment">//该块的左/右端点位置</span><span class="hljs-keyword">int</span> f[<span class="hljs-number">400</span>][<span class="hljs-number">400</span>];<span class="hljs-comment">//第i块到第j块的众数</span><span class="hljs-keyword">int</span> ff[<span class="hljs-number">400</span>][<span class="hljs-number">400</span>];<span class="hljs-comment">//第i块到第j块的众数出现的次数</span><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;mp;<span class="hljs-comment">//离散数据</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">100010</span>];<span class="hljs-comment">//记录每个数字（离散后）出现的位置</span><span class="hljs-keyword">int</span> val[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> apr[<span class="hljs-number">100010</span>];<span class="hljs-comment">//每个数出现的次数（桶排）</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    block=<span class="hljs-built_in">sqrt</span>(n);    num=n/block;<span class="hljs-keyword">if</span>(n%block)num++;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        belong[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)        lef[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>,rig[i]=i*block;    rig[num]=n;<span class="hljs-comment">//最后一块不满的情况</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)    &#123;        <span class="hljs-keyword">int</span> MAX=<span class="hljs-number">0</span>;<span class="hljs-comment">//出现最多的数字出现的最多次数</span>        <span class="hljs-keyword">int</span> pos=INF;<span class="hljs-comment">//出现最多的数字</span>        <span class="hljs-built_in">memset</span>(apr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(apr));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=lef[i];j&lt;=n;j++)        &#123;            apr[a[j]]++;            <span class="hljs-keyword">if</span>(apr[a[j]]&gt;MAX||(apr[a[j]]==MAX&amp;&amp;val[a[j]]&lt;pos))<span class="hljs-comment">//最小众数</span>                pos=val[a[j]],MAX=apr[a[j]],                f[i][belong[j]]=pos,ff[i][belong[j]]=MAX;        &#125;    &#125;    <span class="hljs-comment">/*for(int i=1;i&lt;=num;i++)</span><span class="hljs-comment">     for(int j=i;j&lt;=num;j++)</span><span class="hljs-comment">     printf("%d~%d:%d %d\n",i,j,f[i][j],ff[i][j]);*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=INF,MAX=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(belong[l]==belong[r])    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=r;i++)        &#123;            <span class="hljs-keyword">int</span> d=upper_bound(v[a[i]].<span class="hljs-built_in">begin</span>(),v[a[i]].<span class="hljs-built_in">end</span>(),r)-lower_bound(v[a[i]].<span class="hljs-built_in">begin</span>(),v[a[i]].<span class="hljs-built_in">end</span>(),l);            <span class="hljs-keyword">if</span>(d&gt;MAX||(d==MAX&amp;&amp;val[a[i]]&lt;ans))                ans=val[a[i]],MAX=d;        &#125;    &#125;    <span class="hljs-keyword">else</span>    &#123;        ans=f[belong[l]+<span class="hljs-number">1</span>][belong[r]<span class="hljs-number">-1</span>];        MAX=ff[belong[l]+<span class="hljs-number">1</span>][belong[r]<span class="hljs-number">-1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;=rig[belong[l]];i++)        &#123;            <span class="hljs-keyword">int</span> d=upper_bound(v[a[i]].<span class="hljs-built_in">begin</span>(),v[a[i]].<span class="hljs-built_in">end</span>(),r)-lower_bound(v[a[i]].<span class="hljs-built_in">begin</span>(),v[a[i]].<span class="hljs-built_in">end</span>(),l);            <span class="hljs-keyword">if</span>(d&gt;MAX||(d==MAX&amp;&amp;val[a[i]]&lt;ans))                ans=val[a[i]],MAX=d;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lef[belong[r]];i&lt;=r;i++)        &#123;            <span class="hljs-keyword">int</span> d=upper_bound(v[a[i]].<span class="hljs-built_in">begin</span>(),v[a[i]].<span class="hljs-built_in">end</span>(),r)-lower_bound(v[a[i]].<span class="hljs-built_in">begin</span>(),v[a[i]].<span class="hljs-built_in">end</span>(),l);            <span class="hljs-keyword">if</span>(d&gt;MAX||(d==MAX&amp;&amp;val[a[i]]&lt;ans))                ans=val[a[i]],MAX=d;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//freopen("/Users/apple/Desktop/input.txt","r",stdin);</span>    <span class="hljs-comment">//freopen("/Users/apple/Desktop/output.txt","w",stdout);</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);        <span class="hljs-keyword">if</span>(mp[a[i]]==<span class="hljs-number">0</span>)&#123;mp[a[i]]=++cnt;val[cnt]=a[i];&#125;<span class="hljs-comment">//离散化</span>        a[i]=mp[a[i]];        v[a[i]].push_back(i);    &#125;    build();    init();    <span class="hljs-keyword">int</span> l,r;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r);        solve(l,r);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ2420 爬山算法&amp;&amp;模拟退火</title>
    <link href="/2018/02/13/%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95-%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
    <url>/2018/02/13/%E7%88%AC%E5%B1%B1%E7%AE%97%E6%B3%95-%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>题意</strong>：给出平面上N（&lt;=100）个点，你需要找到一个这样的点，使得这个点到N个点的距离之和尽可能小。输出这个最小的距离和（四舍五入到最近的整数）。</p><p><strong>思路</strong>：参考博客：<a href="http://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html" target="_blank" rel="noopener">http://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html</a></p><p>就和之前一道cf里可以用猴子乱序做的那道题一样感觉有点玄学…虽然知道流程是怎么样了但是就是很奇怪的感觉orz…</p><p>设置的delta初始温度下限温度的不同会得到不同的结果，所以多试几个参数去逼近答案吧（毕竟答案是最小的…（这时候样例就非常重要了…</p><p>关于爬山算法与模拟退火，有一个有趣的比喻：</p><p>爬山算法：兔子朝着比现在高的地方跳去。它找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是爬山算法，它不能保证局部最优值就是全局最优值。</p><p>模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高方向跳去。这就是模拟退火。</p><p>伪代码</p><pre><code class="hljs c++"><span class="hljs-comment">/*</span><span class="hljs-comment">* J(y)：在状态y时的评价函数值</span><span class="hljs-comment">* Y(i)：表示当前状态</span><span class="hljs-comment">* Y(i+1)：表示新的状态</span><span class="hljs-comment">* r： 用于控制降温的快慢</span><span class="hljs-comment">* T： 系统的温度，系统初始应该要处于一个高温的状态</span><span class="hljs-comment">* T_min ：温度的下限，若温度T达到T_min，则停止搜索</span><span class="hljs-comment">*/</span><span class="hljs-keyword">while</span>( T &gt; T_min )&#123;　　dE = J( Y(i+<span class="hljs-number">1</span>) ) - J( Y(i) ) ; 　　<span class="hljs-keyword">if</span> ( dE &gt;=<span class="hljs-number">0</span> ) <span class="hljs-comment">//表达移动后得到更优解，则总是接受移动</span>Y(i+<span class="hljs-number">1</span>) = Y(i) ; <span class="hljs-comment">//接受从Y(i)到Y(i+1)的移动</span>　　<span class="hljs-keyword">else</span>　　&#123;<span class="hljs-comment">// 函数exp( dE/T )的取值范围是(0,1) ，dE/T越大，则exp( dE/T )也</span><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">exp</span>( dE/T ) &gt; <span class="hljs-built_in">random</span>( <span class="hljs-number">0</span> , <span class="hljs-number">1</span> ) )<span class="hljs-comment">//这里是求最大所以是&gt;,如果是最小就是&lt;了</span>Y(i+<span class="hljs-number">1</span>) = Y(i) ; <span class="hljs-comment">//接受从Y(i)到Y(i+1)的移动</span>　　&#125;　　T = r * T ; <span class="hljs-comment">//降温退火 ，0&lt;r&lt;1 。r越大，降温越慢；r越小，降温越快</span>　　<span class="hljs-comment">/*</span><span class="hljs-comment">　　* 若r过大，则搜索到全局最优解的可能会较高，但搜索的过程也就较长。若r过小，则搜索的过程会很快，但最终可能会达到一个局部最优值</span><span class="hljs-comment">　　*/</span>　　i ++ ;&#125;</code></pre><p><strong>代码</strong>：</p><p>爬山算法版：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">double</span> x,y;&#125;p[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a,<span class="hljs-built_in">point</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        sum+=dist(a,p[i]);    <span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;p[i].x,&amp;p[i].y);    <span class="hljs-keyword">double</span> maxt=<span class="hljs-number">100</span>;<span class="hljs-comment">//初始温度</span>    <span class="hljs-keyword">double</span> delta=<span class="hljs-number">0.99</span>;<span class="hljs-comment">//用来控制降温的快慢</span>    <span class="hljs-keyword">double</span> mint=<span class="hljs-number">1e-8</span>;<span class="hljs-comment">//温度的下限，到达该温度就停止搜索</span>    <span class="hljs-built_in">point</span> pp;pp.x=<span class="hljs-number">0</span>;pp.y=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始的点</span>    <span class="hljs-built_in">point</span> nn;    <span class="hljs-keyword">double</span> t=maxt;    <span class="hljs-keyword">double</span> ans=INF;    <span class="hljs-keyword">while</span>(t&gt;mint)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)        &#123;            nn.x=pp.x+dx[i]*t;<span class="hljs-comment">//随机步长</span>            nn.y=pp.y+dy[i]*t;            <span class="hljs-keyword">double</span> zs=getsum(nn);            <span class="hljs-keyword">if</span>(zs&lt;ans)            &#123;                ans=zs;                pp=nn;            &#125;        &#125;        t=t*delta;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,(<span class="hljs-keyword">int</span>)(ans+<span class="hljs-number">0.5</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>模拟退火版：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">double</span> x,y;&#125;p[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dist</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a,<span class="hljs-built_in">point</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        sum+=dist(a,p[i]);    <span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    srand(time(<span class="hljs-literal">NULL</span>));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;p[i].x,&amp;p[i].y);    <span class="hljs-keyword">double</span> maxt=<span class="hljs-number">400</span>;<span class="hljs-comment">//初始温度</span>    <span class="hljs-keyword">double</span> delta=<span class="hljs-number">0.99</span>;    <span class="hljs-keyword">double</span> mint=<span class="hljs-number">1e-8</span>;<span class="hljs-comment">//温度的下限，到达该温度就停止搜索</span>    <span class="hljs-built_in">point</span> pp;pp.x=<span class="hljs-number">0</span>;pp.y=<span class="hljs-number">0</span>;<span class="hljs-comment">//初始的点</span>    <span class="hljs-built_in">point</span> nn;    <span class="hljs-keyword">double</span> t=maxt;    <span class="hljs-keyword">double</span> ans=INF;    <span class="hljs-keyword">while</span>(t&gt;mint)    &#123;        <span class="hljs-keyword">double</span> rad=rand()%<span class="hljs-number">360</span>+<span class="hljs-number">1</span>;        nn.x=pp.x+t*<span class="hljs-built_in">cos</span>(rad);        nn.y=pp.y+t*<span class="hljs-built_in">sin</span>(rad);        <span class="hljs-keyword">double</span> zs=getsum(nn);        <span class="hljs-keyword">if</span>(zs&lt;ans)<span class="hljs-comment">//移动后得到更优的解，接受该移动</span>        &#123;            ans=zs;            pp=nn;        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span>(zs-ans)/t&lt;rand()%<span class="hljs-number">100000</span>*<span class="hljs-number">0.00001</span>)<span class="hljs-comment">//生成（0，1）之间的随机数</span>            &#123;                ans=zs;                pp=nn;            &#125;        &#125;        t=t*delta;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,(<span class="hljs-keyword">int</span>)(ans+<span class="hljs-number">0.5</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ2823 单调队列&amp;&amp;POJ2559 单调栈</title>
    <link href="/2018/02/12/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2018/02/12/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h5 id="POJ-2823"><a href="#POJ-2823" class="headerlink" title="POJ 2823"></a><strong>POJ 2823</strong></h5><p>题意：给定一个大小已知的数组以及一个大小已知的滑动窗口，窗口每个时刻向后移动一位，求出每个时刻窗口中数字的最大值和最小值。</p><p>思路： 单调队列可以用来维护某一区间的最值。</p><p>1.从队尾插入元素：当有新元素需要入队时，让它与当前队尾元素进行比较，若它小于等于当前队尾元素（即破坏了原队列的单调性），那么删除队尾元素，并继续比较队尾与新元素，直到找到一个队尾大于新元素时，将新元素插入到队尾。被删除的元素既比新元素大，又会比新元素先滑出窗口，因此肯定不会成为答案。这个操作不断维护了队列中的最值。</p><p>2.删除队首元素：由于序列中的元素当且仅当在滑动窗口时有效，因此，当队首元素不在滑动窗口内时，就删除队首元素。这个操作维护了数据的临时性。</p><p>双端队列（deque）常用函数：</p><p>deq.front()：返回第一个元素的引用。</p><p>deq.back()：返回最后一个元素的引用。</p><p>deq.push_front(x)：把元素x插入到双向队列的头部。</p><p>deq.pop_front()：弹出双向队列的第一个元素。</p><p>deq.push_back(x)：把元素x插入到双向队列的尾部。</p><p>deq.pop_back()：弹出双向队列的最后一个元素。</p><p>代码（POJ不开O2用STL就是慢…所以用了两个队列）：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> v,id;&#125;;<span class="hljs-keyword">int</span> a[<span class="hljs-number">1000010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,k;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k);    <span class="hljs-built_in">deque</span>&lt;node&gt;q;    node temp;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//维护一个单调递增队列求最小值</span>    &#123;        temp.v=a[i];        temp.id=i;        <span class="hljs-keyword">if</span>(!q.empty())        &#123;            <span class="hljs-keyword">if</span>(q.back().v&lt;=temp.v)                q.push_back(temp);            <span class="hljs-keyword">else</span>            &#123;                <span class="hljs-keyword">while</span>(!q.empty()&amp;&amp;q.back().v&gt;temp.v)                    q.pop_back();                q.push_back(temp);            &#125;        &#125;        <span class="hljs-keyword">else</span> q.push_back(temp);        <span class="hljs-keyword">if</span>(i-q.front().id&gt;k<span class="hljs-number">-1</span>)q.pop_front();        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>)        &#123;            <span class="hljs-keyword">if</span>(i!=n<span class="hljs-number">-1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,q.front().v);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,q.front().v);        &#125;    &#125;    <span class="hljs-built_in">deque</span>&lt;node&gt;Q;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//维护一个单调递减队列求最大值</span>    &#123;        temp.v=a[i];        temp.id=i;        <span class="hljs-keyword">if</span>(!Q.empty())        &#123;            <span class="hljs-keyword">if</span>(Q.back().v&gt;=temp.v)                Q.push_back(temp);            <span class="hljs-keyword">else</span>            &#123;                <span class="hljs-keyword">while</span>(!Q.empty()&amp;&amp;Q.back().v&lt;temp.v)                    Q.pop_back();                Q.push_back(temp);            &#125;        &#125;        <span class="hljs-keyword">else</span> Q.push_back(temp);        <span class="hljs-keyword">if</span>(i-Q.front().id&gt;k<span class="hljs-number">-1</span>)Q.pop_front();        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>)        &#123;            <span class="hljs-keyword">if</span>(i!=n<span class="hljs-number">-1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,Q.front().v);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,Q.front().v);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="HDU1506"><a href="#HDU1506" class="headerlink" title="HDU1506"></a><strong>HDU1506</strong></h5><p>题意：给一个由几个相连接的矩形组成的多边形，计算多边形包含的最大的矩形的面积。</p><p><img src="http://poj.org/images/2559_1.jpg" srcset="/img/loading.gif" alt="POJ2559"></p><p>思路：要想找到里面的最大的面积，我们可以对每一个矩形的高度为标准，尽量的向两头扩展，这样就可以找出以它高度为标准的，并包含它本身的最大矩形。要将其扩展过去，必须高度不低于当前扩展点的高度。</p><p>单调栈可以很方便地求出某个数的左边或者右边第一个比它大或者小的元素。</p><p>从左到右遍历，对于当前矩形，如果高度比栈顶大或相等，就放入栈中，如果高度比栈顶小，就让栈顶退栈，因为该元素比栈顶元素更靠近后面的元素，而且比栈顶元素更小，所以更优，这样直到栈顶高度小于等于该矩形，那么所退的元素的右边第一个比它小的元素就是该矩形。找左边的同理，从右边开始遍历。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">int</span> h[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> l[<span class="hljs-number">100010</span>],r[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;h[i]);        ll ans=<span class="hljs-number">0</span>;        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;s;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            l[i]=<span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(!s.empty()&amp;&amp;h[i]&lt;=h[s.top()])                s.pop();            <span class="hljs-keyword">if</span>(!s.empty())l[i]=s.top();            s.push(i);        &#125;        <span class="hljs-keyword">while</span>(!s.empty())s.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)        &#123;            r[i]=n+<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(!s.empty()&amp;&amp;h[i]&lt;=h[s.top()])                s.pop();            <span class="hljs-keyword">if</span>(!s.empty())r[i]=s.top();            s.push(i);        &#125;        ll temp;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            temp=<span class="hljs-number">1l</span>l*h[i]*(r[i]-l[i]<span class="hljs-number">-1</span>);            ans=<span class="hljs-built_in">max</span>(ans,temp);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>匹配问题专题</title>
    <link href="/2018/02/11/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E4%B8%93%E9%A2%98/"/>
    <url>/2018/02/11/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>（并没有开始做这个专题但是做到了这个专题里的一道题所以就开始开坑吧（。</p><h5 id="HDU-4185"><a href="#HDU-4185" class="headerlink" title="HDU 4185"></a><strong>HDU 4185</strong></h5><p>题意：有一片油田，但是不是纯净的，有的地方是水，现在有一个捞石油的机器，但是这个机器捞的范围是固定的，是2×1的一个矩形大小，那么对于整个油田打捞，也只能打捞2×1的地方，那么，最多可以打捞多少？</p><p>思路：这里考察的是二分图匹配，对于每个’#’对上下左右的’#’建边即可（因为建图WA了几发（迷）），注意这里的标号是所有的，所以匹配之后所有点都有匹配，所以最后要除以二。</p><h5 id="POJ-3041"><a href="#POJ-3041" class="headerlink" title="POJ 3041"></a>POJ 3041</h5><p>题意：给一个N*N的矩阵，有些格子有障碍，要求我们消除这些障碍，问每次消除一行或一列的障碍，最少要几次。</p><p>思路：行列建图。</p><p>最小顶点覆盖：对于图中的每条边，选择这条边的一个端点视为将这条边覆盖，那么一定存在一个最小点覆盖使得选取的点的数量最小同时覆盖所有的边。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络流</title>
    <link href="/2018/02/08/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <url>/2018/02/08/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h5 id="最大流及Dinic算法"><a href="#最大流及Dinic算法" class="headerlink" title="最大流及Dinic算法"></a><strong>最大流及Dinic算法</strong></h5><p>参考博客：<a href="http://www.cnblogs.com/SYCstudio/p/7260613.html" target="_blank" rel="noopener">http://www.cnblogs.com/SYCstudio/p/7260613.html</a></p><p><a href="https://comzyh.com/blog/archives/568/#Dinic-Code" target="_blank" rel="noopener">https://comzyh.com/blog/archives/568/#Dinic-Code</a></p><p><a href="https://www.cnblogs.com/y-clever/p/6308820.html" target="_blank" rel="noopener">https://www.cnblogs.com/y-clever/p/6308820.html</a></p><p><a href="https://blog.csdn.net/lirewriter/article/details/78759337" target="_blank" rel="noopener">https://blog.csdn.net/lirewriter/article/details/78759337</a></p><p><a href="https://www.bilibili.com/video/av18800207/index_2.html#page=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av18800207/index_2.html#page=2</a></p><p>网络流的最大流算法就是指的一个流量的方案使得网络中流量最大。</p><p>网络流最大流的求解：</p><p>网络流的所有算法都是基于一种增广路的思想，下面首先简要的说一下增广路思想，其基本步骤如下：</p><blockquote><p>1.找到一条从源点到汇点的路径，使得路径上任意一条边的残量&gt;0（注意是小于而不是小于等于，这意味着这条边还可以分配流量），这条路径便称为增广路<br>2.找到这条路径上最小的F(u)(v)（我们设F(u)(v)表示u-&gt;v这条边上的残量即剩余流量），下面记为flow<br>3.将这条路径上的每一条有向边u-&gt;v的残量减去flow，同时对于起反向边v-&gt;u的残量加上flow（为什么呢？我们下面再讲）<br>4.重复上述过程，直到找不出增广路，此时我们就找到了最大流</p></blockquote><p>这个算法是基于增广路定理(Augmenting Path Theorem): 网络达到最大流当且仅当残留网络中没有增广路。</p><p>Dinic 算法：<br>基本思路:</p><blockquote><p>1.根据残量网络计算层次图。<br>2.在层次图中使用DFS进行增广直到不存在增广路。<br>3.重复以上步骤直到无法增广。</p></blockquote><p>较详细解释(流程) :</p><p>&gt;</p><blockquote><p>1.用BFS建立分层图  注意:分层图是以当前图为基础建立的,所以要重复建立分层图。<br>2.用DFS的方法寻找一条由源点到汇点的路径,获得这条路径的流量I 根据这条路径修改整个图,将所经之处正向边流量减少I,反向边流量增加I,注意I是非负数。<br>3.重复步骤2,直到DFS找不到新的路径时,重复步骤1。</p></blockquote><p>当前弧优化：</p><p>对于每个点，我可能在一次BFS之后DFS多次。那么它出发的边所到的点里， 有些点出发已经满流。</p><p>这样， 我就可以每个点记录一个当前弧， 表示这次DFS它最后DFS到哪条弧，下次DFS它的时候就从这条弧开始。</p><p>这样，我就可以保证每条边在一次DFS中满流后不会再遍历。</p><p>模板：</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> s,e;<span class="hljs-comment">//源点、汇点</span><span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    ll cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">200010</span>];<span class="hljs-comment">//邻接表要开边数的两倍</span><span class="hljs-keyword">int</span> head[<span class="hljs-number">10010</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">10010</span>];<span class="hljs-comment">//当前弧优化</span><span class="hljs-keyword">int</span> dis[<span class="hljs-number">10010</span>];<span class="hljs-comment">//分层图中每个点的层数（即到原点的最短距离）</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,ll z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;<span class="hljs-comment">//能否到汇点，不能就结束</span>&#125;<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,ll cp)</span><span class="hljs-comment">//id为当前节点，cp为当前最小残量</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;<span class="hljs-comment">//流到终点了或者没有流了</span>    ll res=<span class="hljs-number">0</span>,f;<span class="hljs-comment">//ret:本次搜索能找到的所有流量，f：本次搜索一条路径的可以通过的流量</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));<span class="hljs-comment">//能通的流就等于搜过后面之后允许的流，和自己允许的流的最小值</span>            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;<span class="hljs-comment">//反向边剩余流量加上f</span>                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">ll <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())<span class="hljs-comment">//建立分层图</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            cur[i]=head[i];<span class="hljs-comment">//每一次建立完分层图后都要把cur置为每一个点的第一条边//？？？</span>        ans+=dfs(s,INF);<span class="hljs-comment">//只要有路就走,假设它有无限流，再慢慢调整</span>    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;e)!=EOF)    &#123;        top=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));        <span class="hljs-keyword">while</span>(m--)        &#123;            <span class="hljs-keyword">int</span> x,y;            ll z;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%lld"</span>,&amp;x,&amp;y,&amp;z);            add(x,y,z);            add(y,x,<span class="hljs-number">0</span>);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,dinic());    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a><strong>最大流最小割定理</strong></h5><p>在一个有权图中，源点为Vs，汇点为Vt，如果拿掉这张图中的一些边，就无法从Vs到达Vt，这些边的组合就叫做割集。</p><p>对于一个网络流图G=(V,E)，其割的定义为一种点的划分方式：将所有的点划分为S和T=V-S两个部分，其中源点s∈S，汇点t∈T。</p><p>对于一个割(S,T)，我们定义净流f(S,T)表示穿过割(S,T)的流量之和，即：</p><p>f(S,T) = Σf(u,v) | u∈S,v∈T<br>举个例子：</p><p><img src="http://media.hihocoder.com/problem_images/20160917/14741006888435.jpg" srcset="/img/loading.gif" alt="1.jpg"></p><p>净流f = f(2,4)+f(3,4)+f(3,5) = 12+(-4)+11 = 19</p><p>同时我们定义割的容量C(S,T)为所有从S到T的边容量之和，即：</p><p>C(S,T) = Σc(u,v) | u∈S,v∈T</p><p>割的容量：所有正向割边的容量和</p><p>同样在上面的例子中，其割的容量为：</p><p>c(2,4)+c(3,5)=12+14=26</p><p>实际上对于任意一个割的净流f(S,T)总是和网络流的流量f相等。比如上面例子中我们改变一下割的方式：</p><p><img src="http://media.hihocoder.com/problem_images/20160917/14741006882954.jpg" srcset="/img/loading.gif" alt="2.jpg"></p><p>可以计算出对于这两种情况净流f(S,T)仍然等于19。</p><p><u>任意一个割的净流f(S,T)都等于当前网络的流量f。</u></p><p><u>对于网络的任意一个流f一定是小于等于任意一个割的容量C(S,T)。</u></p><p><u>而在所有可能的割中，存在一个容量最小的割，我们称其为最小割。</u></p><p><u>对于任一个网络流图来说，其最大流一定是小于等于最小割的。</u></p><p>最大流最小割定理：</p><p><u>对于一个网络流图G=(V,E)，其中有源点s和汇点t，那么下面三个条件是等价的：</u></p><p><u>流f是图G的最大流</u></p><p><u>残留网络Gf不存在增广路</u></p><p><u>对于G的某一个割(S,T)，此时f = C(S,T)</u></p><p>首先有<strong>割的容量C(S,T)=T中所有正权点的权值之和+S中所有负权点的权值绝对值之和</strong>。</p><h5 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h5><p>费用流建立在网络最大流的基础上，一张图中最大流有且仅有一个，但是最大流条数往往不止一条，这时候对于我们来说，可能要找出这些最大流中最小（或者最大）的那一条路径（贪心策略嘛），这就是最小（最大）费用最大流  </p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> ll INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> s,e;<span class="hljs-comment">//源点、汇点</span>ll ans;<span class="hljs-comment">//最大流量情况下的最小费用</span><span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    ll cap;    ll cost;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">100010</span>];<span class="hljs-comment">//邻接表要开边数的两倍</span><span class="hljs-keyword">int</span> head[<span class="hljs-number">5010</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">5010</span>];ll dis[<span class="hljs-number">5010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,ll c,ll d)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=c;    eg[top].cost=d;    eg[top].to=b;    eg[top].next=head[a];    head[a]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ss,<span class="hljs-keyword">int</span> ee)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)        dis[i]=INF;    dis[ee]=<span class="hljs-number">0</span>;vis[ee]=<span class="hljs-literal">true</span>;    <span class="hljs-built_in">deque</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    q.push_back(ee);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> temp=q.front();        q.pop_front();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[temp];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> tp=eg[i].to;            <span class="hljs-keyword">if</span>(eg[i^<span class="hljs-number">1</span>].cap&amp;&amp;dis[tp]&gt;dis[temp]-eg[i].cost)            &#123;                dis[tp]=dis[temp]-eg[i].cost;                <span class="hljs-keyword">if</span>(!vis[tp])                &#123;                    vis[tp]=<span class="hljs-literal">true</span>;                    <span class="hljs-keyword">if</span>(!q.empty()&amp;&amp;dis[tp]&lt;dis[q.front()])q.push_front(tp);                    <span class="hljs-keyword">else</span> q.push_back(tp);                &#125;            &#125;        &#125;        vis[temp]=<span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> dis[ss]&lt;INF;&#125;<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,ll cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x==e)    &#123;        vis[e]=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> cp;    &#125;    ll used=<span class="hljs-number">0</span>,a;    vis[x]=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[x];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(!vis[temp]&amp;&amp;eg[i].cap&amp;&amp;dis[x]-eg[i].cost==dis[temp])        &#123;            a=dfs(temp,<span class="hljs-built_in">min</span>(eg[i].cap,cp-used));            <span class="hljs-keyword">if</span>(a)            &#123;                ans+=a*eg[i].cost;                eg[i].cap-=a;                eg[i^<span class="hljs-number">1</span>].cap+=a;                used+=a;            &#125;            <span class="hljs-keyword">if</span>(used==cp)<span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> used;&#125;<span class="hljs-function">ll <span class="hljs-title">costflow</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ll flow=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(spfa(s,e))    &#123;        vis[e]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(vis[e])        &#123;            <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));            flow+=dfs(s,INF);        &#125;    &#125;    <span class="hljs-keyword">return</span> flow;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;e)!=EOF)    &#123;        top=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));        <span class="hljs-keyword">while</span>(m--)        &#123;            <span class="hljs-keyword">int</span> a,b;            ll c,d;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;d);            add(a,b,c,d);            add(b,a,<span class="hljs-number">0</span>,-d);        &#125;        ans=<span class="hljs-number">0</span>;        ll temp=costflow();<span class="hljs-comment">//最大流</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld %lld\n"</span>,temp,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>匹配问题</title>
    <link href="/2018/02/06/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2018/02/06/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><p>参考博客：<a href="http://www.renfei.org/blog/bipartite-matching.html" target="_blank" rel="noopener">http://www.renfei.org/blog/bipartite-matching.html</a></p><p><a href="http://blog.csdn.net/sixdaycoder/article/details/47680831" target="_blank" rel="noopener">http://blog.csdn.net/sixdaycoder/article/details/47680831</a></p><p><a href="https://www.cnblogs.com/logosG/p/logos.html" target="_blank" rel="noopener">https://www.cnblogs.com/logosG/p/logos.html</a></p><p><strong>二分图</strong>：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：<u>把一个图的顶点划分为两个不相交集 U 和V ，使得每一条边都分别连接U、V中的顶点</u>。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。</p><p><strong>匹配</strong>：在图论中，一个「匹配」（matching）是一个边的集合，其中<u>任意两条边都没有公共顶点</u>。例如，图 3、图 4 中红色的边就是图 2 的匹配。</p><p><img src="http://img.renfei.org/2013/08/1.png" srcset="/img/loading.gif" alt="Bipartite Graph(1)">  <img src="http://img.renfei.org/2013/08/2.png" srcset="/img/loading.gif" alt="Bipartite Graph(2)">  <img src="http://img.renfei.org/2013/08/3.png" srcset="/img/loading.gif" alt="Matching">  <img src="http://img.renfei.org/2013/08/4.png" srcset="/img/loading.gif" alt="Maximum Matching"></p><p>我们定义<strong>匹配点</strong>、<strong>匹配边</strong>、<strong>未匹配点</strong>、<strong>非匹配边</strong>，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。</p><p><strong>最大匹配</strong>：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。</p><p><strong>完美匹配</strong>：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。</p><h4 id="二分图的最大匹配（匈牙利算法）"><a href="#二分图的最大匹配（匈牙利算法）" class="headerlink" title="二分图的最大匹配（匈牙利算法）"></a><strong>二分图的最大匹配（匈牙利算法）</strong></h4><p><img src="http://img.renfei.org/2013/08/5.png" srcset="/img/loading.gif" alt="5"></p><p><strong>交替路</strong>：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p><p><strong>增广路</strong>： 从一个未匹配点出发，依次遍历未匹配边、匹配边、未匹配边，这样交替下去，如果最后一个点是未匹配点，这条路径称为增广路。换句话说，起点和终点都为未匹配点的交错路为增广路（agumenting path）（特别提醒，这里的增广路和网络流中的增广路的意义不同）。</p><p>例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：</p><p><img src="http://img.renfei.org/2013/08/6.png" srcset="/img/loading.gif" alt="6"></p><p>观察图6我们可发现增广路的一些特点。</p><ol><li>增广路一定有奇数条边。</li><li>增广路中未匹配边一定比匹配边多一条（因为是从未匹配点出发走交错路到未匹配点结束）</li></ol><p>这里其实就表明了研究增广路的意义。<br>如果找到了一条增广路，那么将未匹配点与匹配边的<strong>身份</strong>调换,那么匹配的边数就多了一条，这样直到找不到增广路为止，那么整个图的匹配的边数一定最大，也就是找到了二分图的最大匹配。</p><p>这里的<strong>身份调换</strong>是指 ：<br>原来匹配的边为edge(1,6),edge(4,8)，匹配边数为2。找到一条增广路（这里不一定从9开始找，任何一个未匹配点都可以）后，现在匹配的边为edge(2,6),edge(1,8),edge(4,9),匹配边数为3。</p><p>匈牙利算法正是利用了增广路的这个性质，从X集合中找到一个未匹配点，寻找增广路，找到了匹配数+1，如果没有找到，那么从X中找到下一个未匹配的点，再次寻找增广路……重复上述过程，直到X集合中的所有节点都被“增广”完毕，无论如何都找不到增广路，那么整个图的匹配数就最大了。</p><p>我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。</p><p><strong>匈牙利树</strong>一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树：</p><p><img src="http://img.renfei.org/2013/08/7.png" srcset="/img/loading.gif" alt="7">   <img src="http://img.renfei.org/2013/08/8.png" srcset="/img/loading.gif" alt="8">    <img src="http://img.renfei.org/2013/08/9.png" srcset="/img/loading.gif" alt="9"></p><p>这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。</p><p>易懂版本参考博客：<a href="http://blog.csdn.net/dark_scope/article/details/8880547" target="_blank" rel="noopener">http://blog.csdn.net/dark_scope/article/details/8880547</a></p><p>代码（增广路注释）：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">110</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> link[<span class="hljs-number">110</span>];<span class="hljs-comment">//右列中与之匹配的左边的</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[id][i];        <span class="hljs-keyword">if</span>(!vis[temp])<span class="hljs-comment">//不在交替路中</span>        &#123;            vis[temp]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记在交替路中</span>            <span class="hljs-keyword">if</span>(link[temp]==<span class="hljs-number">-1</span>||judge(link[temp]))<span class="hljs-comment">//如果是未盖点，说明交替路是增广路，则交换路径，并返回成功</span>            &#123;                link[temp]=id;                <span class="hljs-comment">//link[id]=temp;//如果左边一列与右边一列编号不同就带上这句</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//从id出发没有增广路</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxmatch</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(link,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(link));    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));        <span class="hljs-keyword">if</span>(judge(i))            num++;    &#125;    <span class="hljs-keyword">return</span> num;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    m=m-n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        v[i].<span class="hljs-built_in">clear</span>();    <span class="hljs-keyword">int</span> x,y;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">-1</span>&amp;&amp;y==<span class="hljs-number">-1</span>)<span class="hljs-keyword">break</span>;        v[x].push_back(y);        <span class="hljs-comment">//v[y].push_back(x);</span>    &#125;    <span class="hljs-keyword">int</span> ans=maxmatch();    <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"No Solution!\n"</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>代码（易懂注释）：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">110</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> link[<span class="hljs-number">110</span>];<span class="hljs-comment">//右列中与之匹配的左边的</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[id][i];        <span class="hljs-keyword">if</span>(!vis[temp])<span class="hljs-comment">//如果可以匹配并且还没有标记过(这里标记的意思是这次查找曾试图改变过这个人的归属问题，但是没有成功，所以就不用瞎费工夫了）</span>        &#123;            vis[temp]=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(link[temp]==<span class="hljs-number">-1</span>||judge(link[temp]))<span class="hljs-comment">//没人匹配或者与之匹配的人可以腾出个位置来，这里使用递归</span>            &#123;                link[temp]=id;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxmatch</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(link,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(link));    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));        <span class="hljs-keyword">if</span>(judge(i))            num++;    &#125;    <span class="hljs-keyword">return</span> num;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    m=m-n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        v[i].<span class="hljs-built_in">clear</span>();    <span class="hljs-keyword">int</span> x,y;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">-1</span>&amp;&amp;y==<span class="hljs-number">-1</span>)<span class="hljs-keyword">break</span>;        v[x].push_back(y);        <span class="hljs-comment">//v[y].push_back(x);</span>    &#125;    <span class="hljs-keyword">int</span> ans=maxmatch();    <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"No Solution!\n"</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>匈牙利算法的要点如下</p><ol><li>从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。<ol><li>如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。</li><li>如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。</li></ol></li><li>由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 <code>prev</code> 数组。</li></ol><p>补充定义和定理：</p><p><strong>最大匹配数</strong>：最大匹配的匹配边的数目</p><p><strong>最小顶点覆盖</strong>：假如选了一个点就相当于覆盖了以它为端点的所有边。最小顶点覆盖就是选择最少的点来覆盖所有的边。很显然，最大匹配中的结点满足该性质，也就是说</p><center>最小顶点覆盖数=最大匹配数</center><p><strong>最大独立集</strong> ： 二分图中最大的一个点集，该点集内的点互不相连（没有边相连）。回想一下图4 : <img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20150815155559261.png" srcset="/img/loading.gif" alt="这里写图片描述">显然这里给出了图的一个最大匹配，将最大匹配中的点从原来的节点集合V中删除，那么剩下的点不会有任何边相连，也就是说</p><center>最大独立集数目=|V|−最大匹配数</center><p><strong>最小路径覆盖数</strong>：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。</p><center>最小路径覆盖=最大独立集=|V|−最大匹配</center><p><strong>无向图的最大团</strong>:  从V个顶点选出k个顶点，使得这k个顶点构成一个完全图，即该子图任意两个顶点都有直接的边。</p><center>最大团 = 补图的最大独立集</center><h4 id="二分图最大权匹配（KM算法）"><a href="#二分图最大权匹配（KM算法）" class="headerlink" title="二分图最大权匹配（KM算法）"></a><strong>二分图最大权匹配（KM算法）</strong></h4><p>参考博客：<a href="http://blog.csdn.net/zxn0803/article/details/49999267" target="_blank" rel="noopener">http://blog.csdn.net/zxn0803/article/details/49999267</a></p><p><a href="https://www.cnblogs.com/wenruo/p/5264235.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenruo/p/5264235.html</a></p><p>相等子图是原图的一个生成子图（生成子图即包含原图的所有结点，但是不包含所有的边）,并且该生成子图中只包含满足lx(x)+ly(y)=weight(x,y)的边,这样的边我们称之为可行边。</p><p>步骤如下：<br>首先用邻接矩阵存储二分图，注意：<strong>如果只想求最大权值匹配而不要求是完备匹配的话，请把各个不相连的边的权值设置为0</strong>。<br>之后进行下述步骤：<br>1.运用贪心算法初始化标杆。<br>2.运用匈牙利算法找到完备匹配。<br>3.如果找不到，则通过修改标杆，增加一些边。<br>4.重复2，3的步骤，找到完备匹配时可结束。<br>标杆分为X标杆和Y标杆，一般我们把比较少的点放在X标杆一侧。<br>这样进行算法：<br>首先要初始化两个标杆分别为X标杆和Y标杆，X标杆初始化为与之相连的最大边权，Y标杆初始化为0，且直接加入拥有最大边权的边。如果发现此时的匹配就是完备匹配，那么直接退出，否则进行标杆的更改。从第一个节点开始扫描，如果有合法的增广路，那么将其反选，扩充路径，如果该节点没有合法的增广路，那么则将增广路上的所有的X标杆上的点加入点集S,将Y标杆上的所有点加入点集T，从S和不在T集合中的点里面，计算d=min{L(x)+L(y)-w(x,y)};计算后，将在S点集内的x的顶标减d，在T的y的顶标加d。并将目前没有加入二分图的权值和等于顶标和的边作为未匹配边加入到二分图中，然后再在该节点寻找增广路，如果还是没有，则再次通过更改标杆来增加边，直到有增广路出现为止。之后重复寻找增广路的步骤以及更改标杆的步骤，如果出现了完备匹配，那么直接退出。<br>我认为：求d的过程是把xy的顶标和及其权值相差最小的边加入到二分图中，而修改顶标的过程是使得其顶标之和等于新增入的边权，并使得之前选择的那些边仍然存在（即其顶标和仍等于权值和）。<br>看得有点绕？<br>我们来看一下强行手工模拟：<br>有邻接矩阵如下：<br>x1 x2 x3 x4 x5<br>y1 7 3 14 19 23<br>y2  <em>8</em>  <em>10</em>  <em>15</em> 18 20<br>y3 6 8 12 16 19<br>y4 4 9 13  <em>20</em>  <em>25</em><br>y5 2 7 12 10 15<br>非常完美的一个邻接矩阵，其中斜体为边权最大值。下面我们按照上面的晕乎乎的步骤来进行模拟吧。 </p><p>初始化标杆使X标杆的值为斜体字的值。<br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184147332.png" srcset="/img/loading.gif" alt="KM算法1"><br>连接每条边并且使得x1和y3匹配，然后遍历x2，发现x2找不到合法增广路。<br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184201273.png" srcset="/img/loading.gif" alt="KM算法2"><br>把不合法路径上的x点都归为点集S,y点都归为T,将不在T中的y点和在S中的点尝试进行加边。<br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184222429.png" srcset="/img/loading.gif" alt="KM算法3"><br>找到两条边，更新顶标之后，成功形成增广路，运用匈牙利算法反选。<br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184247664.png" srcset="/img/loading.gif" alt="KM算法4"><br>给x3找一个合法的增广路，一下就找到了，直接反选，结束。 </p><p>下面不对，应该只有一条不合法路径，S={x2,x3,x4},T={y2,y4}，所以x1和y1不变。</p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184259230.png" srcset="/img/loading.gif" alt="KM算法5"></p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184313723.png" srcset="/img/loading.gif" alt="KM算法6"><br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184404897.png" srcset="/img/loading.gif" alt="KM算法7"><br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184421687.png" srcset="/img/loading.gif" alt="KM算法8"><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184457642.png" srcset="/img/loading.gif" alt="KM算法9"></p><p>一个优化是对Y顶点引入松弛函数slack，slack[j]保存跟当前节点j相连的节点i的lx[i]+ly[j]−weight(i,j)的最小值，于是求delta时只需O(n)枚举<strong>不在交错树</strong>中的Y顶点的最小slack值即可。</p><p>松弛值可以在匈牙利算法检查相等子树边失败时进行更新，同时在修改标号后也要更新，具体参考代码实现。</p><p>如果我们要求边权值最小的匹配呢？？？</p><p>我们可以把边权值取负值，得出结果后再取相反数就可以了。</p><p>以HDU 2255为例</p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> nx,ny;<span class="hljs-keyword">int</span> w[<span class="hljs-number">310</span>][<span class="hljs-number">310</span>];<span class="hljs-keyword">int</span> lx[<span class="hljs-number">310</span>],ly[<span class="hljs-number">310</span>];<span class="hljs-keyword">int</span> link[<span class="hljs-number">310</span>];<span class="hljs-comment">//右边对应的左边的编号</span><span class="hljs-keyword">bool</span> visx[<span class="hljs-number">310</span>],visy[<span class="hljs-number">310</span>];<span class="hljs-keyword">int</span> slack[<span class="hljs-number">310</span>];<span class="hljs-comment">//跟当前节点j相连的节点i的lx[i]+ly[j]−weight(i,j)的最小值</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span><span class="hljs-comment">//寻找增广路</span></span><span class="hljs-function"></span>&#123;    visx[id]=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ny;i++)    &#123;        <span class="hljs-keyword">if</span>(visy[i])<span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">int</span> temp=lx[id]+ly[i]-w[id][i];        <span class="hljs-keyword">if</span>(temp==<span class="hljs-number">0</span>)<span class="hljs-comment">//“lx[t]+ly[i]==w[t][i]”决定了这是在相等子图中找增广路的前提</span>        &#123;            visy[i]=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(link[i]==<span class="hljs-number">-1</span>||dfs(link[i]))            &#123;                link[i]=id;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">else</span> slack[i]=<span class="hljs-built_in">min</span>(slack[i],temp);<span class="hljs-comment">//(x,y)不在相等子图中且y不在交错树中</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KM</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(link,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(link));    <span class="hljs-built_in">memset</span>(ly,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ly));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nx;i++)    &#123;        lx[i]=-INF;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ny;j++)            lx[i]=<span class="hljs-built_in">max</span>(lx[i],w[i][j]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nx;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ny;j++)slack[j]=INF;<span class="hljs-comment">//每次换新的x结点都要初始化slack</span>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//如果没有找到一条合法增广路，就一直加边</span>        &#123;            <span class="hljs-built_in">memset</span>(visx,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(visx));            <span class="hljs-built_in">memset</span>(visy,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(visy));            <span class="hljs-keyword">if</span>(dfs(i))<span class="hljs-keyword">break</span>;<span class="hljs-comment">//找到增广路，退出</span>            <span class="hljs-keyword">int</span> d=INF;<span class="hljs-comment">//否则，应该加入新的边，计算d的值</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ny;j++)                <span class="hljs-keyword">if</span>(!visy[j])d=<span class="hljs-built_in">min</span>(d,slack[j]);            <span class="hljs-comment">//if(d==INF)return -1;//找不到可以加入的边，即没有完美匹配</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;nx;j++)                <span class="hljs-keyword">if</span>(visx[j])lx[j]-=d;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ny;j++)            &#123;                <span class="hljs-keyword">if</span>(visy[j])ly[j]+=d;                <span class="hljs-keyword">else</span> slack[j]-=d;                <span class="hljs-comment">//修改顶标后，要把所有的slack值都减去delta</span>                <span class="hljs-comment">//这是因为lx[i] 减小了delta</span>                <span class="hljs-comment">//slack[j] = min(lx[i] + ly[j] -w[i][j]) --j不属于交错树--也需要减少delta</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ny;i++)    &#123;        <span class="hljs-keyword">if</span>(link[i]!=<span class="hljs-number">-1</span>)            sum+=w[link[i]][i];    &#125;    <span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        nx=ny=n;        <span class="hljs-comment">//memset(w,0,sizeof(w));</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nx;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ny;j++)                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;w[i][j]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,KM());    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="二分图多重匹配"><a href="#二分图多重匹配" class="headerlink" title="二分图多重匹配"></a><strong>二分图多重匹配</strong></h4><p>二分图多重最大匹配：</p><p>在原图上建立源点S和汇点T，S向每个X方点连一条容量为该X方点L值的边，每个Y方点向T连一条容量为该Y方点L值的边，原来二分图中各边在新的网络中仍存在，容量为1（若该边可以使用多次则容量大于1），求该网络的最大流，就是该二分图多重最大匹配的值。</p><p>二分图多重最优匹配：<br>在原图上建立源点S和汇点T，S向每个X方点连一条容量为该X方点L值、费用为0的边，每个Y方点向T连一条容量为该Y方点L值、费用为0的边，原来二分图中各边在新的网络中仍存在，容量为1（若该边可以使用多次则容量大于1），费用为该边的权值。求该网络的最大费用最大流，就是该二分图多重最优匹配的值。</p><p>以hihocoder1393为例：<a href="https://hihocoder.com/problemset/problem/1393" target="_blank" rel="noopener">https://hihocoder.com/problemset/problem/1393</a></p><p>题意：</p><p>班级一共有N名学生，编号依次为1..N。运动会一共有M项不同的比赛，编号为1..M。第i项比赛每个班需要派出m[i]名选手参加。</p><p>编号为i的学生表示最多同时参加a[i]项比赛，并且给出他所擅长的b[i]项比赛的编号。</p><p>要求将每个学生都安排到他所擅长的比赛项目，以增加夺冠的可能性。同时又要考虑满足每项比赛对人数的要求，当然给一个学生安排的比赛项目也不能超过他愿意参加的比赛项目数量。</p><p>问能否有一个合适的安排，同时满足这些条件。</p><p>思路：</p><p>将学生看作A部，比赛项目看作B部，比如编号为i的学生擅长编号为j的项目，那么就连接A[i]-B[j]。</p><p>因为A[i]最多只能和a[i]的点相连。所以我们需要一个方法来限制这个量在0~a[i]之间变动，有点像网络流里面的流量，只能在0和容量之间变动。</p><p>首先虚拟一个源点s和汇点t，在s和A[i]之间连接一条容量为a[i]的边，将原来A[i]-B[j]直接的边都改造为从A[i]到B[j]的容量为1的边，由于比赛项目B[j]最多只需要m[j]名选手参加，所以我们不妨限制B[j]-t的容量为m[j]。</p><p><img src="http://media.hihocoder.com/problem_images/20160924/14747068019148.jpg" srcset="/img/loading.gif" alt="6.jpg"></p><p>s-A[i]：这一类边的流量表示了A[i]参加的项目数量。</p><p>A[i]-B[j]：这一类边的流量表示了A[i]是否参加项目B[j]，若参加则流量为1，否则流量为0。</p><p>B[j]-t：这一类边的流量表示了参加比赛项目B[j]的选手数量。</p><p>由于流网络会自动调整去满足最大流量，所以它会自动调整每个A[i]-B[j]的流量来使得B[j]-t尽可能大。</p><p>若每个项目都能够满足人数的话，网络流会自己调整为所有B[j]-t都满流的情况。</p><p>只需要最后判断一下每一条B[j]-t的边是否满流，就可以知道能否满足需求。同时还可以根据A[i]-B[j]的情况，计算出每个选手所参加的比赛项目。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> s,e;<span class="hljs-comment">//源点、汇点</span><span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">100010</span>];<span class="hljs-comment">//邻接表要开边数的两倍</span><span class="hljs-keyword">int</span> head[<span class="hljs-number">210</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">210</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">210</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+m+<span class="hljs-number">1</span>;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x;        <span class="hljs-keyword">int</span> y;        <span class="hljs-keyword">int</span> z;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);<span class="hljs-comment">//学生/比赛</span>        top=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));        s=<span class="hljs-number">0</span>;e=n+m+<span class="hljs-number">1</span>;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;x);            sum+=x;            add(n+i,e,x);            add(e,n+i,<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;x);            add(s,i,x);            add(i,s,<span class="hljs-number">0</span>);            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;y);            <span class="hljs-keyword">while</span>(y--)            &#123;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;z);                z+=n;                add(i,z,<span class="hljs-number">1</span>);                add(z,i,<span class="hljs-number">0</span>);            &#125;        &#125;        <span class="hljs-keyword">if</span>(dinic()==sum)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Yes\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="最小路径覆盖的网络流做法"><a href="#最小路径覆盖的网络流做法" class="headerlink" title="最小路径覆盖的网络流做法"></a><strong>最小路径覆盖的网络流做法</strong></h4><p>hihocoder1394：<a href="http://hihocoder.com/problemset/problem/1394" target="_blank" rel="noopener">http://hihocoder.com/problemset/problem/1394</a></p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> s,e;<span class="hljs-comment">//源点、汇点</span><span class="hljs-keyword">int</span> top;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cap;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">100010</span>];<span class="hljs-comment">//邻接表要开边数的两倍</span><span class="hljs-keyword">int</span> head[<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> cur[<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> dis[<span class="hljs-number">1010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> z)</span></span><span class="hljs-function"></span>&#123;    eg[top].cap=z;    eg[top].to=y;    eg[top].next=head[x];    head[x]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    dis[s]=<span class="hljs-number">0</span>;    q.push(s);    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> id=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)        &#123;            <span class="hljs-keyword">int</span> temp=eg[i].to;            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)            &#123;                dis[temp]=dis[id]+<span class="hljs-number">1</span>;                q.push(temp);                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res=<span class="hljs-number">0</span>,f;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">int</span> temp=eg[i].to;        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)        &#123;            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)            &#123;                eg[i].cap-=f;                eg[i^<span class="hljs-number">1</span>].cap+=f;                res+=f;                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(bfs())    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;i++)            cur[i]=head[i];        ans+=dfs(s,INF);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    s=<span class="hljs-number">0</span>;e=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        add(s,i,<span class="hljs-number">1</span>),add(i,s,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;i++)        add(i,e,<span class="hljs-number">1</span>),add(e,i,<span class="hljs-number">0</span>);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);        add(x,n+y,<span class="hljs-number">1</span>),add(n+y,x,<span class="hljs-number">0</span>);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,n-dinic());    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="二分图常用建图方法"><a href="#二分图常用建图方法" class="headerlink" title="二分图常用建图方法"></a>二分图常用建图方法</h4><h5 id="行列匹配法"><a href="#行列匹配法" class="headerlink" title="行列匹配法"></a>行列匹配法</h5><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802104803640.png" srcset="/img/loading.gif" alt="img"></p><p>上图是一个 3 * 3 的矩阵，方格内的 1 表示这个地方有敌人，0 表示没有敌人,现在我们有很多箭，每根箭可以杀死一行或者一列的敌人，问我们要杀死所有的敌人至要用到几根箭？<br>我们要杀死某个敌人，只要让他所在的行列有箭经过就行。也就是所有的位置都被箭覆盖就行，就是顶点的最小覆盖，既然是顶点的最小覆盖，而且我们要杀的是敌人，那么我们的点就应该是敌人的位子，即(行列)对于上面那个图我么可以建立下面这个模型：</p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802105126921.png" srcset="/img/loading.gif" alt="img"></p><p>一个二分图的最小顶点覆盖就是要找到最少的边把所有的顶点覆盖，二分图的最小顶点覆盖是等于二分图的最大匹配。所以我们只需要对上面的那个二分图就最大匹配就行。</p><h5 id="黑白染色法"><a href="#黑白染色法" class="headerlink" title="黑白染色法"></a>黑白染色法</h5><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802105325500.png" srcset="/img/loading.gif" alt="img"></p><p>又是一个图，要求是把方格里的所有的 1 改为零，一次最多只能修改相邻的两个，问最少需要修改几次? </p><p>既然是每次只能拿相邻的两个，正好我们匹配的时候也是找两个进行匹配，这是否就是这个题和最大二分图匹配相联系的地方呢？但是每个点能和他四周的四个点匹配,那么我们怎么把所有的点分成两个部分呢？就是要把第i个点放到第一部分，第i个点周围的四个点放到第二部分，再把这四个点周围的点放到第一部分。有了这样的思想，我们只需对原图做这样的改动：黑白染色使四周和中间的颜色不同。</p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802105807265.png" srcset="/img/loading.gif" alt="img"></p><p>图中黑白的意思是就是把点分类，图里的 1,2,3,4,5,6 表示的就是上面那个 0，1 图的1 的个数，然后建图，把相邻的点相连，比如说1和2，2和3。</p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802105906030.png" srcset="/img/loading.gif" alt="img"></p><p>然后要把所有一改为零，也就是要对每个点都操作，每个点都要有，那不就是最小顶点覆盖吗？这个问题解决了。</p><h5 id="反建法"><a href="#反建法" class="headerlink" title="反建法"></a>反建法</h5><p>问题背景:一个极度封建的老师要带同学们出去玩,但是他怕在途中同学之间发生恋情老师研究了一下发现,满足下面几种条件的两个同学之间发生恋情的可能性很小<br>1）身高差 &gt; 40<br>2）性别相同<br>3）爱好不同的音乐<br>4）爱好同类型的运动<br>显然如果我们用满足上面条件的同学之间建边那么最后建立起来的就不是二分图了。稍微观察一下,男生之间我们是随便带的,女生也是,因为他们彼此性别相同。因此我们就可以把男女分为两部分,那么男女之间如何建边?如果我们把男女满足不发生恋情的连起来,那么求出来的最大匹配没有代表性,不能得到我们想要的结果。因此我们用反建法,把男女中可能发生恋情的建立边。也就是说把身高差&lt;=40 或 爱好相同音乐或爱好不同类型运动的男女同学之间用边连起来。然后求一个最大独立集,最大独立集的原则不就是找到一个点集,使得集合内的点互不相连且点尽量多吗?我们把可能发生恋情的男女相连,那么最大独立集不就是我们要找的不可能发生恋情的人的集合吗? 那么, 这个问题解决了!</p><h5 id="拆点法"><a href="#拆点法" class="headerlink" title="拆点法"></a>拆点法</h5><p>拆点法是用于解决最小路径覆盖问题的,给出一个图</p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110208488.png" srcset="/img/loading.gif" alt="img"></p><p>要找到几条路径,可以把所有的点经过,并且路径之间不可以交叉。我们的做法是把点拆成两部分(点 1 拆为 x1,y1. 点 2 拆为 x2,y2……)</p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110300686.png" srcset="/img/loading.gif" alt="img"></p><p>如果我们对这个图求二分图的最大匹配,你会发现每个匹配对应着一个路径覆盖,因此,此二分图的最大匹配即:原图中的最小路径覆盖上的边的个数(路径是由 0 条,1 条或多条边组成的)。那么原图的最小路径覆盖数 = 原图顶点数 – 最小路径上的边数 也就是 原图的最小路径覆盖数 = 原图顶点数 – 二分图最大匹配数。</p><h5 id="一行变多行-一列变多列"><a href="#一行变多行-一列变多列" class="headerlink" title="一行变多行,一列变多列"></a>一行变多行,一列变多列</h5><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110411526.png" srcset="/img/loading.gif" alt="img"></p><p>上面是一个 4*4 的方格,方格内的###表示墙,我们要在表格内没有墙的地方建立碉堡,而且要保证任何两个碉堡之间互相不能攻击,问最多能建多少个碉堡?是否感觉像第一个题呢?如果我们向第一个题那样建图,那么最后求出来的最大匹配也就是行和列的匹配。而且这个匹配满足了所有匹配都是不同行不同列(匹配本身的性质就是每个点至多属于匹配中的某个边)。但是这样的建图的话,我们墙怎么处理? 有墙的地方就相当于把这一行和这一列分成了两行,两列。<br>例如</p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110605983.png" srcset="/img/loading.gif" alt="img"></p><p>一行变成了两行。</p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110450890.png" srcset="/img/loading.gif" alt="img"></p><p>然后我们按照这个编号建图即可</p><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110558718.png" srcset="/img/loading.gif" alt="img"></p><p>对这个图求二分图最大匹配即可。这个问题也解决了!</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1696 极角排序</title>
    <link href="/2018/02/05/POJ-1696-%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F/"/>
    <url>/2018/02/05/POJ-1696-%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>题意：给你平面的一个点集,然后要你从y坐标最小的点开始以水平方向向下一个点连线,每次只能直走或左转,问你最多能走多少点?(输出所有走过的点,且不走回头路,所有点坐标均唯一)</p><p><img src="http://poj.org/images/1696_1.jpg" srcset="/img/loading.gif" alt="img"></p><p>思路：</p><p>​       本题其实就是用极角排序,每次都有一个你的当前点,然后每次都贪心的走以当前点为中心的极角最小的那个点(如果有多个,就走距离当前点最近的那个点即可.)</p><p>​       这样,我们能保证能走过的点数是最多的.</p><p><img src="http://img.blog.csdn.net/20141015234020125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ4MDYwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img"></p><p>​       为什么上述贪心算法是对的呢?其实这就是每次都在找最外层的凸包.</p><p><img src="http://img.blog.csdn.net/20141015234047705?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ4MDYwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="img"></p><p>完整代码：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">double</span> x,y;&#125;a[<span class="hljs-number">110</span>],p[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> n,top;<span class="hljs-keyword">int</span> cur;<span class="hljs-comment">//记录新的极点</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cross</span><span class="hljs-params">(<span class="hljs-built_in">point</span> p0,<span class="hljs-built_in">point</span> p1,<span class="hljs-built_in">point</span> p2)</span><span class="hljs-comment">//叉乘判断在左边还是右边</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a,<span class="hljs-built_in">point</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">point</span> p1,<span class="hljs-built_in">point</span> p2)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> c=cross(p[cur],p1,p2);    <span class="hljs-keyword">if</span>(c&gt;<span class="hljs-number">0</span>||(c==<span class="hljs-number">0</span>&amp;&amp;dis(p[cur],p1)&lt;dis(p[cur],p2)))        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">graham</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;<span class="hljs-comment">//最下最左的点</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-keyword">if</span>((a[i].y&lt;a[pos].y)||(a[i].y==a[pos].y&amp;&amp;a[i].x&lt;a[pos].x))            pos=i;    swap(a[pos],a[<span class="hljs-number">0</span>]);    p[<span class="hljs-number">0</span>]=a[<span class="hljs-number">0</span>];cur=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)    &#123;        sort(a+i,a+n,cmp);<span class="hljs-comment">//极角排序</span>        <span class="hljs-comment">//printf("(%d)",cur);</span>        <span class="hljs-comment">/*for(int j=i;j&lt;n;j++)</span><span class="hljs-comment">            printf("%d ",a[j].id);</span><span class="hljs-comment">        printf("\n");*/</span>        p[i]=a[i];        cur=i;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%lf%lf"</span>,&amp;a[i].id,&amp;a[i].x,&amp;a[i].y);        graham();        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,n);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,p[i].id);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,p[n<span class="hljs-number">-1</span>].id);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在debug的时候找到了一个坐标系上画点的网站：</p><p><a href="https://www.desmos.com" target="_blank" rel="noopener">https://www.desmos.com</a></p><p>挺好用的233333</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wannafly挑战赛9</title>
    <link href="/2018/02/03/Wannafly%E6%8C%91%E6%88%98%E8%B5%9B9/"/>
    <url>/2018/02/03/Wannafly%E6%8C%91%E6%88%98%E8%B5%9B9/</url>
    
    <content type="html"><![CDATA[<p><strong>C 列一列</strong></p><p>题意：小W在计算一个数列{An},其中A1=1,A2=2,An+2=An+1+An。输入数列中的某一项，输出该项是是数列的第几项。</p><p>思路：这里用的是取模来存的思想，Hash一样来存。</p><p>对于unsigned整型溢出，C的规范是有定义的——“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模。</p><p>对于signed整型的溢出，C的规范定义是“undefined behavior”，也就是说，编译器爱怎么实现就怎么实现。对于大多数编译器来说，算得啥就是啥。</p><p>让它自然溢出就相当于取模了，这里很迷，long long 溢出后似乎也是取模的，试了一下似乎是这样的。</p><p>不行的话就用1e9+7来模，不过似乎会有冲突，可以特判或者找两个数来模，如果两个结果都符合的话，就可以了。</p><pre><code class="hljs c++"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> f[<span class="hljs-number">1000010</span>];<span class="hljs-keyword">char</span> a[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;f[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">1000000</span>;i++)    &#123;        f[i]=f[i<span class="hljs-number">-2</span>]+f[i<span class="hljs-number">-1</span>];        <span class="hljs-comment">//printf("%lld ",f[i]);</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    init();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a)!=EOF)    &#123;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> aa=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(a);i++)            aa=aa*<span class="hljs-number">10</span>+a[i]-<span class="hljs-string">'0'</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1000000</span>;i++)            <span class="hljs-keyword">if</span>(f[i]==aa)            &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,i);                <span class="hljs-keyword">break</span>;            &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算几何</title>
    <link href="/2018/02/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    <url>/2018/02/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="http://dev.gameres.com/Program/Abstract/Geometry.htm#" target="_blank" rel="noopener">http://dev.gameres.com/Program/Abstract/Geometry.htm#</a></p><h5 id="向量的点积"><a href="#向量的点积" class="headerlink" title="向量的点积"></a><strong>向量的点积</strong></h5><p>结果为<script type="math/tex">\vec{a}· \vec{b}=x_1x_2+y_1y_2</script>。</p><p>点积的结果是一个数值。</p><p>点积的集合意义：我们以向量 a 向向量 b 做垂线，则<script type="math/tex">| a |*cos(a,b)</script>为 a 在向量 b 上的投影，即点积是一个向量在另一个向量上的投影乘以另一个向量。且满足交换律</p><p>应用：可以根据集合意义求两向量的夹角，<script type="math/tex">\vec{a}·\vec{b}=|\vec{a}||\vec{b}|cos\theta</script>。</p><h5 id="向量的叉积"><a href="#向量的叉积" class="headerlink" title="向量的叉积"></a><strong>向量的叉积</strong></h5><p>结果为<script type="math/tex">|\vec{a}\times\vec{b}|=|\vec{a}||\vec{b}|sin\theta=x1*y2-x2*y1</script>。</p><p>叉积的结果也是一个向量，是垂直于向量a，b所形成的平面，如果看成三维坐标的话是在 z 轴上，上面结果是它的模。</p><p>方向判定：右手定则，（右手半握，大拇指垂直向上，四指右向量a握向b，大拇指的方向就是叉积的方向）</p><p>坐标运算：</p><p><script type="math/tex">\vec{a}=a_x,a_y,a_z</script>，<script type="math/tex">\vec{b}=b_x,b_y,b_z</script> ，i,j,k分别是X,Y,Z轴方向的单位向量，则<script type="math/tex">\vec{a}×\vec{b}=(a_yb_z-a_zb_y)\vec{i}+(a_zb_x-a_xb_z)\vec{j}+(a_xb_y-a_yb_x)\vec{k}</script>,</p><p>为了帮助记忆,利用三阶</p><p>行列式，写成</p><p>det <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D86/sign=ed67d90cabec8a13101a5ae6f6038050/37d12f2eb9389b50f5891db18735e5dde6116edb.jpg" srcset="/img/loading.gif" alt="img">。</p><p><script type="math/tex">a\times b=(l,m,n)\times (o,p,q)=(mq-np,no-lq,lp-mo)</script>。</p><p>叉积的集合意义：</p><p>1：其结果是a和b为相邻边形成平行四边形的面积。</p><p>2：结果有正有负，有sin（a，b）可知和其夹角有关，夹角大于180°为负值。</p><p>3：叉积不满足交换律</p><p>应用：</p><p>1：通过结果的正负判断两矢量之间的顺逆时针关系</p><p>若 a×b &gt; 0表示a在b的顺时针方向上</p><p>若 a×b &lt; 0表示a在b的逆时针方向上</p><p>若 a×b == 0表示a在b共线，但不确定方向是否相同</p><p>2：判断折线拐向，可转化为判断第三点在前两的形成直线的顺逆时针方向，然后判断拐向。</p><p>3：判断一个点在一条直线的哪一侧，同样上面的方法。</p><p>4：判断点是否在线段上，可利用叉乘首先判断是否共线，然后在判断是否在其上。</p><p>5：判断两条直线是否相交</p><p>​     我们分两步确定两条线段是否相交：</p><p>​      (1)快速排斥试验</p><p>​      设以线段 P1P2 为对角线的矩形为R， 设以线段 Q1Q2 为对角线的矩形为T，如果R和T不相交，显然两线段不会相交。</p><p>　  (2)跨立试验<br>　  如果两线段相交，则两线段必然相互跨立对方。若P1P2跨立Q1Q2 ，则矢量 ( P1 - Q1 ) 和( P2 - Q1 )位于矢量( Q2 - Q1 ) 的两侧，即( P1 - Q1 ) × ( Q2 - Q1 ) <em> ( P2 - Q1 ) × ( Q2 - Q1 ) &lt; 0。上式可改写成( P1 - Q1 ) × ( Q2 - Q1 ) </em> ( Q2 - Q1 ) × ( P2 - Q1 ) &gt; 0。当 ( P1 - Q1 ) × ( Q2 - Q1 ) = 0 时，说明 ( P1 - Q1 ) 和 ( Q2 - Q1 )共线，但是因为已经通过快速排斥试验，所以 P1 一定在线段 Q1Q2上；同理，( Q2 - Q1 ) ×(P2 - Q1 ) = 0 说明 P2 一定在线段 Q1Q2上。所以判断P1P2跨立Q1Q2的依据是：( P1 - Q1 ) × ( Q2 - Q1 ) <em> ( Q2 - Q1 ) × ( P2 - Q1 ) &gt;= 0。同理判断Q1Q2跨立P1P2的依据是：( Q1 - P1 ) × ( P2 - P1 ) </em> ( P2 - P1 ) × ( Q2 - P1 ) &gt;= 0。</p><p>具体情况如下图所示：</p><p>​    <img src="http://dev.gameres.com/Program/Abstract/Geometry_2.gif" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs c++"><span class="hljs-comment">//这里直线1的两个顶点是p[0],p[1];直线2的两个顶点是p[2],p[3]。</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">double</span> x,y;&#125;p[<span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a,<span class="hljs-built_in">point</span> b,<span class="hljs-built_in">point</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> a.x*b.y+b.x*c.y+c.x*a.y-a.x*c.y-b.x*a.y-c.x*b.y;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;p[i].x,&amp;p[i].y);        <span class="hljs-keyword">double</span> l0102=calc(p[<span class="hljs-number">0</span>],p[<span class="hljs-number">1</span>],p[<span class="hljs-number">2</span>]);        <span class="hljs-keyword">double</span> l0103=calc(p[<span class="hljs-number">0</span>],p[<span class="hljs-number">1</span>],p[<span class="hljs-number">3</span>]);        <span class="hljs-keyword">double</span> l2320=calc(p[<span class="hljs-number">2</span>],p[<span class="hljs-number">3</span>],p[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">double</span> l2321=calc(p[<span class="hljs-number">2</span>],p[<span class="hljs-number">3</span>],p[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span>(l0102*l0103&lt;=<span class="hljs-number">0</span>&amp;&amp;l2320*l2321&lt;=<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Yes\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="混合积"><a href="#混合积" class="headerlink" title="混合积"></a><strong>混合积</strong></h5><p>设 a ,b,c 是空间中三个向量，则 (a×b)·c称为三个向量 a ，b ，c 的混合积，记作[a b c] 或 (a,b,c) 或 (abc)。</p><p>设<script type="math/tex">\vec{a}=a_1\vec{i}+a_2\vec{j}+a_3\vec{k}</script>，<script type="math/tex">\vec{b}=b_1\vec{i}+b_2\vec{j}+b_3\vec{k}</script>，<script type="math/tex">\vec{c}=c_1\vec{i}+c_2\vec{j}+c_3\vec{k}</script>。则有</p><p><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D174/sign=cf3995104c10b912bbc1f2f9f7fcfcb5/a50f4bfbfbedab6401679f6bfc36afc379311e07.jpg" srcset="/img/loading.gif" alt="img"></p><p>应用：</p><p>四个点构成三个向量， 如果这三个向量的混合积为0，那么体积为0，那么四点共面。</p><h5 id="求任意多边形面积-有向面积"><a href="#求任意多边形面积-有向面积" class="headerlink" title="求任意多边形面积-有向面积"></a><strong>求任意多边形面积-有向面积</strong></h5><p>只要记住这个公式：</p><p><img src="http://acm.hdu.edu.cn/data/images/2528-2.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果逆时针给出点坐标，值为正，</p><p>如果顺时针给出点坐标，值为负。</p><p>当i=n-1  i+1就是n所代表的点就是第一个点。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> x,y;&#125;p[<span class="hljs-number">110</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;p[i].x,&amp;p[i].y);        p[n].x=p[<span class="hljs-number">0</span>].x;p[n].y=p[<span class="hljs-number">0</span>].y;        <span class="hljs-keyword">double</span> ans=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            ans+=<span class="hljs-number">0.5</span>*(p[i].x*p[i+<span class="hljs-number">1</span>].y-p[i+<span class="hljs-number">1</span>].x*p[i].y);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.1f\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="皮克公式"><a href="#皮克公式" class="headerlink" title="皮克公式"></a><strong>皮克公式</strong></h5><p>给定顶点坐标均是整点（或正方形格点）的简单多边形，皮克定理说明了其面积S和内部格点数目n、边上格点数目s的关系：</p><p><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D88/sign=2eff49b0b4003af349bad168342acee8/fc1f4134970a304e3d330943d3c8a786c9175c71.jpg" srcset="/img/loading.gif" alt="img"></p><p>(其中n表示多边形内部的点数,s表示多边形边界上的点数,S表示多边形的面积)</p><p>poj 1265</p><p>题意：给出机器人每一步向右走和向上走的步数，得到一个平面上的简单多边形，求边上的点，多边形内的点，多边形面积。</p><p>思路：</p><p>先求边上格点数目：已知一条直线，如(5,0)到(6,3)这条直线，经过的整点数是2，可通过如下公式计算：</p><p>格点数 = gcd(|x2-x1|,|y2-y1|)</p><p>前提，约定起点不算在该线所经过格点数中。</p><p>再利用上面求多边形面积的方法求出面积，根据皮克公式可以求出内部格点数目。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> x,y;&#125;p[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> b;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">if</span>(a&lt;b)&#123;<span class="hljs-keyword">int</span> temp;temp=a;a=b;b=temp;&#125;    <span class="hljs-keyword">while</span>(a%b)&#123;<span class="hljs-keyword">int</span> r=a%b;a=b;b=r;&#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">mianji</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> s=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        s+=<span class="hljs-number">0.5</span>*(p[i].x*p[i+<span class="hljs-number">1</span>].y-p[i+<span class="hljs-number">1</span>].x*p[i].y);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(s);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//边上的格点数</span>        p[<span class="hljs-number">0</span>].x=<span class="hljs-number">0</span>;p[<span class="hljs-number">0</span>].y=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">int</span> a,b;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;b);            num+=gcd(<span class="hljs-built_in">abs</span>(a),<span class="hljs-built_in">abs</span>(b));            p[i].x=p[i<span class="hljs-number">-1</span>].x+a;            p[i].y=p[i<span class="hljs-number">-1</span>].y+b;        &#125;        <span class="hljs-keyword">double</span> ss=mianji();        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Scenario #%d:\n%d %d %.1f\n\n"</span>,kase,(<span class="hljs-keyword">int</span>)ss-(num/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>,num,ss);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="精度"><a href="#精度" class="headerlink" title="精度"></a><strong>精度</strong></h5><p>参考博客：<a href="http://www.cnblogs.com/crazyacking/p/4668471.html" target="_blank" rel="noopener">http://www.cnblogs.com/crazyacking/p/4668471.html</a></p><p>判断浮点数相等：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eps 1e-8<span class="hljs-comment">//依题目而定</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sgn</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(x) &lt; eps)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h5 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a><strong>凸包</strong></h5><p>参考博客：<a href="https://www.cnblogs.com/aiguona/p/7232243.html" target="_blank" rel="noopener">https://www.cnblogs.com/aiguona/p/7232243.html</a></p><p>1⃣把纵坐标最小的点作为p0，如果有多个纵坐标最小的点，就选其中横坐标最小的点。</p><p>2⃣按逆时针方向相对于p0进行极角排序，如果极角相同，就把距离p0近的排在前面。</p><p>3⃣把p0,p1入栈，把p2作为当前点。</p><p>4⃣栈顶的上一个到栈顶画一根直线，如果当前点在这根直线的左边或者直线上，该点入栈，如果当前点在这根直线的右边，就让栈顶元素出栈，继续4⃣步骤。</p><p>5⃣如果不是最后一个元素，选这个入栈元素后面一个元素为当前点，继续4⃣步骤。</p><p>以hdu1392求凸包周长为例（这里注意n=1和n=2要特判（因为没有形成圈））</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">double</span> x,y;&#125;a[<span class="hljs-number">110</span>],p[<span class="hljs-number">110</span>];<span class="hljs-keyword">int</span> n,top;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cross</span><span class="hljs-params">(<span class="hljs-built_in">point</span> p0,<span class="hljs-built_in">point</span> p1,<span class="hljs-built_in">point</span> p2)</span><span class="hljs-comment">//叉乘判断在左边还是右边</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);&#125;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-built_in">point</span> a,<span class="hljs-built_in">point</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">point</span> p1,<span class="hljs-built_in">point</span> p2)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> c=cross(a[<span class="hljs-number">0</span>],p1,p2);    <span class="hljs-keyword">if</span>(c&gt;<span class="hljs-number">0</span>||(c==<span class="hljs-number">0</span>&amp;&amp;dis(a[<span class="hljs-number">0</span>],p1)&lt;dis(a[<span class="hljs-number">0</span>],p2)))        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">graham</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;<span class="hljs-comment">//最下最左的点</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-keyword">if</span>((a[i].y&lt;a[pos].y)||(a[i].y==a[pos].y&amp;&amp;a[i].x&lt;a[pos].x))            pos=i;    swap(a[pos],a[<span class="hljs-number">0</span>]);    sort(a+<span class="hljs-number">1</span>,a+n,cmp);<span class="hljs-comment">//极角排序</span>    top=<span class="hljs-number">1</span>;    p[<span class="hljs-number">0</span>]=a[<span class="hljs-number">0</span>];    p[<span class="hljs-number">1</span>]=a[<span class="hljs-number">1</span>];<span class="hljs-comment">//0,1入栈</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">while</span>(top&amp;&amp;cross(p[top<span class="hljs-number">-1</span>],p[top],a[i])&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//栈顶和栈顶的前一个连线，如果当前点在右边的话，栈顶出栈，继续</span>            top--;        top++;        p[top]=a[i];    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0.00\n"</span>);<span class="hljs-keyword">continue</span>;&#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lf%lf"</span>,&amp;a[i].x,&amp;a[i].y);        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2f\n"</span>,dis(a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>]));<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-comment">//因为不成圈所以2要特判</span>        graham();        <span class="hljs-keyword">double</span> ans=<span class="hljs-number">0</span>;        p[top+<span class="hljs-number">1</span>]=p[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=top;i++)            ans+=dis(p[i],p[i+<span class="hljs-number">1</span>]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2f\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形dp</title>
    <link href="/2018/01/28/%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2018/01/28/%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<p>最近都在做dp相关呀…</p><h5 id="hdu-1520-树的最大独立集"><a href="#hdu-1520-树的最大独立集" class="headerlink" title="hdu 1520 树的最大独立集"></a><strong>hdu 1520 树的最大独立集</strong></h5><p>题意：给出一棵树， 每个节点有权值，要求父节点和子节点不能同时取，求能够取得的最大值。</p><p>思路：把树用有向边存下来。</p><p>dp(i)(0):不选i点子树能够得到的最大价值;dp(i)(1):选i点子树能够得到的最大价值。</p><p>dp(i)(0)=sum(max(dp(k)(0),dp(k)(1)));//子节点可选可不选<br>dp(i)(1)=sum(dp(k)(0));//子节点都不选</p><p>从可能为根的节点开始dfs，先得到树叶的dp值，然后往上回溯得到根的dp值，取最大值即为答案。</p><p>完整代码：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">6010</span>];<span class="hljs-keyword">bool</span> nr[<span class="hljs-number">6010</span>];<span class="hljs-comment">//true:不是根结点</span><span class="hljs-keyword">int</span> dp[<span class="hljs-number">6010</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">//dp[i][0]:不选i点子树能够得到的最大价值</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[id][i];        dfs(temp);        dp[id][<span class="hljs-number">0</span>]+=<span class="hljs-built_in">max</span>(dp[temp][<span class="hljs-number">0</span>],dp[temp][<span class="hljs-number">1</span>]);<span class="hljs-comment">//子节点可选可不选</span>        dp[id][<span class="hljs-number">1</span>]+=dp[temp][<span class="hljs-number">0</span>];<span class="hljs-comment">//子节点都不选</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        <span class="hljs-built_in">memset</span>(nr,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(nr));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;dp[i][<span class="hljs-number">1</span>]);            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;            v[i].<span class="hljs-built_in">clear</span>();        &#125;        <span class="hljs-keyword">int</span> x,y;        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y)!=EOF)        &#123;            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>&amp;&amp;y==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;            v[y].push_back(x);            nr[x]=<span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">if</span>(!nr[i])            &#123;                dfs(i);                ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">0</span>],dp[i][<span class="hljs-number">1</span>]));            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="poj-1655-树的重心"><a href="#poj-1655-树的重心" class="headerlink" title="poj 1655 树的重心"></a><strong>poj 1655 树的重心</strong></h5><p>题意：一颗n结点无根树，选择一个结点为根，将无根树-&gt;有根树，最大子树的结点数最小，我们称该节点为质心（树的重心），求树的重心，如果有多个，按照节点编号升序输出。</p><p>思路：<img src="http://img.blog.csdn.net/20150222155128323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzAwODI5MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" srcset="/img/loading.gif" alt="img"></p><p>完整代码：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 100000000</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> top,n;<span class="hljs-keyword">int</span> head[<span class="hljs-number">20010</span>];<span class="hljs-keyword">int</span> num[<span class="hljs-number">20010</span>];<span class="hljs-comment">//每个节点的子树的节点数（包括自己）</span><span class="hljs-keyword">int</span> dp[<span class="hljs-number">20010</span>];<span class="hljs-comment">//删除节点i后最大联通块的节点数</span><span class="hljs-comment">//dp[i]=max(dp[j](j为i的子节点),n-dp[i](i上方子树))</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">20010</span>*<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    eg[top].to=b;    eg[top].next=head[a];    head[a]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//printf("%d %d\n",id,fa);</span>    <span class="hljs-keyword">int</span> mmax=<span class="hljs-number">-1</span>;<span class="hljs-comment">//id的子节点中最大的联通块</span>    num[id]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">if</span>(eg[i].to!=fa)        &#123;            dfs(eg[i].to,id);            num[id]+=num[eg[i].to];            mmax=<span class="hljs-built_in">max</span>(mmax,num[eg[i].to]);        &#125;    &#125;    dp[id]=<span class="hljs-built_in">max</span>(mmax,n-num[id]);    <span class="hljs-comment">//printf("id:%d num:%d dp:%d\n",id,num[id],dp[id]);</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;m);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));        top=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)        &#123;            <span class="hljs-keyword">int</span> x,y;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);            add(x,y);            add(y,x);        &#125;        <span class="hljs-comment">/*for(int j=1;j&lt;=n;j++)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            for(int i=head[j];i!=-1;i=eg[i].next)</span><span class="hljs-comment">                printf("%d ",eg[i].to);</span><span class="hljs-comment">            printf("\n");</span><span class="hljs-comment">        &#125;*/</span>        dfs(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//求出每个节点的子树的节点数（包括自己）</span>        <span class="hljs-keyword">int</span> pos=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">if</span>(dp[i]&lt;dp[pos])                pos=i;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,pos,dp[pos]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="poj-2631-树的直径"><a href="#poj-2631-树的直径" class="headerlink" title="poj 2631 树的直径"></a><strong>poj 2631 树的直径</strong></h5><p>题意：树上最长的简单路径即为树的直径，求树的直径。</p><p>思路：</p><p>两种方法。</p><p>1⃣两次dfs(bfs)：先任选一个起点BFS找到最长路的终点，再从终点进行BFS，则第二次BFS找到的最长路即为树的直径。</p><p>完整代码：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 100000000</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> top,pos,mmax;<span class="hljs-keyword">int</span> head[<span class="hljs-number">10010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cost;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">2</span>*<span class="hljs-number">10010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    eg[top].cost=c;    eg[top].to=b;    eg[top].next=head[a];    head[a]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> fa,<span class="hljs-keyword">int</span> v)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">if</span>(eg[i].to!=fa)        &#123;            dfs(eg[i].to,id,v+eg[i].cost);        &#125;    &#125;    <span class="hljs-keyword">if</span>(v&gt;mmax)    &#123;        mmax=v;        pos=id;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x,y,z;    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z)!=EOF)    &#123;        add(x,y,z);        add(y,x,z);    &#125;    mmax=<span class="hljs-number">-1</span>;    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//任选一个点，找离它最远的点</span>    mmax=<span class="hljs-number">-1</span>;    dfs(pos,pos,<span class="hljs-number">0</span>);<span class="hljs-comment">//从上面最远的点开始找离这个点最远的点</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,mmax);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>2⃣dp：对于任意一个点，搜索其两个能延伸最远和次远的儿子，把两个距离相加再加上两儿子到父亲的距离再取最大就是树的直径，<u>而且两儿子不能在一条延伸路径上</u>。f(i)(0),f(i)(1)分别记录以顶端端点为i的最长链和次长链长度，当子结点的最长边（次短边没有影响，因为对于i来说的两条路不能在一条延伸路径上）加上到父结点的距离大于父结点的最长边时，更新父结点的最长边和次长边。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 100000000</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> top;<span class="hljs-keyword">int</span> head[<span class="hljs-number">10010</span>];<span class="hljs-keyword">int</span> dp[<span class="hljs-number">10010</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">//顶端为i的最长链和次长链的长度</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cost;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">2</span>*<span class="hljs-number">10010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    eg[top].cost=c;    eg[top].to=b;    eg[top].next=head[a];    head[a]=top++;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)    &#123;        <span class="hljs-keyword">if</span>(eg[i].to!=fa)        &#123;            dfs(eg[i].to,id);            <span class="hljs-keyword">if</span>(dp[eg[i].to][<span class="hljs-number">0</span>]+eg[i].cost&gt;dp[id][<span class="hljs-number">0</span>])            &#123;                dp[id][<span class="hljs-number">1</span>]=dp[id][<span class="hljs-number">0</span>];                dp[id][<span class="hljs-number">0</span>]=dp[eg[i].to][<span class="hljs-number">0</span>]+eg[i].cost;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[eg[i].to][<span class="hljs-number">0</span>]+eg[i].cost&gt;dp[id][<span class="hljs-number">1</span>])                dp[id][<span class="hljs-number">1</span>]=dp[eg[i].to][<span class="hljs-number">0</span>]+eg[i].cost;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x,y,z;    top=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z)!=EOF)    &#123;        <span class="hljs-comment">//if(x==0&amp;&amp;y==0&amp;&amp;z==0)break;</span>        add(x,y,z);        add(y,x,z);    &#125;    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//任选一个点，找离它最远的点和次远的点</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>骨牌覆盖</title>
    <link href="/2018/01/27/%E9%AA%A8%E7%89%8C%E8%A6%86%E7%9B%96/"/>
    <url>/2018/01/27/%E9%AA%A8%E7%89%8C%E8%A6%86%E7%9B%96/</url>
    
    <content type="html"><![CDATA[<h5 id="hihocoder-1048"><a href="#hihocoder-1048" class="headerlink" title="hihocoder 1048"></a><strong>hihocoder 1048</strong></h5><p>题意：在一个N×M的格子里，现在有两种类型的砖块，1×2和2×1，问一共有多少种方案，可以将整个N×M的空间都填满。2&lt;=N&lt;=1000, 3&lt;=m&lt;=5。</p><p>思路：参考博客：<a href="http://blog.csdn.net/lu597203933/article/details/44137277" target="_blank" rel="noopener">http://blog.csdn.net/lu597203933/article/details/44137277</a></p><p>（事实上考虑的时候顺序是这样的1⃣️👉4⃣️👉3⃣️👉2⃣️）</p><p>1⃣️确定0表示什么，1表示什么。</p><p>在位置(i, j)如果我们选择横着贴砖，那么将(i, j),(i, j+1)都填写成1，如果竖着贴砖，我们将(i,j)填写成0，将(i+1, j)填写成1。</p><p>为什么这样表示呢？</p><p>首先确定有几种情况：</p><p>假如现在我们在铺砖位置(i, j), 并且假设之前的位置已经铺设好的了，在这个位置，我们的选择：</p><p>1.不用铺了，(i-1,j)竖着铺好了，那就继续看(i,j+1)；</p><p>2.横着铺，(i,j)和(i,j+1)都铺上；</p><p>3.竖着铺，(i,j)和(i+1,j)都铺上；</p><p>那么为什么竖着铺的时候(i,j)填写成0，(i+1, j)填写成1呢？</p><p>假设反过来，会造成什么结果呢？</p><p>如果某一位是0，那么你就看上一块是不是1即可；如果某一位是1，要检查右边那块是不是1，如果不是1，说明是竖着放的，向右继续检查，如果是1，说明可能是横着放的也有可能是竖着放的，假设是横着放的，那要判断右边那块的上面一块是不是1，但是这里就出现矛盾了，这里的1，到底是指竖着放的的一块呢还是指横着放的某一块呢？</p><p>所以要把(i,j)填写成0，(i+1, j)填写成1。</p><p>还有另一种解释：横着放设为1表示对下一行没有任何影响了，竖着放的第一块，对下面是有影响的，所以为0，第二块则是没有影响的，为1。</p><p>这样选择还有一个好处：在处理最后一行的时候，可以保证最后一行都是1， 因为最后一行绝对不能成为竖砖开始，所以很容易取得最后的解。</p><p>2⃣️确定第一行的合法状态。</p><p>枚举所有状态，对于每个状态的每一列进行判断。</p><p>如果某一位是0，就继续向右检查；</p><p>如果某一位是1，这时是不可能作为竖着放的第二块的，只可能是横着放的，那么就检查右边那块是不是1，这里注意不要越界，如果是1，就j- -，否则就不合法。（这里的判断的(i,x)一定不是由(i,x-1)位横着铺砖过来的，否则直接x=x+2,就不会来判断(i,x)位了）</p><p>注意⚠️：判断某一位是0还是1时，要注意如果是1的话结果应该是&gt;0而不是1本身，因为这一位是有权值的。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;m);i++)    &#123;        <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>&amp;&amp;sign==<span class="hljs-number">0</span>;j--)        &#123;            <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;j)&amp;i)&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//该位是1,则后一块也得是1,第一行的1只能是横着放的</span>            &#123;                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)sign++;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))&amp;i)==<span class="hljs-number">0</span>)sign++;                <span class="hljs-keyword">else</span> j--;            &#125;        &#125;        <span class="hljs-keyword">if</span>(sign==<span class="hljs-number">0</span>)dp[<span class="hljs-number">1</span>][i]=<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>3⃣️动态规划。</p><p>dp(i)(j):推到第i行状态为j时的方法数。</p><p>dp(i)(j)=sum{dp(i-1)(k),0&lt;=k&lt;(1&lt;&lt;m)&amp;&amp;k和j是可以兼容的}</p><p>判断是否兼容：</p><p>如果某一位是0，那么上一块只能是1；</p><p>如果某一位是1，那么就分两种情况：</p><p>上一块是0，那么继续向右检测；</p><p>上一块是1，那么就说明这里是横着铺的，右边一块也一定是1，<u>右边一块的上一块一定是1</u>，因为右边一块已经确定状态是横着铺了，如果都满足的话，就j- -，否则就说明不兼容。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span><span class="hljs-comment">//x:这一行的状态，y:上一行的状态</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;i)&amp;x)==<span class="hljs-number">0</span>)<span class="hljs-comment">//该位是0，则上一块只能是1</span>        &#123;            <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;i)&amp;y)==<span class="hljs-number">0</span>)                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">else</span><span class="hljs-comment">//该位是1</span>        &#123;            <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;i)&amp;y)&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//如果上一块是0,就继续检测；如果上一块是1,(i,x+1)也一定是1，****并且(i-1,x+1)一定是1!!!(注意！！！）</span>            &#123;                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))&amp;x)&gt;<span class="hljs-number">0</span>&amp;&amp;((<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))&amp;y)&gt;<span class="hljs-number">0</span>)                    i--;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<span class="hljs-comment">//每一行</span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;m);j++)<span class="hljs-comment">//这一行的状态</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;m);k++)<span class="hljs-comment">//上一行的状态</span>        &#123;            <span class="hljs-keyword">if</span>(judge(j,k))                dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][k])%MOD;        &#125;    &#125;&#125;</code></pre><p>4⃣️dp(n)((1&lt;&lt;m)-1)即为总方法数。</p><p>因为最后一行只能都为1。</p><p>完整代码：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dp[<span class="hljs-number">1100</span>][(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>)+<span class="hljs-number">10</span>];<span class="hljs-comment">//在第i行状态为j时的方法数</span><span class="hljs-comment">//竖放的第一块是0，第二块是1</span><span class="hljs-keyword">int</span> m;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;m);i++)    &#123;        <span class="hljs-comment">//printf("i=%d:",i);</span>        <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;        <span class="hljs-comment">/*for(int j=m-1;j&gt;=0;j--)</span><span class="hljs-comment">            printf("%d",((1&lt;&lt;j)&amp;i));*/</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>&amp;&amp;sign==<span class="hljs-number">0</span>;j--)        &#123;            <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;j)&amp;i)&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//该位是1,则后一块也得是1,第一行的1只能是横着放的</span>                <span class="hljs-comment">//这里是&gt;0,注意！！！不一定是1呀！！！</span>            &#123;                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)sign++;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))&amp;i)==<span class="hljs-number">0</span>)sign++;                <span class="hljs-keyword">else</span> j--;            &#125;        &#125;        <span class="hljs-keyword">if</span>(sign==<span class="hljs-number">0</span>)dp[<span class="hljs-number">1</span>][i]=<span class="hljs-number">1</span>;        <span class="hljs-comment">//printf(" %lld\n",dp[1][i]);</span>    &#125;    <span class="hljs-comment">//printf("\n");</span>&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span><span class="hljs-comment">//x:这一行的状态，y:上一行的状态</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;i)&amp;x)==<span class="hljs-number">0</span>)<span class="hljs-comment">//该位是0，则上一块只能是1</span>        &#123;            <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;i)&amp;y)==<span class="hljs-number">0</span>)                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">else</span><span class="hljs-comment">//该位是1</span>        &#123;            <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;i)&amp;y)&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//如果上一块是0,就继续检测；如果上一块是1,(i,x+1)也一定是1，****并且(i-1,x+1)一定是1!!!(注意！！！）</span>            &#123;                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(((<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))&amp;x)&gt;<span class="hljs-number">0</span>&amp;&amp;((<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))&amp;y)&gt;<span class="hljs-number">0</span>)                    i--;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;<span class="hljs-comment">//m比较小</span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));    test1();<span class="hljs-comment">//处理出第一行合法的情况</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<span class="hljs-comment">//每一行</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;m);j++)<span class="hljs-comment">//这一行的状态</span>        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;m);k++)<span class="hljs-comment">//上一行的状态</span>            &#123;                <span class="hljs-keyword">if</span>(judge(j,k))                    dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][k])%MOD;            &#125;            <span class="hljs-comment">//printf("dp[%d][%d]:%lld\n",i,j,dp[i][j]);</span>        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,dp[n][(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>]);<span class="hljs-comment">//最后一行是不可能出现0的</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>这里用枚举+判断会有些慢…</p><p>所以可以直接生成合法的方案。</p><p>1⃣️0和1的表示如上一个方法。</p><p>2⃣️对于每一个位置，有三种放置方法。</p><p>不放（下放）：这时这个块为0，则上一块只能是1。</p><p>上放：这时这个块为1，则上一块只能是0。</p><p>横放：这时这个块为1，右边的块也为1，那么上面那块为1，右边的上面那块也为1。</p><p>然后从0开始构造即可。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> num;<span class="hljs-comment">//兼容的方案数</span><span class="hljs-keyword">int</span> ok[<span class="hljs-number">50010</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">//ok[][0]:上一行的状态；ok[][1]：下一行的状态</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> pre,<span class="hljs-keyword">int</span> now)</span><span class="hljs-comment">//构造出所有兼容模式:c（列数），pre（上一行的状态），pre（该行的状态）</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(c&gt;m)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//防止横放越界的情况</span>    <span class="hljs-keyword">if</span>(c==m)    &#123;        ok[num][<span class="hljs-number">0</span>]=pre;        ok[num++][<span class="hljs-number">1</span>]=now;        <span class="hljs-keyword">return</span>;    &#125;    dfs(c+<span class="hljs-number">1</span>,(pre&lt;&lt;<span class="hljs-number">1</span>)|<span class="hljs-number">1</span>,now&lt;&lt;<span class="hljs-number">1</span>);<span class="hljs-comment">//不放（即下放），为0，则上行为1</span>    dfs(c+<span class="hljs-number">1</span>,pre&lt;&lt;<span class="hljs-number">1</span>,(now&lt;&lt;<span class="hljs-number">1</span>)|<span class="hljs-number">1</span>);<span class="hljs-comment">//上放，为1，则上行为0</span>    dfs(c+<span class="hljs-number">2</span>,(pre&lt;&lt;<span class="hljs-number">2</span>)|<span class="hljs-number">3</span>,(now&lt;&lt;<span class="hljs-number">2</span>)|<span class="hljs-number">3</span>);<span class="hljs-comment">//横放，为1，右边为1，上边为1，上边的右边为1</span>&#125;</code></pre><p>3⃣️动态规划。</p><pre><code class="hljs c++"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dp[<span class="hljs-number">15</span>][<span class="hljs-number">50010</span>];<span class="hljs-comment">//推到第i行兼容方式为j时方法数</span><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));dp[<span class="hljs-number">0</span>][(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//第一行不能上放，所以第0行不能有空的，只能为1</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;num;j++)    &#123;        dp[i][ok[j][<span class="hljs-number">1</span>]]+=dp[i<span class="hljs-number">-1</span>][ok[j][<span class="hljs-number">0</span>]];    &#125;&#125;</code></pre><p>因为第一行不能上放，所以第0行不能有0，只能都是1。</p><p>dp(i)(j):推到第i行状态为j时的方法数。</p><p>dp(i)(j)=sum{dp(i-1)(k),0&lt;=k&lt;(1&lt;&lt;m)&amp;&amp;k和j是可以兼容的}。</p><p>4⃣️dp(n)((1&lt;&lt;m)-1)即为答案。</p><p>完整代码：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> m;<span class="hljs-keyword">int</span> num;<span class="hljs-comment">//兼容的方案数</span><span class="hljs-keyword">int</span> ok[<span class="hljs-number">50010</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">//ok[][0]:上一行的状态；ok[][1]：下一行的状态</span><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dp[<span class="hljs-number">15</span>][<span class="hljs-number">50010</span>];<span class="hljs-comment">//推到第i行兼容方式为j时方法数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> pre,<span class="hljs-keyword">int</span> now)</span><span class="hljs-comment">//构造出所有兼容模式:c（列数），pre（上一行的状态），pre（该行的状态）</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(c&gt;m)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//防止横放越界的情况</span>    <span class="hljs-keyword">if</span>(c==m)    &#123;        ok[num][<span class="hljs-number">0</span>]=pre;        ok[num++][<span class="hljs-number">1</span>]=now;        <span class="hljs-keyword">return</span>;    &#125;    dfs(c+<span class="hljs-number">1</span>,(pre&lt;&lt;<span class="hljs-number">1</span>)|<span class="hljs-number">1</span>,now&lt;&lt;<span class="hljs-number">1</span>);<span class="hljs-comment">//不放（即下放），为0，则上行为1</span>    dfs(c+<span class="hljs-number">1</span>,pre&lt;&lt;<span class="hljs-number">1</span>,(now&lt;&lt;<span class="hljs-number">1</span>)|<span class="hljs-number">1</span>);<span class="hljs-comment">//上放，为1，则上行为0</span>    dfs(c+<span class="hljs-number">2</span>,(pre&lt;&lt;<span class="hljs-number">2</span>)|<span class="hljs-number">3</span>,(now&lt;&lt;<span class="hljs-number">2</span>)|<span class="hljs-number">3</span>);<span class="hljs-comment">//横放，为1，右边为1，上边为1，上边的右边为1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>&amp;&amp;m==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        num=<span class="hljs-number">0</span>;        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        <span class="hljs-comment">//printf("%d\n",num);</span>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));        dp[<span class="hljs-number">0</span>][(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//第一行不能上放，所以第0行不能有空的，只能为1</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;num;j++)            &#123;                dp[i][ok[j][<span class="hljs-number">1</span>]]+=dp[i<span class="hljs-number">-1</span>][ok[j][<span class="hljs-number">0</span>]];            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,dp[n][(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>当n很大的时候，就不能用上述的方法算了，这个时候矩阵的优势就体现出来了。</p><h5 id="51nod-1033"><a href="#51nod-1033" class="headerlink" title="51nod 1033"></a><strong>51nod 1033</strong></h5><p>题意：2 &lt;= m &lt;= 10^9，2 &lt;= n &lt;= 5</p><p>思路：题目转化为求经过n次转化，从初始态到终态有几种转化法。</p><p>建立矩阵的方法：矩阵的大小为(1&lt;&lt;m-1) ，如果pre状态能到达状态now，那么mat(pre)(now)=1，然后求此矩阵的n次幂即可。</p><p>输出的是ans((1&lt;&lt;m)-1)((1&lt;&lt;m)-1)，因为第0行都为1，最后一行也都为1。</p><p>完整代码：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> m;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">40</span>][<span class="hljs-number">40</span>];&#125;mt,r;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> pre,<span class="hljs-keyword">int</span> now)</span><span class="hljs-comment">//构造出所有兼容模式:c（列数），pre（上一行的状态），pre（该行的状态）</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(c&gt;m)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//防止横放越界的情况</span>    <span class="hljs-keyword">if</span>(c==m)    &#123;        mt.a[pre][now]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span>;    &#125;    dfs(c+<span class="hljs-number">1</span>,(pre&lt;&lt;<span class="hljs-number">1</span>)|<span class="hljs-number">1</span>,now&lt;&lt;<span class="hljs-number">1</span>);<span class="hljs-comment">//不放（即下放），为0，则上行为1</span>    dfs(c+<span class="hljs-number">1</span>,pre&lt;&lt;<span class="hljs-number">1</span>,(now&lt;&lt;<span class="hljs-number">1</span>)|<span class="hljs-number">1</span>);<span class="hljs-comment">//上放，为1，则上行为0</span>    dfs(c+<span class="hljs-number">2</span>,(pre&lt;&lt;<span class="hljs-number">2</span>)|<span class="hljs-number">3</span>,(now&lt;&lt;<span class="hljs-number">2</span>)|<span class="hljs-number">3</span>);<span class="hljs-comment">//横放，为1，右边为1，上边为1，上边的右边为1</span>&#125;<span class="hljs-function">mat <span class="hljs-title">mult</span><span class="hljs-params">(mat x,mat y)</span></span><span class="hljs-function"></span>&#123;    mat res=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;m);i++)        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;m);j++)            <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;m);k++)                res.a[i][j]=(res.a[i][j]+(x.a[i][k]*y.a[k][j])%MOD)%MOD;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">mat <span class="hljs-title">PowerMod</span><span class="hljs-params">(mat x,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span></span><span class="hljs-function"></span>&#123;    mat ans=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;m);i++)        ans.a[i][i]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)            ans=mult(ans,x);        x=mult(x,x);        n=n/<span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%d"</span>,&amp;n,&amp;m);    <span class="hljs-built_in">memset</span>(mt.a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(mt.a));    dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    r=PowerMod(mt,n);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,r.a[(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>][(<span class="hljs-number">1</span>&lt;&lt;m)<span class="hljs-number">-1</span>]);<span class="hljs-comment">//第0行只能全是1</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>终于搭建了我的博客啦www</title>
    <link href="/2018/01/26/%E7%BB%88%E4%BA%8E%E6%90%AD%E5%BB%BA%E4%BA%86%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%95%A6www/"/>
    <url>/2018/01/26/%E7%BB%88%E4%BA%8E%E6%90%AD%E5%BB%BA%E4%BA%86%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%95%A6www/</url>
    
    <content type="html"><![CDATA[<p>经过两天断断续续的搭建以及搬运…终于把之前的博文从lofter搬运到这里啦www</p><p>虽说这里写博文好像有点麻烦 但是比lofter在格式上面好了很多呀 再也不用担心复制代码会出现莫名其妙的空行啦（而且更好看？（这个模板real好看呀</p><p>有了博客就更有动力刷题啦（？</p><p>不立太多flag总之加油啦www</p>]]></content>
    
    
    
    <tags>
      
      <tag>随感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心题</title>
    <link href="/2018/01/26/%E8%B4%AA%E5%BF%83%E9%A2%98/"/>
    <url>/2018/01/26/%E8%B4%AA%E5%BF%83%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="区间选点问题-P233"><a href="#区间选点问题-P233" class="headerlink" title="区间选点问题(P233)"></a><strong>区间选点问题(P233)</strong></h5><p>-方法：</p><p>把所有区间按b从小到大排序（b相同时a从大到小排序），则如果出现区间包含的情况，小区间一定排在前面。第一个区间应该取最后一个点。</p><p>-练习(POJ1328)：</p><p>更自然的方法：</p><p>每个岛屿都有这样的最左和最右可被侦测坐标。<br>根据贪婪的思想，每次都应该将最右可被侦测坐标作为衡量标准。<br>假定当前的岛屿为cur，当前的下一个为next。<br>1.如果next的最左可被侦测坐标比cur的最右都大的话，只能再设一个雷达来侦测next了。 </p><p>2.如果next的最左可被侦测坐标比cur的最右小，这时会有两种情况。<br>   A.next最右 &lt; cur最右<br>   B.next最右 &gt;= cur最右<br>   对于B情况,我们可以直接侦测到next了, 可以找next的next了.<br>   对于A情况,也就等价于next包含于cur, 这样就应该把next的右最为衡量标准了.<br>   因为这样可以左移最右坐标, 可以让可能更多的岛屿被侦测到(他们的最左与衡量标准有更多的交集)</p><p>-教训：</p><p>注意中间变量t是double啊啊啊啊啊…</p><h5 id="贪心-POJ2109"><a href="#贪心-POJ2109" class="headerlink" title="贪心(POJ2109)"></a><strong>贪心(POJ2109)</strong></h5><p><strong>方法一（用double）</strong>：</p><p>k=pow(p,1/n);</p><p>类型          长度 (bit)           有效数字          绝对值范围<br>float                32                      6~7                  10^(-37) ~ 10^38<br>double            64                     15~16               10^(-307) ~10^308<br>long double   128                   18~19               10^(-4931) ~ 10 ^ 4932</p><p>首先需要明确：double类型虽然能表示10^(-307)   ~   10^308, （远大于题意的1&lt;=p&lt;10101这个范围）,但只能精确前16位，因此必须慎用！</p><p><strong>方法二（高精度运算+二分查找+快速幂）</strong>：</p><p><strong>方法三（贪心法）</strong>：黑人问号？？？</p><p>贪心(POJ2586)</p><p><strong>方法一（枚举）：</strong></p><p>根据前五个月的情况分五种情况。<em>**</em></p><p><strong>方法二（贪心）：</strong></p><p>先将每个月都当成盈利，从1月开始，算5个月的总和，假如是盈利，把最后一个月设成亏损（最后一个月取到的次数最多），再算5个月总和，要是还是盈利，继续依次设置下去。要注意的是，假如一个月盈利大于4个月亏损总和，就只能全亏了。</p><h5 id="线段的重叠（51nod-1091）"><a href="#线段的重叠（51nod-1091）" class="headerlink" title="线段的重叠（51nod 1091）"></a><strong>线段的重叠（51nod 1091）</strong></h5><p>先排序，起点升序，终点降序，因为贪心。然后用两重循环，把每一条线段当成基准，然后对之后的每一条线段根据完全重叠和重叠部分进行讨论，线扫一遍。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> s;    <span class="hljs-keyword">int</span> e;&#125;d[<span class="hljs-number">50010</span>],temp;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(st x,st y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x.s!=y.s)<span class="hljs-keyword">return</span> x.s&lt;y.s;    <span class="hljs-keyword">return</span> x.e&gt;y.e;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,MAX,l,i,j,sign;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;d[i].s,&amp;d[i].e);    sort(d,d+n,cmp);    MAX=<span class="hljs-number">0</span>;sign=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        temp.s=d[i].s;temp.e=d[i].e;        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;n;j++)        &#123;            <span class="hljs-keyword">if</span>(d[j].s&lt;=temp.e)            &#123;                <span class="hljs-keyword">if</span>(d[j].e&gt;=temp.e)                &#123;                    l=temp.e-d[j].s;                    MAX=<span class="hljs-built_in">max</span>(MAX,l);                    sign++;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    l=d[j].e-d[j].s;                    MAX=<span class="hljs-built_in">max</span>(MAX,l);                    sign++;                &#125;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(sign==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,MAX);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDOJ 2057 十六进制相加</title>
    <link href="/2018/01/26/HDOJ-2057-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%8A%A0/"/>
    <url>/2018/01/26/HDOJ-2057-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>用long long:</strong></p><p><strong>注意：十六进制输入十六进制输出就ok。</strong><br><strong>题目告知A长度不会超过15位，A**</strong>最大为fffffffffffffff，转换成10进制为  1152921504606847046，long long<strong>**范围是-2^63~+2^63-1</strong>, +<strong>MAX:  9223372036854775807，所以long long足够了。需要注意的是如果用long long，输入和输入时都需要写成 %llX ，%x和%X分别对应十六进制中字母小写和字母大写，需要对结果&lt;0时做一些处理，这样就AC</strong>了~</p><p>用__int64：</p><p>%I64X（%X是无符号的，不能输出负值，所以sum如果是负的，要转为正的）</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数位dp</title>
    <link href="/2018/01/26/%E6%95%B0%E4%BD%8Ddp-0/"/>
    <url>/2018/01/26/%E6%95%B0%E4%BD%8Ddp-0/</url>
    
    <content type="html"><![CDATA[<p>之前暑假的时候找过模板来着…好像当时不是很懂那个模板…以至于之后就忘了要怎么写了…现在换了一种数位dp的写法…还是这种写法好懂呀…</p><p><a href="https://www.cnblogs.com/wenruo/p/4725005.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenruo/p/4725005.html</a></p><p>以不要62这道题为例：</p><p>1⃣️预处理出来dp(i)(j)：i位j为首数字的数字里有多少上牌号<br>如j=4时：dp(i)(j)=0<br>j!=4时：</p><p><img src="http://latex.codecogs.com/gif.latex?dp%5Bi%5D%5Bj%5D%3D%5Csum_%7Bk%3D0%7D%5E%7B9%7Ddp%5Bi-1%5D%5Bk%5D%2C%20%28k%21%3D2%7C%7Cj%21%3D6%29" srcset="/img/loading.gif" alt="img"></p><p>2⃣️分离数位</p><p>比如52431,ans=sum{dp(5)(k),0&lt;=k&lt;=4}+sum{dp(4)(k),0&lt;=k&lt;=1}，到第三位4的时候，由于不能有4，所以就可以break，相当于处理完4的时候，前三位要固定好，打算处理3的时候就是52400～52420了，这些都是不符合条件的。<br>因为for(int j=0;j&lt;d[i];j++)，所以这里处理出来的是[0,n)中符合要求的个数。</p><p>完整代码：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span>usingnamespacestd;<span class="hljs-keyword">int</span> dp[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<span class="hljs-comment">//i位j为首数字的数字里有多少上牌号</span><span class="hljs-keyword">int</span> d[<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dp));    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">7</span>;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">9</span>;j++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">9</span>;k++)                <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">4</span>&amp;&amp;!(j==<span class="hljs-number">6</span>&amp;&amp;k==<span class="hljs-number">2</span>))                    dp[i][j]+=dp[i<span class="hljs-number">-1</span>][k];            <span class="hljs-comment">//printf("dp[%d][%d]:%d\n",i,j,dp[i][j]);</span>        &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//处理出[0,n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(n)    &#123;        d[++len]=n%<span class="hljs-number">10</span>;        n=n/<span class="hljs-number">10</span>;    &#125;    d[len+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//处理n=0的情况</span>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len;i&gt;=<span class="hljs-number">1</span>;i--)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;d[i];j++)            <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">4</span>&amp;&amp;!(j==<span class="hljs-number">2</span>&amp;&amp;d[i+<span class="hljs-number">1</span>]==<span class="hljs-number">6</span>))            &#123;                ans+=dp[i][j];            &#125;        <span class="hljs-keyword">if</span>(d[i]==<span class="hljs-number">4</span>||(d[i]==<span class="hljs-number">2</span>&amp;&amp;d[i+<span class="hljs-number">1</span>]==<span class="hljs-number">6</span>))<span class="hljs-keyword">break</span>;        <span class="hljs-comment">//这里不是d[i]==6&amp;&amp;d[i-1]==2的原因是：比如1621，难道处理到6之后，1600 1610里面就没有号牌了吗，所以要到最后一位。</span>        <span class="hljs-comment">//1000 1100 1200 1300 1400 1500 1600 1610</span>    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    init();    <span class="hljs-keyword">int</span> l,r;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(l==<span class="hljs-number">0</span>&amp;&amp;r==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,solve(r+<span class="hljs-number">1</span>)-solve(l));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>joyoi treat dp（或者记忆化搜索）</title>
    <link href="/2018/01/26/joyoi-treat-dp%EF%BC%88%E6%88%96%E8%80%85%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%89/"/>
    <url>/2018/01/26/joyoi-treat-dp%EF%BC%88%E6%88%96%E8%80%85%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>题意：</p><p>给出长度为N的数列{A_i}，每次可以从最左边或者最右边取走一个数，第i次取数得到的价值是i * A_j。求价值之和最大的取数方案。</p><p>思路：</p><p>记忆化搜索：</p><pre><code class="hljs markdown">用 DP[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]表示a数组取i到j的最大价值。</code></pre><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">2010</span>];<span class="hljs-keyword">int</span> dp[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> t)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l&gt;r)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(dp[l][r])returndp[l][r];    <span class="hljs-keyword">int</span> temp=<span class="hljs-number">0</span>;    temp=<span class="hljs-built_in">max</span>(temp,dfs(l+<span class="hljs-number">1</span>,r,t+<span class="hljs-number">1</span>)+t*a[l]);    temp=<span class="hljs-built_in">max</span>(temp,dfs(l,r<span class="hljs-number">-1</span>,t+<span class="hljs-number">1</span>)+t*a[l]);    returndp[l][r]=temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dfs(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><pre><code class="hljs markdown">dp：用 DP[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>] 表示 a 数组左边取 i 个数右边取 j 个数所能取得的最大价值，则可得状态转移方程 DP[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]=max&#123;DP[<span class="hljs-string">i−1</span>][<span class="hljs-symbol">j</span>]+a[<span class="hljs-string">i</span>]×(i+j),DP[<span class="hljs-string">i</span>][<span class="hljs-symbol">j−1</span>]+a[n−j+1]×(i+j)&#125;。最后结果为 max&#123;i+j=n|DP[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]&#125;.</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1257 01分数规划</title>
    <link href="/2018/01/26/51nod-1257-01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"/>
    <url>/2018/01/26/51nod-1257-01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>题意：</p><p>N个物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数），从中选出K件物品（K &lt;= N)，使得单位体积的价值最大。</p><p>思路：</p><p>要使sump/sumw&lt;=x，即使sump-x*sumw&lt;=0，可以二分使该式值为0找解。</p><p>代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n,k;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sump,sumw;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dx</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> w,p;    <span class="hljs-keyword">double</span> bz;&#125;a[<span class="hljs-number">50010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(dx x,dx y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x.bz&gt;y.bz;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        a[i].bz=a[i].p-x*a[i].w;    sort(a,a+n,cmp);    sump=sumw=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)    &#123;        sump+=a[i].p;        sumw+=a[i].w;    &#125;    <span class="hljs-keyword">if</span>(sump-x*sumw&gt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//往大了找</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ansp,answ;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;a[i].w,&amp;a[i].p);    <span class="hljs-keyword">double</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">50010</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)    &#123;        <span class="hljs-keyword">double</span> m=(l+r)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(judge(m))        &#123;            ansp=sump;            answ=sumw;            l=m;        &#125;        <span class="hljs-keyword">else</span> r=m;    &#125;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> gdd=__gcd(ansp,answ);    ansp/=gdd;    answ/=gdd;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld/%lld\n"</span>,ansp,answ);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces869C 组合数学（或者DP）</title>
    <link href="/2018/01/26/CodeForces869C-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%88%E6%88%96%E8%80%85DP%EF%BC%89/"/>
    <url>/2018/01/26/CodeForces869C-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%88%E6%88%96%E8%80%85DP%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>题意:</p><p>有三种岛屿，数量分别为a,b,c；任意两个岛屿可以最多建一座桥（桥长度为1），问你有几种建桥方式；</p><p>同种岛屿要么无法达到，要么距离至少为3；</p><p>组合数学思路：</p><p>限制条件可以理解为：1.同种岛屿之间不能有桥；2.同种岛屿不能同时连着同一个岛屿；</p><p>因为条件1，所以建桥可以分三步，a与b的建桥情况，b与c的建桥情况，a与c的建桥情况，即每种岛屿的每个岛屿与另一种的每个岛屿之间有没有桥。</p><p>因为条件2，<strong>每种岛屿的每个岛屿最多只能和另一种的岛屿建一座桥</strong>。</p><p>对于第一步，min(a,b)+1种情况，即分别有0，1，2，。。。，min（a+b）座桥时的情况，对每个情况k，方式数有，从a中选k个岛屿<em>从b中选k个岛屿（即C(a,k) </em> C(b,k)*k!）。</p><p>根据分类相加，分布相乘的计数原理，可以求出答案。（Cn,m可以用递推预处理，An,m等于Cn,m*m!，m!也可以预处理）</p><p>DP思路：</p><p>直接拿dp[i][j] 代表有i个红颜色小岛，j个蓝颜色小岛的情况下有多少种。</p><p>新增的小岛有两种情况：</p><p>1.不和其他小岛相连</p><p>2.和另一种颜色的某个小岛相连</p><pre><code class="hljs markdown">dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]=(dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">j</span>]+(dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">j-1</span>]*j%mod))%mod;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2018/01/26/%E4%BA%8C%E5%88%86%E4%B8%93%E9%A2%98/"/>
    <url>/2018/01/26/%E4%BA%8C%E5%88%86%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>常用思想：枚举一个值，使得剩下的值具有单调性，然后进行二分。</p><h4 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h4><p>参考博客：<a href="https://www.cnblogs.com/fenghaoran/p/6391052.html" target="_blank" rel="noopener">https://www.cnblogs.com/fenghaoran/p/6391052.html</a></p><p>为什么可以二分答案呢？</p><p>如果要求满足条件的最大值，如果我们check了10000，发现它是满足解的，那么答案肯定不小于10000。如果我们又check了20000，发现它是满足解的，那么10000-20000内的数我们都不用枚举。又或者20000是不满足解的，那么答案就在10000-20000的左闭右开区间内。这个时候我们如果”恰当地“check 15000，答案的范围会进一步缩小。</p><p><strong>碰到最小/最大有可能是二分答案哦。</strong></p><h5 id="求满足条件的最大值"><a href="#求满足条件的最大值" class="headerlink" title="求满足条件的最大值"></a>求满足条件的最大值</h5><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=maxn,ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(l&lt;=r)&#123;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(judge(mid))ans=mid,l=mid+<span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;&#125;</code></pre><h5 id="求满足条件的最小值"><a href="#求满足条件的最小值" class="headerlink" title="求满足条件的最小值"></a>求满足条件的最小值</h5><pre><code class="hljs c++"><span class="hljs-keyword">int</span> l=<span class="hljs-number">1</span>,r=maxn,ans=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(l&lt;=r)&#123;    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(judge(mid))ans=mid,r=mid<span class="hljs-number">-1</span>;    <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1088 最长回文子串</title>
    <link href="/2018/01/26/51nod-1088-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2018/01/26/51nod-1088-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>1.暴力法：求出所有子串…</p><p>2.动态规划法：</p><p>定义二维数组P[i,j]用以表示Si…Sj是回文（true）或不是回文（false）</p><p>那么可知P[i,j] = (P[i + 1, j - 1] &amp;&amp; Si ==Sj)</p><p>初始条件是：P[i, i]=true，P[i, i + 1] = (Si == Si+1)</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> dp[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j,<span class="hljs-built_in">max</span>=<span class="hljs-number">1</span>,len;    <span class="hljs-keyword">char</span> a[<span class="hljs-number">1010</span>];    gets(a);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(a);i++)    dp[i][i]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(a)<span class="hljs-number">-1</span>;i++)    <span class="hljs-keyword">if</span>(a[i]==a[i+<span class="hljs-number">1</span>])    &#123;        dp[i][i+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;        <span class="hljs-built_in">max</span>=<span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">for</span>(len=<span class="hljs-number">3</span>;len&lt;=<span class="hljs-built_in">strlen</span>(a);len++)    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(a)-len+<span class="hljs-number">1</span>;i++)    &#123;        j=i+len<span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span>(dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>&amp;&amp;a[i]==a[j])        &#123;            dp[i][j]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(j-i+<span class="hljs-number">1</span>&gt;<span class="hljs-built_in">max</span>)<span class="hljs-built_in">max</span>=j-i+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span> dp[i][j]=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,<span class="hljs-built_in">max</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>3.中心扩展法：回文的特点，就是中心对称。对于有N个字符的字符串S，只有2N-1个中心。为何是2N-1？因为两个字符之间的空档也可以是一个中心。例如”abba”的两个b中间就是一个中心。</p><p>4.Manacher算法：</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces 888E 折半搜索</title>
    <link href="/2018/01/26/CodeForces-888E-%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/"/>
    <url>/2018/01/26/CodeForces-888E-%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>E. Maximum Subsequence</p><p>You are given an array a consisting of n integers, and additionally an integer m. You have to choose some sequence of indices b1, b2, …, bk (1 ≤ b1 &lt; b2 &lt; … &lt; bk ≤ n) in such a way that the value of <img src="http://codeforces.com/predownloaded/db/28/db283c0794aac433c817bad7534d99cc6287207c.png" srcset="/img/loading.gif" alt="img">is maximized. Chosen sequence can be empty.</p><p>Print the maximum possible value of <img src="http://codeforces.com/predownloaded/db/28/db283c0794aac433c817bad7534d99cc6287207c.png" srcset="/img/loading.gif" alt="img">.</p><p>Input</p><p>The first line contains two integers n and m (1 ≤ n ≤ 35, 1 ≤ m ≤ 109).</p><p>The second line contains n integers a1, a2, …, an (1 ≤ ai ≤ 109).</p><p>Output</p><p>Print the maximum possible value of <img src="http://codeforces.com/predownloaded/db/28/db283c0794aac433c817bad7534d99cc6287207c.png" srcset="/img/loading.gif" alt="img">.</p><p>Examples</p><p>input</p><p>4 4<br>5 2 4 1 </p><p>output</p><p>3 </p><p>input</p><p>3 20<br>199 41 299 </p><p>output</p><p>19 </p><p>Note</p><p>In the first example you can choose a sequence b = {1, 2}, so the sum <img src="http://codeforces.com/predownloaded/2d/54/2d54a18809c9900276d22b11793fef24b3c7ddc1.png" srcset="/img/loading.gif" alt="img"> is equal to 7 (and that’s 3 after taking it modulo 4).</p><p>In the second example you can choose a sequence b = {3}.</p><p>题意：给出几个数，每个数字可以取也可以不取，使和的取模最大。</p><p>解题思路：这里如果直接搜索的话需要2^35次，所以这里折半搜索，分为前半和后半进行搜索，所以搜2*2^17次就可以了，把前半和后半分别放进set里面，对于前半可以枚举，对于后半就是根据m-1-s[0]来进行二分查找不超过这个值的最大值，然后更新答案即可。</p><pre><code class="hljs c++"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">40</span>];<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;s[<span class="hljs-number">2</span>];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tp,longlong sum,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l==r+<span class="hljs-number">1</span>)<span class="hljs-comment">//这里注意</span>    &#123;        s[tp].insert(sum);        <span class="hljs-comment">//printf("%d %lld\n",tp,sum);</span>        <span class="hljs-keyword">return</span>;    &#125;    dfs(tp,sum,l+<span class="hljs-number">1</span>,r);    dfs(tp,(sum+a[l])%m,l+<span class="hljs-number">1</span>,r);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    longlong ans;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%lld"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;a[i]);        a[i]=a[i]%m;    &#125;    dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n/<span class="hljs-number">2</span>);    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>);    ans=-INF;<span class="hljs-comment">//注意初值</span>    <span class="hljs-built_in">set</span>&lt;longlong&gt;::iterator it,it1;    <span class="hljs-keyword">for</span>(it=s[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>();it!=s[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>();it++)    &#123;        longlong x;        x=m<span class="hljs-number">-1</span>-*it;        it1=s[<span class="hljs-number">1</span>].upper_bound(x);        it1--;<span class="hljs-comment">//小于等于x的数</span>        ans=<span class="hljs-built_in">max</span>(ans,*it+*it1);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces 798D 玄学 贪心</title>
    <link href="/2018/01/26/CodeForces-798D-%E7%8E%84%E5%AD%A6-%E8%B4%AA%E5%BF%83/"/>
    <url>/2018/01/26/CodeForces-798D-%E7%8E%84%E5%AD%A6-%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p>麦克有两个只包含正整数的数组 A = [a1, a2, …, an] 和 B = [b1, b2, …, bn] ，长度都为 n 。</p><p>他现在想要选出 k 个数 P = [p1, p2, …, pk] 满足 1 ≤ pi ≤ n 并且数组 P 中的数字互不相等。要求P数组满足: 2·(ap1 + … + apk) 比数组 A 的和大，并且 2·(bp1 + … + bpk) 比数组 B 的和大。当然， k必须小于等于 <img src="https://odzkskevi.qnssl.com/470dd5d409a475e11ad5716d53913c4e?v=1492826085" srcset="/img/loading.gif" alt="img"> ，否则 P 数组太容易选出来了。</p><p>请你给出一个合法的方案。</p><p>解题思路：</p><p>玄学做法：通过随机乱序原数组，然后判断前 ⌊n2⌋+1 个数的和是否满足题意，不满足继续乱序，一直到碰应了结果就输出，有点神奇…</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">100010</span>],b[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> pos[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> n;   <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> suma=<span class="hljs-number">0</span>,sumb=<span class="hljs-number">0</span>;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);       suma+=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)a[i];       pos[i]=i;    &#125;   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;b[i]);       sumb+=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)b[i];    &#125;   <span class="hljs-keyword">int</span> num;   num=n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;   <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> zsa,zsb;   srand((<span class="hljs-keyword">int</span>)time(<span class="hljs-number">0</span>));   <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)    &#123;       random_shuffle(pos,pos+n);<span class="hljs-comment">//随机乱序</span>       zsa=zsb=<span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)       &#123;           zsa+=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)a[pos[i]];           zsb+=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)b[pos[i]];       &#125;       <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*zsa&gt;suma&amp;&amp;<span class="hljs-number">2</span>*zsb&gt;sumb)       &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,num);           <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,pos[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>);           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;num;i++)                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,pos[i]+<span class="hljs-number">1</span>);           <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);           <span class="hljs-keyword">break</span>;       &#125;    &#125;   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>正解：先把a从大到小排序，然后两个两个取其中b的值比较大的。这样做是因为首先a是从大到小排序的了，而且取了一半的数，当前选的肯定比剩下的大，对于b，b取了两者之间比较大的而且选了一半，所以大。这里抓住取了一半这个条件。</p><p>对于二维的贪心我们可以先让它变成其中一维有序，这样只需要重点考虑另一维，就会简单很多。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 5695 拓扑排序+优先队列</title>
    <link href="/2018/01/26/HDU-5695-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2018/01/26/HDU-5695-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cn.vjudge.net/problem/HDU-5695" target="_blank" rel="noopener">Gym Class</a></p><p>众所周知，度度熊喜欢各类体育活动。 </p><p>今天，它终于当上了梦寐以求的体育课老师。第一次课上，它发现一个有趣的事情。在上课之前，所有同学要排成一列， 假设最开始每个人有一个唯一的ID，从1到NN，在排好队之后，每个同学会找出包括自己在内的前方所有同学的最小ID，作为自己评价这堂课的分数。麻烦的是，有一些同学不希望某个（些）同学排在他（她）前面，在满足这个前提的情况下，新晋体育课老师——度度熊，希望最后的排队结果可以使得所有同学的评价分数和最大。  </p><p>Input</p><p>第一行一个整数TT，表示T(1≤T≤30)T(1≤T≤30) 组数据。 </p><p>对于每组数据，第一行输入两个整数NN和M(1≤N≤100000,0≤M≤100000)M(1≤N≤100000,0≤M≤100000)，分别表示总人数和某些同学的偏好。<br>接下来MM行，每行两个整数AA 和B(1≤A,B≤N)B(1≤A,B≤N)，表示ID为AA的同学不希望ID为BB的同学排在他（她）之前。你可以认为题目保证至少有一种排列方法是符合所有要求的。  </p><p>Output</p><p>对于每组数据，输出最大分数 。</p><p>Sample Input</p><p>3 1 0 2 1 1 2 3 1 3 1</p><p>Sample Output</p><p>1 2 6</p><p><strong>解题思路：</strong></p><p>显然越大的数字排在越前面的方案越好,所以在面临选择的情况下先把大的排在前面.因为排有些人的时候有依赖关系,这个关系相当于要符合一个拓扑序列.所以用优先队列维护入度为0的点,每次把最大的元素放到剩下位置的第一个就好了。</p><p>拓扑排序：</p><p>一.定义</p><p>​    对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若<u，v> ∈E(G)，则u在线性序列中出现在v之前。</p><p>   通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。</p><p>   注意:</p><p>   1)只有有向无环图才存在拓扑序列;</p><p>   2)对于一个DAG,可能存在多个拓扑序列;</p><p>   如:</p><p>   <img src="http://pic002.cnblogs.com/images/2011/288799/2011041609254211.jpg" srcset="/img/loading.gif" alt="img"></p><p>该DAG的拓扑序列为A B C D或者A C B D</p><p> <img src="http://pic002.cnblogs.com/images/2011/288799/2011041609265749.jpg" srcset="/img/loading.gif" alt="img"></p><p>而此有向图是不存在拓扑序列的，因为图中存在环路</p><p>拓扑序列算法思想</p><p> (1)从有向图中选取一个没有前驱(即入度为0)的顶点，并输出之; </p><p> (2)从有向图中删去此顶点以及所有以它为尾的弧;</p><p>重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。</p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;g[<span class="hljs-number">100010</span>];<span class="hljs-keyword">int</span> in[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> t,n,m,u,v;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);   <span class="hljs-keyword">while</span>(t--)    &#123;       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)       &#123;           g[i].<span class="hljs-built_in">clear</span>();           in[i]=<span class="hljs-number">0</span>;       &#125;       <span class="hljs-keyword">while</span>(m--)       &#123;           <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;u,&amp;v);           g[u].push_back(v);           in[v]++;       &#125;       priority_queue&lt;<span class="hljs-keyword">int</span>&gt;q;       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)           <span class="hljs-keyword">if</span>(in[i]==<span class="hljs-number">0</span>)                q.push(i);       <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum=<span class="hljs-number">0</span>;       <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> MIN=INF;       <span class="hljs-keyword">while</span>(!q.empty())       &#123;           <span class="hljs-keyword">int</span> temp=q.top();           q.pop();           <span class="hljs-keyword">if</span>(temp&lt;MIN)MIN=temp;            sum+=MIN;           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;g[temp].<span class="hljs-built_in">size</span>();i++)           &#123;                in[g[temp][i]]--;               <span class="hljs-keyword">if</span>(in[g[temp][i]]==<span class="hljs-number">0</span>)q.push(g[temp][i]);<span class="hljs-comment">//入度为0的点肯定在这里面</span>           &#125;       &#125;       <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,sum);    &#125;   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1672 区间交</title>
    <link href="/2018/01/26/51nod-1672-%E5%8C%BA%E9%97%B4%E4%BA%A4/"/>
    <url>/2018/01/26/51nod-1672-%E5%8C%BA%E9%97%B4%E4%BA%A4/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>小A有一个含有n个非负整数的数列与m个区间。每个区间可以表示为l<em>{i},r</em>{i}li,ri。</p><p>它想选择其中kk个区间， 使得这些区间的交的那些位置所对应的数的和最大。</p><p>数据范围：1&lt;=n&lt;=1e5,1&lt;=k&lt;=m&lt;=1e5</p><p><strong>解题思路：</strong></p><p>先根据左端点从小到大对区间排序，枚举每个区间的左端点当成交的左端点，对于右端点，选择的是左端点比交的左端点小的区间，把它们的右端点放入线段树，注意前k-1个区间是不用枚举左端点的，然后再对于每个确定的交的左端点找第k大的右端点即为该区间。</p><p>注意：res的初始值应该是0，因为存在找不到的情况。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//查询区间第k大</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l==r)        <span class="hljs-keyword">return</span> l;    <span class="hljs-keyword">if</span>(node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val&gt;=x)<span class="hljs-comment">//优先从右树中找满足条件的</span>        <span class="hljs-keyword">return</span> query1(id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,x);    <span class="hljs-keyword">else</span><span class="hljs-comment">//右边不够剩下的点从左树找</span>        <span class="hljs-keyword">return</span> query1(id&lt;&lt;<span class="hljs-number">1</span>,x-node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val);&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1449 砝码称重</title>
    <link href="/2018/01/26/51nod-1449-%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D/"/>
    <url>/2018/01/26/51nod-1449-%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<p><strong>题意：</strong></p><p>你用无数个砝码，每个砝码的重量都是w的幂数，而且每个砝码重量都不同。<br>问能不能用天平与这些砝码称重量为m的物品。</p><p><strong>解题思路：</strong></p><p>如果让一些砝码表示m的话，只需要将m转化为w进制数，然后要求每一位不是0就是1，然而这里可以利用天平使m加上一个由0、1组成的w进制数等于另一个由0、1组成的w进制数，也就是说，转换成了m可以表示成两个由0、1组成的w进制数的差。</p><p>如果是0或1，明显这一位可以构造出来，不管m除以w继续变成子问题。<br>如果是w-1，那么被减数这一位是0，减数这一位是1，相减后还要借位，借位就是被减数减1，于是我们让m除以w再加1使得被减数无需减1，于是继续变成子问题。</p><p>因为是0和1组成的，所以想要构造出来只有这三种情况。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>连通图专题</title>
    <link href="/2018/01/26/%E8%BF%9E%E9%80%9A%E5%9B%BE%E4%B8%93%E9%A2%98/"/>
    <url>/2018/01/26/%E8%BF%9E%E9%80%9A%E5%9B%BE%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>强连通分量tarjan：<a href="https://www.byvoid.com/zhs/blog/scc-tarjan" target="_blank" rel="noopener">https://www.byvoid.com/zhs/blog/scc-tarjan</a></p><p><a href="http://www.cnblogs.com/zufezzt/p/4699731.html" target="_blank" rel="noopener">http://www.cnblogs.com/zufezzt/p/4699731.html</a></p><p>缩点：<a href="https://segmentfault.com/a/1190000009187840" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009187840</a></p><p>求割点：<a href="http://www.cnblogs.com/en-heng/p/4002658.html" target="_blank" rel="noopener">http://www.cnblogs.com/en-heng/p/4002658.html</a></p><p>求桥：<a href="http://blog.csdn.net/fuyukai/article/details/51039788" target="_blank" rel="noopener">http://blog.csdn.net/fuyukai/article/details/51039788</a></p><p>双连通分量：<a href="http://blog.csdn.net/fuyukai/article/details/51303292" target="_blank" rel="noopener">http://blog.csdn.net/fuyukai/article/details/51303292</a></p><p>割边：在连通图中，删除了连通图的某条边后，图不再连通。这样的边被称为割边，也叫做桥。</p><p>割点：在连通图中，删除了连通图的某个点以及与这个点相连的边后，图不再连通。这样的点被称为割点。</p><p>DFS搜索树：用DFS对图进行遍历时，按照遍历次序的不同，我们可以得到一棵DFS搜索树。在上面例子中，得到的搜索树为：</p><p><img src="http://media.hihocoder.com/problem_images/20150627/14353909466118.png" srcset="/img/loading.gif" alt="img"></p><p>树边：在搜索树中的蓝色线所示，可理解为在DFS过程中访问未访问节点时所经过的边，也称为父子边</p><p>回边：在搜索树中的橙色线所示，可理解为在DFS过程中遇到已访问节点时所经过的边，也称为返祖边、后向边</p><p>观察DFS搜索树，我们可以发现有两类节点可以成为割点：</p><ul><li>对根节点u，若其有两棵或两棵以上的子树，则该根结点u为割点；</li><li>对非叶子节点u（非根节点），若其中的某棵子树的节点均没有指向u的祖先节点的回边，说明删除u之后，根结点与该棵子树的节点不再连通；则节点u为割点。</li></ul><p>对于根结点，显然很好处理；但是对于非叶子节点，怎么去判断有没有回边是一个值得深思的问题。</p><p>我们用dfn[u]记录节点u在DFS过程中被遍历到的次序号，low[u]记录节点u或u的子树通过非父子边追溯到最早的祖先节点（即DFS次序号最小），那么low[u]的计算过程如下：</p><p><img src="http://media.hihocoder.com/problem_images/20150627/week52_5.png" srcset="/img/loading.gif" alt="img"></p><p>对于给的例子，其求出的dfn和low数组为：</p><p>id  1 2 3 4 5 6 </p><p>dfn 1 2 3 4 5 6 </p><p>low 1 1 1 4 4 4</p><p>可以发现，对于情况2，当(u,v)为树边且low[v]≥dfn[u]时，节点u才为割点。</p><p>而当(u,v)为树边且low[v]&gt;dfn[u]时，表示v节点只能通过该边(u,v)与u连通，那么(u,v)即为割边。</p><p>若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥），则称作点（边）双连通图。</p><p>对于一个无向图，当我们把图中所有的桥都去掉以后，剩下的每一个区域就是我们要求的边的双连通分量。</p><h5 id="POJ-2186"><a href="#POJ-2186" class="headerlink" title="POJ 2186"></a><strong>POJ 2186</strong></h5><p>题意：每一头牛的愿望就是变成一头最受欢迎的牛。现在有N头牛，给你M对整数(A,B)，表示牛A认为牛B受欢迎。 这种关系是具有传递性的，如果A认为B受欢迎，B认为C受欢迎，那么牛A也认为牛C受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。</p><p>解题思路： 先用tarjan求出每个强连通分量，再缩点，统计每个点的出度，如果有且只有1个出度为0的点，就输出这个点包含的节点数，否则输出0（如果其点有出度，那么这个点首先一定就不是被所有牛崇拜的对象，所以如果一个点没有出度，那么这头牛就很有可能被所有牛所崇拜。如果出度为０的牛大于两个，那么就说明被所有牛都崇拜的个数为０，因为这里有两头及以上牛互相没有崇拜关系）。</p><p>AC代码：</p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">10010</span>];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;scc[<span class="hljs-number">10010</span>];<span class="hljs-keyword">int</span> dfn[<span class="hljs-number">10010</span>];<span class="hljs-comment">//在DFS中该节点被搜索的次序</span><span class="hljs-keyword">int</span> low[<span class="hljs-number">10010</span>];<span class="hljs-comment">//i或i的子树能够通过非树边追溯到最早的祖先节点（即DFS次序号最小）</span><span class="hljs-keyword">int</span> sccn[<span class="hljs-number">10010</span>];<span class="hljs-comment">//缩点数组，表示某个点对应的强连通分量编号</span><span class="hljs-keyword">int</span> ot[<span class="hljs-number">10010</span>];<span class="hljs-comment">//每个强连通分量的出度</span><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">10010</span>];<span class="hljs-comment">//是否在栈中</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>;<span class="hljs-keyword">int</span> cnt;<span class="hljs-comment">//强连通分量编号</span><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;s;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span><span class="hljs-function"></span>&#123;    dfn[u]=low[u]=++<span class="hljs-built_in">step</span>;    vis[u]=<span class="hljs-literal">true</span>;    s.push(u);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[u].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[u][i];        <span class="hljs-keyword">if</span>(!dfn[temp])<span class="hljs-comment">//没有被访问过</span>        &#123;            tarjan(temp);            low[u]=<span class="hljs-built_in">min</span>(low[u],low[temp]);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vis[temp])<span class="hljs-comment">//在栈中</span>            low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[temp]);    &#125;    <span class="hljs-keyword">if</span>(low[u]==dfn[u])<span class="hljs-comment">//构成强连通分量</span>    &#123;        cnt++;        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">int</span> temp=s.top();            s.pop();<span class="hljs-comment">//此点以上的点全部出栈，构成一个强连通分量</span>            vis[temp]=<span class="hljs-literal">false</span>;            sccn[temp]=cnt;<span class="hljs-comment">//cnt是强连通分量的序号</span>            scc[cnt].push_back(temp);            <span class="hljs-keyword">if</span>(temp==u)<span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        v[i].<span class="hljs-built_in">clear</span>();        scc[i].<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-keyword">int</span> from,to;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;from,&amp;to);        v[from].push_back(to);    &#125;    <span class="hljs-built_in">step</span>=cnt=<span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(dfn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dfn));    <span class="hljs-built_in">memset</span>(sccn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(sccn));    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)        <span class="hljs-keyword">if</span>(!dfn[i])            tarjan(i);    <span class="hljs-built_in">memset</span>(ot,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ot));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;v[i].<span class="hljs-built_in">size</span>();j++)    &#123;        <span class="hljs-keyword">int</span> temp=v[i][j];        <span class="hljs-keyword">if</span>(sccn[i]!=sccn[temp])<span class="hljs-comment">//如果i点与他指向的点不在同一个强连通分量中</span>            ot[sccn[i]]++;<span class="hljs-comment">//i点所在的强连通分量的出度+1</span>    &#125;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-comment">//出度为0的强连通分量个数</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)    <span class="hljs-keyword">if</span>(ot[i]==<span class="hljs-number">0</span>)    &#123;        num++;        pos=i;    &#125;    <span class="hljs-keyword">if</span>(num==<span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,scc[pos].<span class="hljs-built_in">size</span>());    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="HDU-2767"><a href="#HDU-2767" class="headerlink" title="HDU 2767"></a><strong>HDU 2767</strong></h5><p>题意：至少增加几条边，才能让图强连通。</p><p>解题思路：我们要将这个图变成强连通分量为1的图，我们不妨这样考虑：既然强连通分量为1的图有这样的特点：如果一个图是强连通分量为1的图，对于每个节点来说，一定没有任何一个点的出度或者入度有0的情况。那么我们的任务也就明确了，对于所有节点度的处理，使得没有０度的存在。这里设出度为０的节点数为ａ，设入度为０的节点数为ｂ，其实我们如果找到了ａ和ｂ的值，搞定最大值，其实也就搞定了这个问题（注意本来就是连通图的情况要特判）。</p><h5 id="POJ-1236"><a href="#POJ-1236" class="headerlink" title="POJ 1236"></a><strong>POJ 1236</strong></h5><p>题意：</p><p>​       有N个学校，从每个学校都能从一个单向网络到另外一个学校，两个问题1：初始至少需要向多少个学校发放软件，使得网络内所有的学校最终都能得到软件。2：至少需要添加几条边，使任意向一个学校发放软件后，经过若干次传送，网络内所有的学校最终都能得到软件。</p><p>解题思路：</p><p>​      在有向无环图中，边变为了强连通分量之间的文件传输关系。意味着：只要一个强连通分量有入边，那么就可以通过这个入边从另外一个分量中接收文件。但是，无环图意味着肯定存在没有入度(入度为0)的强连通分量，这些强连通分量没有文件来源，所以要作为投放文件的位置。那么，第一问就只需要计算出缩点后入度为0的强连通分量数目即可。第二问同HDU2767。</p><h5 id="UVA-315"><a href="#UVA-315" class="headerlink" title="UVA 315"></a><strong>UVA 315</strong></h5><p>题意：求割点。</p><p>解题思路：</p><p>在无向连通图G中，<br>1、根结点u为割顶当且仅当它有两个或者多个子结点；<br>2、非根结点u为割顶当且仅当u存在结点v，使得v极其所有后代都没有反向边可以连回u的祖先（u不算）<br>在Tarjan算法里面，有两个时间戳非常重要，一个是dfn，意为深度优先数，即代表访问顺序；一个是low，意为通过反向边能到达的最小dfn。于是，上述定理中第二个条件（非根结点）可以简单地写成low[v]&gt;=dfn[u]。 </p><p>可作模板。</p><p><strong>求割点模板：</strong></p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">10010</span>];<span class="hljs-keyword">int</span> dfn[<span class="hljs-number">10010</span>];<span class="hljs-comment">//在DFS中该节点被搜索的次序</span><span class="hljs-keyword">int</span> low[<span class="hljs-number">10010</span>];<span class="hljs-comment">//i或i的子树能够追溯到的最早的栈中节点的次序号</span><span class="hljs-keyword">bool</span> cut[<span class="hljs-number">10010</span>];<span class="hljs-comment">//是否为割点</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    dfn[u]=low[u]=++<span class="hljs-built_in">step</span>;    <span class="hljs-keyword">int</span> child=<span class="hljs-number">0</span>;<span class="hljs-comment">//孩子结点的数目</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[u].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[u][i];        <span class="hljs-keyword">if</span>(temp==fa)<span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(!dfn[temp])<span class="hljs-comment">//没有被访问过</span>        &#123;            child++;            tarjan(temp,u);            low[u]=<span class="hljs-built_in">min</span>(low[u],low[temp]);            <span class="hljs-keyword">if</span>(u!=fa&amp;&amp;low[temp]&gt;=dfn[u])<span class="hljs-comment">//当前结点不是根结点</span>                cut[u]=<span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">else</span> low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[temp]);    &#125;    <span class="hljs-keyword">if</span>(u==fa&amp;&amp;child&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//当前结点是根结点</span>        cut[u]=<span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,from,to;    <span class="hljs-keyword">char</span> ch;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            v[i].<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;from);            <span class="hljs-keyword">if</span>(from==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)            &#123;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%c"</span>,&amp;to,&amp;ch);                v[from].push_back(to);                v[to].push_back(from);                <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">'\n'</span>)<span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-built_in">step</span>=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(dfn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dfn));        <span class="hljs-built_in">fill</span>(cut+<span class="hljs-number">1</span>,cut+n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">if</span>(!dfn[i])                tarjan(i,i);        <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)            <span class="hljs-keyword">if</span>(cut[i])num++;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,num);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="UVA-796"><a href="#UVA-796" class="headerlink" title="UVA 796"></a><strong>UVA 796</strong></h5><p>题意：求桥。</p><p>解题思路：可作模板。</p><p><strong>求割边模板：</strong></p><pre><code class="hljs c++"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">10010</span>];<span class="hljs-keyword">int</span> dfn[<span class="hljs-number">10010</span>];<span class="hljs-comment">//在DFS中该节点被搜索的次序</span><span class="hljs-keyword">int</span> low[<span class="hljs-number">10010</span>];<span class="hljs-comment">//i或i的子树能够追溯到的最早的栈中节点的次序号</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">a</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> ansx,ansy;&#125;ans[<span class="hljs-number">10010</span>];<span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>,cnt;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(a x,a y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x.ansx!=y.ansx)<span class="hljs-keyword">return</span> x.ansx&lt;y.ansx;    <span class="hljs-keyword">return</span> x.ansy&lt;y.ansy;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    dfn[u]=low[u]=++<span class="hljs-built_in">step</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[u].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">int</span> temp=v[u][i];        <span class="hljs-keyword">if</span>(!dfn[temp])<span class="hljs-comment">//没有被访问过</span>        &#123;            tarjan(temp,u);            low[u]=<span class="hljs-built_in">min</span>(low[u],low[temp]);            <span class="hljs-keyword">if</span>(low[temp]&gt;dfn[u])<span class="hljs-comment">//一条无向边(u,v)是桥，当且仅当(u,v)为树枝边，且满足DFS(u)&lt;Low(v)。</span>            &#123;                <span class="hljs-keyword">int</span> a=u,b=temp;                <span class="hljs-keyword">if</span>(a&gt;b)swap(a,b);                ans[cnt].ansx=a;                ans[cnt++].ansy=b;            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dfn[temp]&lt;dfn[u]&amp;&amp;temp!=fa)            low[u]=<span class="hljs-built_in">min</span>(low[u],dfn[temp]);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,from,to,num;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            v[i].<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d (%d)"</span>,&amp;from,&amp;num);            <span class="hljs-keyword">while</span>(num--)            &#123;                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;to);                v[from].push_back(to);            &#125;        &#125;        <span class="hljs-built_in">step</span>=cnt=<span class="hljs-number">0</span>;        <span class="hljs-built_in">memset</span>(dfn,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dfn));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-keyword">if</span>(!dfn[i])                tarjan(i,i);        sort(ans,ans+cnt,cmp);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d critical links\n"</span>,cnt);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d - %d\n"</span>,ans[i].ansx,ans[i].ansy);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="POJ-3177"><a href="#POJ-3177" class="headerlink" title="POJ 3177"></a><strong>POJ 3177</strong></h5><p>题意：最少加多少条边使图变得双连通（有重边）。</p><p>解题思路：</p><p><a href="http://blog.csdn.net/lyy289065406/article/details/6762370" target="_blank" rel="noopener">http://blog.csdn.net/lyy289065406/article/details/6762370</a></p><p><a href="http://blog.csdn.net/lyy289065406/article/details/6762432" target="_blank" rel="noopener">http://blog.csdn.net/lyy289065406/article/details/6762432</a></p><p>首先要找出图G的所有【边双连通分量】。</p><p>Tarjan算法用来寻找图G的所有【边双连通分量】是最简单有效的方法，因为Tarjan算法在DFS过程中会对图G所有的结点都生成一个Low值，而由于题目已表明任意两个结点之间不会出现重边，因此Low值相同的两个结点必定在同一个【边双连通分量】中！  （如果是有重边的话，那么不同的low值是可能是属于同一个边双连通分量的，这个时候就要通过其他方法去求解边双连通分量。）无向图的边双连通分量似乎和求强连通相似…其实也是有原因的…</p><p>那么如何解决重边的问题？</p><p>1、  构造图G时把重边也考虑进来，然后在划分边双连通分量时先把桥删去，再划分，其中桥的一端的割点归入当前正在划分的边双连通分量。这个处理比较麻烦；</p><p>2、  在输入图G的边时，若出现重边，则不把重边放入图G，然后在划分边双连通分量时依然用Low划分。</p><p>把每一个【边双连通分量】都看做一个点（即【缩点】）</p><p>问题再次被转化为“至少在缩点树上增加多少条树边，使得这棵树变为一个双连通图”。</p><p>首先知道一条等式：</p><p>若要使得任意一棵树，在增加若干条边后，变成一个双连通图，那么</p><p><strong>至少增加的边数 =（ 这棵树总度数为1的结点数 + 1 ）/ 2</strong></p><p>那么我们只需求缩点树中总度数为1的结点数（即叶子数）有多少就可以了。换而言之，我们只需求出所有缩点的度数，然后判断度数为1的缩点有几个，问题就解决了。</p><p>求出所有缩点的度数的方法</p><p>两两枚举图G的直接连通的点，只要这两个点不在同一个【缩点】中，那么它们各自所在的【缩点】的度数都+1。注意由于图G时无向图，这样做会使得所有【缩点】的度数都是真实度数的2倍，必须除2后再判断叶子。</p><h5 id="HDU-4612"><a href="#HDU-4612" class="headerlink" title="HDU 4612"></a><strong>HDU 4612</strong></h5><p>题意：有重边的无向图，问添加一条边最多能够减少多少个桥。</p><p>解题思路：</p><p>这条边肯定是连最远的，边双连通分量缩点重建树，然后dfs找树的直径， 答案就是缩点之后的边数-直径。</p><p>重边的处理：用一个k标记，假如这个点到父亲的路有两条，那么第一条可以不走，但是第二条必须要走，因为是重边,这样我的儿子节点也就可以更新low了。</p><p>树的直径（最长路）的求法：假设 s-t这条路径为树的直径，或者称为树上的最长路，从任意一点u出发搜到的最远的点一定是s、t中的一点，然后在从这个最远点开始搜，就可以搜到另一个最长路的端点，即用两遍广搜就可以找出树的最长路。</p><h5 id="HDU-4635"><a href="#HDU-4635" class="headerlink" title="HDU 4635"></a><strong>HDU 4635</strong></h5><p>题意：给你一个有向图，问在保证这个图无重边，无自环，且不是强连通图的情况下，最多可以添加多少条有向边。</p><p>解题思路：</p><p>找出强联通块，计算每个连通块内的点数。将点数最少的那个连通块单独拿出来，其余的连通块合并成一个连通分量。假设第一个连通块的 点数是 x  第二个连通块的点数是 y, 已经有的边数是 m，</p><p>如果使X图强连通，边数最多为x<em>(x-1)(即X图的每个顶点到X图其它每个顶点都有一条单向边)；如果使Y图强连通，边数最多为y</em>(y-1)；X图和Y图之间只有单项的边，则边数最多为x*y(即X图的每个顶点到Y图每个顶点都有一条单向边)。</p><p>通过以上可以求得边数F（DAG）=x<em>y+x</em>(x-1)+y<em>(y-1)=n</em>n-n-x<em>y.即DAG图的边数最多为n</em>n-n-x*y-m。</p><p>由于n一定，所以本题就可以转化为求x*y的最小值，又因为x+y=n，可知x一定要和y相差最大，所以x要最小。而且要找的X图一定是入度为0或者出度为0的强连通分量，因为无法删边，如果入度和出度都不为0的话 ，说明该边是一定存在的，就无法用这个式子了。</p><h5 id="HDU-4738"><a href="#HDU-4738" class="headerlink" title="HDU 4738"></a><strong>HDU 4738</strong></h5><p>题意：给一个无向图，求找出一条边，使得删除这条边以后整个图就不连通了，找出满足的边里权值最小的那个，找不到输出-1。</p><p>解题思路：注意细节即可。考虑图本来就连通和不连通的情况，以及最小的权值为0的时候也要有人去背。</p><h5 id="POJ-3694"><a href="#POJ-3694" class="headerlink" title="POJ 3694"></a><strong>POJ 3694</strong></h5><p>题意：</p><p>解题思路：首先运行一次tarjan，求出桥和缩点，那么远无向图将缩点为一棵树，树边正好是原来的桥。每次连接两点，看看这两点是不是在同一个缩点内，如果是，那么缩点后的树没任何变化，如果两点属于不同的缩点，那么连接起来，然后找这两个缩点的LCA，因为从点u到LCA再到点v再到点u，将形成环，里面的树边都会变成不是桥。</p><h5 id="2018年全国多校算法寒假训练营练习比赛（第四场）D"><a href="#2018年全国多校算法寒假训练营练习比赛（第四场）D" class="headerlink" title="2018年全国多校算法寒假训练营练习比赛（第四场）D"></a><strong>2018年全国多校算法寒假训练营练习比赛（第四场）D</strong></h5><p>题意：给出一个n*m个格子的地图，每个格子都有黄金。小明可以将他所在的格子的黄金收归囊中，并且还可以向下或者向右移动’.’，然后继续收集黄金。小明不能移动到有障碍物‘#’的格子上。小明可以随意地在地图上放置可以传送到地图上某一个确定的格子的传送门。至少要使用多少个传送门才能让他在游戏时无论出现在哪个格子，他都能拿到地图上的所有金子。</p><p>思路：首先考虑题目里说要拿到所有金子，意思就是要让整张图强连通，而传送门就相当于至少增加几条边，才能让图强连通。这里数据比较大0&lt;n,m&lt;=1000，如果缩点会爆内存，所以只用这种思想即建好图找出度为0的数量和入度为0的数量，取最大值，而不用缩点，注意这里还是要特判只有一个’.’点的情况。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树专题</title>
    <link href="/2018/01/26/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98/"/>
    <url>/2018/01/26/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="POJ-3264"><a href="#POJ-3264" class="headerlink" title="POJ 3264"></a><strong>POJ 3264</strong></h5><p>题意：给出一串的数字，然后给出一个区间a b，输出从a到b的最大的数和最小的数的差</p><p>解题思路：直接跑两次query，一次查询最小，一次查询最大即可。</p><h5 id="POJ-2528"><a href="#POJ-2528" class="headerlink" title="POJ 2528"></a><strong>POJ 2528</strong></h5><p>题意：n（n&lt;=10000)个人依次贴海报,给出每张海报所贴的范围li，ri（1&lt;=li&lt;=ri&lt;=10000000)，求出最后还能看见多少张海报。</p><p>解题思路：离散化+线段树。</p><p>离散化部分：</p><p>如下面的例子（题目的样例），因为单位1是一个单位长度，将下面的</p><p>​      1   2   3   4  6   7   8   10</p><p>​     —  —  —  —  —  —  —  —</p><p>​      1   2   3   4  5   6   7   8</p><p>离散化  X[1] = 1; X[2] = 2; X[3] = 3; X[4] = 4; X[5] = 6; X[7] = 8; X[8] = 10</p><p>于是将一个很大的区间映射到一个较小的区间之中了，然后再对每一张海报依次更新在宽度为1~8的墙上(用线段树），最后统计不同颜色的段数。</p><p>但是只是这样简单的离散化是错误的，</p><p>如三张海报为：1~10 1~4 6~10</p><p>离散化时 X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 6, X[ 4 ] = 10<br>第一张海报时：墙的1~4被染为1；<br>第二张海报时：墙的1~2被染为2，3~4仍为1；<br>第三张海报时：墙的3~4被染为3，1~2仍为2。<br>最终，第一张海报就显示被完全覆盖了，于是输出2，但实际上明显不是这样，正确输出为3。</p><p>新的离散方法为：在相差大于1的数间加一个数，例如在上面1 4 6 10中间加5（算法中实际上1，4之间，6，10之间都新增了数的）</p><p>X[ 1 ] = 1, X[ 2 ] = 4, X[ 3 ] = 5, X[ 4 ] = 6， X[ 5 ] = 10</p><p>这样之后，第一次是1~5被染成1；第二次1~2被染成2；第三次4~5被染成3</p><p>最终，1~2为2，3为1，4~5为3，于是输出正确结果3。</p><p>这里不用map，用二分查找找到离散后的编号即可。</p><p>线段树部分：</p><p>把海报的编号当成lazy标记，如果访问了某个区间，则lazy标记更新，update和query的时候都要标记下传，本区间的lazy标记归零。</p><h5 id="HDU-4027"><a href="#HDU-4027" class="headerlink" title="HDU 4027"></a><strong>HDU 4027</strong></h5><p>题意：给定100000个数，两种操作，0 i j表示将i j这段的数字都开根号（向下取整），1 i j表示查询i j之间的所有值的和（所有的和都不超过64位）。</p><p>解题思路：注意到值为1之后就不用再开根号了，注意这个剪枝即可，还有注意开long long。</p><h5 id="HDU-1540"><a href="#HDU-1540" class="headerlink" title="HDU 1540"></a><strong>HDU 1540</strong></h5><p>题意：D代表破坏村庄，R代表修复最后被破坏的那个村庄，Q代表询问包括x在内的最大连续区间是多少。</p><p>解题思路：区间合并问题。设置lsum[n],rsum[n]分别表示区间左端连续村庄个数,区间右端连续村庄个数。</p><p>注意query函数的写法：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loc,<span class="hljs-keyword">int</span> id)</span>   <span class="hljs-comment">//区间查询</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l==r)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(loc&gt;=m-node[id&lt;&lt;<span class="hljs-number">1</span>].rsum+<span class="hljs-number">1</span>&amp;&amp;loc&lt;=m+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].lsum)       <span class="hljs-keyword">return</span> node[id&lt;&lt;<span class="hljs-number">1</span>].rsum+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].lsum;    <span class="hljs-keyword">if</span>(loc&lt;=m)<span class="hljs-keyword">return</span> query(loc,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> query(loc,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);&#125;</code></pre><h5 id="HDU-3974"><a href="#HDU-3974" class="headerlink" title="HDU 3974"></a><strong>HDU 3974</strong></h5><p>题意：一棵树的结构，父节点是老板，子节点是员工，每次给父节点分配的任务，立即会下分到他所有的子节点，有更新和查询命令。</p><p>解题思路：以样例为例子：</p><p><img src="http://imglf3.nosdn.127.net/img/ajhrcUFValVhVzZueWd3RExSU2tWMlNhcmFiajRDWXQvNkswMWdxNEhSMU4veXFqUEdJTXhnPT0.jpg?=imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2" srcset="/img/loading.gif" alt="img"></p><p>用dfs将结点重新编号，对于每个结点，保存st和ed，分别表示自己的编号和最后儿子的编号，使其连续，然后映射到线段树上，对于T操作就是对于st[i]到ed[i]的区间修改，对于C操作就是单点查询。</p><h5 id="HDU-1542"><a href="#HDU-1542" class="headerlink" title="HDU 1542"></a><strong>HDU 1542</strong></h5><p>题意：矩形面积并。</p><p>解题思路：</p><p><a href="http://www.cnblogs.com/KonjakJuruo/p/6024266.html" target="_blank" rel="noopener">http://www.cnblogs.com/KonjakJuruo/p/6024266.html</a></p><p><a href="http://blog.csdn.net/kirito_acmer/article/details/45918499" target="_blank" rel="noopener">http://blog.csdn.net/kirito_acmer/article/details/45918499</a></p><h5 id="HDU-4578"><a href="#HDU-4578" class="headerlink" title="HDU 4578"></a><strong>HDU 4578</strong></h5><p>题意：</p><p>给一个数组，初始值为零，有四种操作</p><p>“1 x y c”,代表 把区间 [x,y] 上的值全部加c</p><p>“2 x y c”,代表 把区间 [x,y] 上的值全部乘以c</p><p>“3 x y c” 代表 把区间 [x,y]上的值全部赋值为c</p><p>“4 x y p” 代表 求区间 [x,y] 上值的p次方和1&lt;=p&lt;=3</p><p>解题思路：</p><p>lazy标记用ax+b即可。注意细节即可。</p><h5 id="HDU-4614"><a href="#HDU-4614" class="headerlink" title="HDU 4614"></a><strong>HDU 4614</strong></h5><p>题意：</p><p>有n个花瓶，标号0 ~ n−1。m个操作， </p><p>‘1AF′，表示从A位置开始插F朵花，遇到有花的花瓶跳过。到最后一个花瓶都还有花剩余，丢弃剩下的花。 </p><p>‘2AB′，表示将区间[A,B]内的花瓶全部清空。(A≤B) </p><p>对于每个1操作，输出第一个和最后一个插花的位置，如果一朵花都插不了，输出‘Can not put any one.’；对于每个2操作，输出区间[A,B]内被清空的花瓶的数量。</p><p>解题思路：</p><p>线段树+二分。</p><p>令num(i,j)为区间[i,j]的空花瓶数。<br>对于一个1操作，首先判一下num(A,n)是否大于0。之后，因为区间[A,n]的空花瓶数是单调不递减的，所以可以通过二分查找到 一个最小的位置L，使得num(A,L)==1，则此时的L就是第一个插花的位置；同样二分找到一个最小的位置R，使得num(A,R)==min(F,num(A,n))，则此时的R就是最后一个插花的位置。<br>对于一个2操作，直接询问区间[A,B]的空花瓶数，拿总数一减，输出。</p><p>二分的写法：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bin_search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loc,<span class="hljs-keyword">int</span> num)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=loc,r=n<span class="hljs-number">-1</span>;    <span class="hljs-keyword">int</span> res;    <span class="hljs-keyword">while</span>(l&lt;=r)    &#123;        <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;        ans=<span class="hljs-number">0</span>;        query2(loc,m,<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(ans&gt;=num)        &#123;            res=m;            r=m<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">else</span> l=m+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AC自动机专题</title>
    <link href="/2018/01/26/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%93%E9%A2%98/"/>
    <url>/2018/01/26/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="HDU-2896"><a href="#HDU-2896" class="headerlink" title="HDU 2896"></a><strong>HDU 2896</strong></h5><p>别把num设成-1…因为有多个母串…</p><h5 id="POJ-2778"><a href="#POJ-2778" class="headerlink" title="POJ 2778"></a><strong>POJ 2778</strong></h5><p>题意：有m种DNA序列是有疾病的，问有多少种长度为n的DNA序列不包含任何一种有疾病的DNA序列。（仅含A,T,C,G四个字符）</p><p>解题思路：</p><p>AC自动机+矩阵快速幂</p><p><a href="http://blog.csdn.net/morgan_xww/article/details/7834801" target="_blank" rel="noopener">http://blog.csdn.net/morgan_xww/article/details/7834801</a></p><p>这里涉及到用Trie图构造邻接矩阵…</p><p>于是补了一下Trie图的构建…</p><p><a href="http://www.cppblog.com/menjitianya/archive/2014/07/10/207604.html" target="_blank" rel="noopener">http://www.cppblog.com/menjitianya/archive/2014/07/10/207604.html</a></p><p>这里还有一个知识点：矩阵A^m所代表的意义就是从点与点之间走m步能够到达的方案总数。</p><p><a href="http://blog.csdn.net/WT_cnyali/article/details/69803030" target="_blank" rel="noopener">http://blog.csdn.net/WT_cnyali/article/details/69803030</a></p><p><img src="http://imglf4.nosdn.127.net/img/ajhrcUFValVhVzRuaStXbHpydTN2T0FkY1k3OUsxcjZXZzFId2dDVWIwa0tZSENhY1lmenp3PT0.jpg?=imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2" srcset="/img/loading.gif" alt="img"></p><h5 id="HDU-2243"><a href="#HDU-2243" class="headerlink" title="HDU 2243"></a><strong>HDU 2243</strong></h5><p>题意：给定n个单词，求长度不大于m的字符串中所有含给定单词的字符串的个数 。</p><p>解题思路：</p><p>整体和上题相似，即所有情况再减去上题求的情况即可。</p><p><img src="http://imglf5.nosdn.127.net/img/ajhrcUFValVhVzVyNFV3Zlo3bUdnYzRGWUhoRnJxaTVnMTI3R0FQdVZYOTl0RHI1LzNnR0tBPT0.jpg?=imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2" srcset="/img/loading.gif" alt="img"></p><p>将运算过程中的变量和矩阵的元素定义为unsigned __int64，就能实现自动对2^64自动取MOD。注意输出是%I64u。</p><h5 id="HDU-2457"><a href="#HDU-2457" class="headerlink" title="HDU 2457"></a><strong>HDU 2457</strong></h5><p>题意：已知一个DNA串和一些病毒DNA序列，求出最少改变DNA串中多少个字符，能使得串中不包含任意一个病毒序列。</p><pre><code class="hljs markdown">解题思路：Trie图+DP。先构造Trie图，这里要注意如果fail指针指向危险子串的本身也危险，if(temp-&gt;child[i]-&gt;fail-&gt;num==1)//注意：fail指针指向危险子串的本身也危险temp-&gt;child[i]-&gt;num=1;之后就是DP，f[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]表示匹配到原串第i个字符时，在AC自动机的j号节点时没有病毒串的最小花费。转移的时候有三种情况：1.转移出病毒串，这个时候直接continue。2.转移与原串相符，这个时候直接将数值转移过去。3.转移与原串不符，这个时候转移数值之后还要+1，再在dp[<span class="hljs-string">len</span>][<span class="hljs-symbol">i</span>]中找到最小值。</code></pre><pre><code class="hljs c++">   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=len;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;sum;j++)        dp[i][j]=INF;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;sum;j++)    <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j]&lt;INF)<span class="hljs-comment">//不是从病毒串转移的</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)        &#123;            <span class="hljs-keyword">if</span>(Trie[j].child[k]-&gt;num==<span class="hljs-number">0</span>)<span class="hljs-comment">//不是一个单词的结尾</span>            &#123;                p=Trie[j].child[k];                <span class="hljs-comment">//转移与原串相符，这个时候直接将数值转移过去。转移与原串不符，这个时候转移数值之后还要+1。</span>                dp[i][p-&gt;idd]=<span class="hljs-built_in">min</span>(dp[i][p-&gt;idd],dp[i<span class="hljs-number">-1</span>][j]+(bh(str[i<span class="hljs-number">-1</span>])!=k));            &#125;        &#125;    &#125;    <span class="hljs-keyword">int</span> ans=INF;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;sum;i++)    &#123;        <span class="hljs-keyword">if</span>(Trie[i].num==<span class="hljs-number">0</span>&amp;&amp;dp[len][i]&lt;ans)            ans=dp[len][i];    &#125;    <span class="hljs-keyword">if</span>(ans==INF)ans=<span class="hljs-number">-1</span>;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP&amp;扩展KMP&amp;Manacher专题</title>
    <link href="/2018/01/26/KMP-%E6%89%A9%E5%B1%95KMP-Manacher%E4%B8%93%E9%A2%98/"/>
    <url>/2018/01/26/KMP-%E6%89%A9%E5%B1%95KMP-Manacher%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="KMP模板"><a href="#KMP模板" class="headerlink" title="KMP模板"></a><strong>KMP模板</strong></h5><p>参考视频：<a href="https://www.bilibili.com/video/av3246487/" target="_blank" rel="noopener">https://www.bilibili.com/video/av3246487/</a></p><p><a href="https://www.bilibili.com/video/av11866460/" target="_blank" rel="noopener">https://www.bilibili.com/video/av11866460/</a></p><p><a href="https://www.bilibili.com/video/av16828557/" target="_blank" rel="noopener">https://www.bilibili.com/video/av16828557/</a></p><p>参考博客：<a href="https://subetter.com/algorithms-and-mathematics/kmp-algorithm.html" target="_blank" rel="noopener">https://subetter.com/algorithms-and-mathematics/kmp-algorithm.html</a></p><p>复杂度：<script type="math/tex">O(m+n)</script></p><pre><code class="hljs c++"><span class="hljs-comment">//s为母串，p为模式串</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getnext</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> k=<span class="hljs-number">-1</span>,j=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(p);    Next[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(j&lt;len)    &#123;        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">-1</span>||p[k]==p[j])        &#123;            k++;            j++;            <span class="hljs-comment">//if(p[j]!=p[k])</span>            Next[j]=k;            <span class="hljs-comment">//else Next[j]=Next[k];</span>        &#125;        <span class="hljs-keyword">else</span> k=Next[k];    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    getnext();    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> slen=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">int</span> plen=<span class="hljs-built_in">strlen</span>(p);    <span class="hljs-keyword">while</span>(i&lt;slen)    &#123;        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span>||s[i]==p[j])        &#123;            i++;            j++;            <span class="hljs-keyword">if</span>(j==plen)            &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,i+<span class="hljs-number">1</span>-plen);<span class="hljs-comment">//出现的位置</span>                cnt++;                j=Next[j];            &#125;        &#125;        <span class="hljs-keyword">else</span> j=Next[j];    &#125;    <span class="hljs-keyword">return</span> cnt;   <span class="hljs-comment">//返回出现的次数</span>&#125;</code></pre><h5 id="Manacher模板"><a href="#Manacher模板" class="headerlink" title="Manacher模板"></a><strong>Manacher模板</strong></h5><p>参考博客：<a href="https://www.jianshu.com/p/799bc53d4e3d" target="_blank" rel="noopener">https://www.jianshu.com/p/799bc53d4e3d</a></p><p>复杂度：<script type="math/tex">O(n)</script></p><pre><code class="hljs c++"><span class="hljs-keyword">char</span> a[<span class="hljs-number">11000010</span>];<span class="hljs-comment">//aba</span><span class="hljs-keyword">char</span> anew[<span class="hljs-number">23000010</span>];<span class="hljs-comment">//$#a#b#a#</span><span class="hljs-keyword">int</span> p[<span class="hljs-number">23000010</span>];<span class="hljs-comment">//新串中以第i个字符为对称轴的回文串的回文半径</span><span class="hljs-comment">//p[i]-1为原串中以i为对称轴的最长回文串的长度</span><span class="hljs-comment">/*</span><span class="hljs-comment">* abaaba</span><span class="hljs-comment">* i: 0 1 2 3 4 5 6 7 8 9 10 11 12 13</span><span class="hljs-comment">* anew[i]: $ # a # b # a # a # b # a #</span><span class="hljs-comment">* p[i]:    1 1 2 1 4 1 2 7 2 1 4 1 2 1</span><span class="hljs-comment">* p[i]-1:  0 0 1 0 3 0 1 6 1 0 3 0 1 0</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(a);    anew[<span class="hljs-number">0</span>]=<span class="hljs-string">'$'</span>;    anew[<span class="hljs-number">1</span>]=<span class="hljs-string">'#'</span>;    <span class="hljs-keyword">int</span> num=<span class="hljs-number">2</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        anew[num++]=a[i];        anew[num++]=<span class="hljs-string">'#'</span>;    &#125;    anew[num]=<span class="hljs-string">'\0'</span>;    <span class="hljs-comment">//puts(anew);</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Manacher</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    init();    <span class="hljs-keyword">int</span> MAX=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(anew);    <span class="hljs-comment">//printf("%d\n",len);</span>    <span class="hljs-keyword">int</span> id;<span class="hljs-comment">//mx对应的回文串的对称轴所在的位置</span>    <span class="hljs-keyword">int</span> mx=<span class="hljs-number">0</span>;<span class="hljs-comment">//当前访问到的所有回文子串，所能触及的最右一个字符的位置</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(i&lt;mx)            p[i]=<span class="hljs-built_in">min</span>(p[<span class="hljs-number">2</span>*id-i],mx-i);        <span class="hljs-keyword">else</span>            p[i]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(anew[i-p[i]]==anew[i+p[i]])<span class="hljs-comment">//扩展</span>            p[i]++;        <span class="hljs-keyword">if</span>(mx&lt;i+p[i])<span class="hljs-comment">//最右的字符的位置要改变</span>        &#123;            id=i;            mx=i+p[i];        &#125;        MAX=<span class="hljs-built_in">max</span>(MAX,p[i]<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-keyword">return</span> MAX;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,Manacher());    <span class="hljs-comment">/*for(int i=1;i&lt;strlen(anew);i++)</span><span class="hljs-comment">        printf("%d ",p[i]-1);</span><span class="hljs-comment">    printf("\n");*/</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="HDU-1686"><a href="#HDU-1686" class="headerlink" title="HDU 1686"></a><strong>HDU 1686</strong></h5><p>题意：AZA AZAZAZA 输出3</p><p>解题思路：</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(j==plen)&#123;    cnt++;    j=Next[j];&#125;</code></pre><h5 id="HDU-2087"><a href="#HDU-2087" class="headerlink" title="HDU 2087"></a><strong>HDU 2087</strong></h5><p>题意：aaaaaa  aa 输出3</p><p>解题思路：</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(j==plen)&#123;    cnt++;    j=<span class="hljs-number">0</span>;&#125;</code></pre><h5 id="HDU-3746"><a href="#HDU-3746" class="headerlink" title="HDU 3746"></a><strong>HDU 3746</strong></h5><p>题意：给你一个字符串，要求将字符串的全部字符最少循环2次需要添加的字符数。</p><p>解题思路：找循环节。len-next[i]为此字符串的最小循环节(i为字符串的结尾)，如果len%(len-next[i])==0,此字符串的最小周期就为len/(len-next[i])。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> length=len-Next[len];<span class="hljs-comment">//循环节长度</span><span class="hljs-keyword">if</span>(len!=length&amp;&amp;len%length==<span class="hljs-number">0</span>)    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,length-Next[len]%length);</code></pre><h5 id="HDU-3336（存疑）"><a href="#HDU-3336（存疑）" class="headerlink" title="HDU 3336（存疑）"></a><strong>HDU 3336（存疑）</strong></h5><p>题意：求给出字符串的所有前缀在原字符串中出现的次数和。</p><p>解题思路：dp[i]代表以第i位结尾的字符串中包括多少以第i位字母结尾的前缀的出现次数，那么有dp[i]=dp[Next[i]]+1，利用Next数据跳转到第Next[i]的位置，这个位置的跟之前的有过多少次匹配，只要在原基础上加1即可。</p><h5 id="HDU-2609"><a href="#HDU-2609" class="headerlink" title="HDU 2609"></a><strong>HDU 2609</strong></h5><p>题意：有n个有01组成的字符串，每个字符串都代表一个项链，那么该字符串就是一个环状的结构，求可以经过循环旋转，最后不同的串有多少个。</p><p>解题思路：</p><p>将每个字符串转换成最小串（因为最小串对于每一个长度相同但不同的串都是不一样的），然后放在set里面去重。</p><p>最小表示法：</p><p>有一个字符串，这个字符串的首尾是连在一起的，要求寻找一个位置，以该位置为起点的字符串的字典序在所有的字符串中中最小。</p><p>假设有两个下标i，j，表示如果从i和从j出发的字符串，有一个k表示字符串的长度，如果长度达到len，就表示找到最小的串。</p><p>s[i+k] == s[j+k]:  k++</p><p>s[i+k]&gt;s[j+k]: i=i+k+1 表示以i，到i+k为起点的字符串，都不是最小字符串的前缀。</p><p>s[i+k]&lt;s[j+k]: j=j+k+1 同理</p><p>直到i或j大于串长，找较小者。</p><p>注意：1.i和j一定是不同的。2.每次不等时，需要设置k为0。</p><p>复杂度：<script type="math/tex">O(n)</script>。</p><h5 id="最小表示法模板"><a href="#最小表示法模板" class="headerlink" title="最小表示法模板"></a><strong>最小表示法模板</strong></h5><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=str.<span class="hljs-built_in">size</span>();    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(i&lt;len&amp;&amp;j&lt;len&amp;&amp;k&lt;len)    &#123;        <span class="hljs-keyword">if</span>(str[(i+k)%len]==str[(j+k)%len])            k++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[(i+k)%len]&gt;str[(j+k)%len])   <span class="hljs-comment">//最大表示法这里变成&lt;</span>        &#123;            i=i+k+<span class="hljs-number">1</span>;            k=<span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            j=j+k+<span class="hljs-number">1</span>;            k=<span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span>(i==j)j++;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(i,j);   <span class="hljs-comment">//返回的是第一个最小串的首字符的位置</span>&#125;</code></pre><h5 id="HDU-4513"><a href="#HDU-4513" class="headerlink" title="HDU 4513"></a><strong>HDU 4513</strong></h5><p>题意：求最长回文子串，而外要求:从回文串最中间向两边满足非递增。</p><p>解题思路：改变一下扩展条件即可。</p><pre><code class="hljs c++">        <span class="hljs-keyword">while</span>(anew[i-p[i]]==anew[i+p[i]])<span class="hljs-comment">//扩展</span>        &#123;            <span class="hljs-keyword">if</span>(anew[i-p[i]]!=<span class="hljs-number">-2</span>)            &#123;                <span class="hljs-keyword">if</span>(anew[i+p[i]]&lt;=anew[i+p[i]<span class="hljs-number">-2</span>])p[i]++;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;            &#125;            p[i]++;        &#125;</code></pre><h5 id="HDU-3294"><a href="#HDU-3294" class="headerlink" title="HDU 3294"></a><strong>HDU 3294</strong></h5><p>字符串转化的时候不用刚开始就转化，要判断好回文以后输出的地方再转化，否则会TLE。</p><h5 id="2018年全国多校算法寒假训练营练习比赛（第五场）C"><a href="#2018年全国多校算法寒假训练营练习比赛（第五场）C" class="headerlink" title="2018年全国多校算法寒假训练营练习比赛（第五场）C"></a><strong>2018年全国多校算法寒假训练营练习比赛（第五场）C</strong></h5><p>题意：有一个字符串，让你找到这个字符串 S 里面的子串T，必须满足是这个串的前缀，也是这个串的后缀，并且在字符串中也出现过一次的，输出最长满足要求字符串。</p><p>思路：利用Next数组，next数组表示的是这个串最长的公共前后缀，那么求出这个串所有的公共前后缀就是循环即可，因为最长的公共前后缀是next[len]，那么比它短一点的肯定是在这个前缀的最长前后缀，即next[next[len]]，然后KMP一下如果出现次数大于等于3的话就符合要求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论基础专题</title>
    <link href="/2018/01/26/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98/"/>
    <url>/2018/01/26/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="Lightoj1282"><a href="#Lightoj1282" class="headerlink" title="Lightoj1282 "></a><strong>Lightoj1282 </strong></h5><p>求n^k的前三位的方法：对于给定的一个数n,它可以写成10^a,其中这个a为浮点数，则n^k=(10^a)^k=10^a<em>k=(10^x)</em>(10^y);其中x,y分别是a*k的整数部分和小数部分，对于t=n^k这个数，它的位数由(10^x)决定，它的位数上的值则有(10^y)决定，因此我们要求t的前三位，只需要将10^y求出，在乘以100，就得到了它的前三位。</p><p>fmod(f,(int)f)即可得到小数点后的部分。</p><h5 id="POJ-2115"><a href="#POJ-2115" class="headerlink" title="POJ 2115"></a><strong>POJ 2115</strong></h5><p>题意：for(i=A;i!=B;i+=C){i%(2^k)};问你循环执行几次？</p><p>解题思路：</p><p>(A+s*C)%2^k=B</p><p>(A+s*C)≡B(mod 2^k)</p><p>s<em>C-m</em>2^k=B-A</p><h5 id="LightOj-1341"><a href="#LightOj-1341" class="headerlink" title="LightOj 1341 "></a><strong>LightOj 1341 </strong></h5><p>a&lt;b*b可以剪枝剪掉。</p><h5 id="LightOj-1234"><a href="#LightOj-1234" class="headerlink" title="LightOj 1234"></a><strong>LightOj 1234</strong></h5><p>分组打表。</p><h5 id="LightOj-1336"><a href="#LightOj-1336" class="headerlink" title="LightOj 1336"></a><strong>LightOj 1336</strong></h5><p>考虑奇数+打表找规律。</p><h5 id="LightOj-1213"><a href="#LightOj-1213" class="headerlink" title="LightOj 1213 "></a><strong>LightOj 1213 </strong></h5><p>最内层的加法式子执行了n^K次，每次加了K个数，所以一共加了K<em>n^K个数，一共有n个数，每个数加的次数一定是相同的，所以每个数都加了K</em>n^(K-1)次，所以结果就是Sum<em>K</em>n^(K-1)%mod。</p><h5 id="UVA-11752"><a href="#UVA-11752" class="headerlink" title="UVA 11752"></a><strong>UVA 11752</strong></h5><p>题意：</p><p>如果一个数可以表示成两个或以上的数的幂，就是超级幂；</p><p>例如64 = 8^2 = 4^3;</p><p>求1到2^64-1所有的的超级幂；题目没有输入；</p><p>解题思路：</p><p>所有数的合数（不是素数就是合数）次幂，都是超级幂；</p><p>所以求所有每个数的合数次幂；</p><p>double ceil(double x)：返回大于或者等于指定表达式的最小整数。</p><p>指数上限：int limit=(int)ceil(64*log(2)/log(i))-1;</p><p>unsigned long long输出格式是%llu。</p><h5 id="LightOj-1245"><a href="#LightOj-1245" class="headerlink" title="LightOj 1245"></a><strong>LightOj 1245</strong></h5><p>题意：求f(n)=n/1+n/2…..n/n,其中n/i保留整数。</p><p>解题思路：可以找规律，知道只要枚举到sqrt(n)即可，剩下的得数是连续的，所以算出个数就可以算出f(n)了。</p><h5 id="51nod-1179"><a href="#51nod-1179" class="headerlink" title="51nod 1179"></a><strong>51nod 1179</strong></h5><p>题意：给出N个正整数，找出N个数两两之间最大公约数的最大值(1 &lt;= S[i] &lt;= 1000000)。</p><p>思路：由范围知道可以分解出因子，并且计数，找到最大的cnt[i]&gt;=2的i即为答案。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础DP1专题</title>
    <link href="/2018/01/26/%E5%9F%BA%E7%A1%80DP1%E4%B8%93%E9%A2%98/"/>
    <url>/2018/01/26/%E5%9F%BA%E7%A1%80DP1%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="HDU-1160"><a href="#HDU-1160" class="headerlink" title="HDU 1160 "></a><strong>HDU 1160 </strong></h5><p>很生气的一道题…WA了好久都觉得自己是对的…debug了好久…发现是路径输出的时候发生了错误…本来是用</p><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(y!=<span class="hljs-number">0</span>)&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,m[y].id);    y=pre[y];&#125;</code></pre><p>这样来输出的，结果WA，然后用递归</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;    <span class="hljs-built_in">print</span>(pre[pos]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,m[pos].id);&#125;</code></pre><p>就AC了，不是说没有顺序规定的吗..,在这种条件下讲道理应该是一样的呀…究竟是怎么回事呢….哦…题目有坑…我以为是没有顺序的…其实这个任意一种的意思还是要按顺序的…有毒…题目都不讲清楚…</p><h5 id="HDU-1024"><a href="#HDU-1024" class="headerlink" title="HDU 1024"></a><strong>HDU 1024</strong></h5><p>题意：定一个数组，求其分成m个不相交子段和最大值的问题。</p><pre><code class="hljs markdown">解题思路：设dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]表示前j个元素分成i组的最优解（j分好的组里面）方程为dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]=max&#123;d[<span class="hljs-string">i</span>][<span class="hljs-symbol">j-1</span>]+a[<span class="hljs-string">j</span>],max(dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">k</span>]+a[j])&#125;(i-1<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">=k</span>&lt;=<span class="hljs-string">j-1)</span></span></span><span class="xml">第一种情况是j还在第i组里的最后一个</span><span class="xml">第二种情况是j自成一组，上一组最后一个为k，即第i-1组最大和</span><span class="xml">内存不够，就用滚动数组，观察到max( dp[i-1][k] ) 就是上一组 0....j-1 的最大值。我们可以在每次计算dp[i][j]的时候记录下前j个的最大值 用数组保存下来  下次计算的时候可以用.</span><span class="xml">方程就变成dp[i][j]=max(dp[j-1],pre[j-1])+a[j]。</span></code></pre><p>核心代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> pre[<span class="hljs-number">1000010</span>];<span class="hljs-comment">//存上一层前j个的dp[k]的最大值</span>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)        &#123;            MAX=-INF;            <span class="hljs-keyword">for</span>(j=i;j&lt;=n;j++)   <span class="hljs-comment">//k的左界是i-1</span>            &#123;                dp[j]=<span class="hljs-built_in">max</span>(dp[j<span class="hljs-number">-1</span>],pre[j<span class="hljs-number">-1</span>])+a[j];   <span class="hljs-comment">//k的右界是j-1</span>                pre[j<span class="hljs-number">-1</span>]=MAX;   <span class="hljs-comment">//这一层的前j-1个的dp[k]的最大值</span>                MAX=<span class="hljs-built_in">max</span>(MAX,dp[j]);   <span class="hljs-comment">//把MAX更新一下</span>            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,MAX);</code></pre><h5 id="HDU-1114"><a href="#HDU-1114" class="headerlink" title="HDU 1114"></a><strong>HDU 1114</strong></h5><h5 id="HDU-2859"><a href="#HDU-2859" class="headerlink" title="HDU 2859 "></a><strong>HDU 2859 </strong></h5><p>要注意可能有1*1这种数据…不能把ans初始化为-INF啊…</p><h5 id="HDU-1074"><a href="#HDU-1074" class="headerlink" title="HDU 1074"></a><strong>HDU 1074</strong></h5><p>状态压缩DP。</p><p>位运算在状压DP常见的应用如下：</p><p>1.判断一个数字x二进制下第i位是不是等于1。</p><p>方法：if ( ( ( 1 &lt;&lt; ( i - 1 ) ) &amp; x ) &gt; 0)</p><p>将1左移i-1位，相当于制造了一个只有第i位上是1，其他位上都是0的二进制数。然后与x做与运算，如果结果&gt;0，说明x第i位上是1，反之则是0。</p><p>2.将一个数字x二进制下第i位更改成1。</p><p>方法：x = x | ( 1&lt;&lt;(i-1) )</p><p>3.把一个数字二进制下最靠右的第一个1去掉。</p><p>方法：x=x&amp;(x-1)</p><p>代码及注释：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN (1&lt;&lt;15)+10</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">110</span>];    <span class="hljs-keyword">int</span> limit,actu;&#125;t[<span class="hljs-number">20</span>];<span class="hljs-keyword">int</span> dp[MAXN],Time[MAXN],path[MAXN];<span class="hljs-comment">//dp表示在此状态扣了多少分</span><span class="hljs-comment">//Time表示在此状态用了多少时间</span><span class="hljs-comment">//path表示到达状态i的前驱,为了最后输出完成作业的顺序</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;    output(x-(<span class="hljs-number">1</span>&lt;&lt;path[x]));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>,t[path[x]].name);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T,i,j,n,tot,temp,score;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);    <span class="hljs-keyword">while</span>(T--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s%d%d"</span>,t[i].name,&amp;t[i].limit,&amp;t[i].actu);        <span class="hljs-built_in">memset</span>(Time,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(Time));        <span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>&lt;&lt;n;<span class="hljs-comment">//所有状态</span>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;tot;i++)        &#123;            dp[i]=INF;            <span class="hljs-keyword">for</span>(j=n<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<span class="hljs-comment">//有两门作业完成后分数相同，在这种情况下，起初位于前面的作业位于前面</span>            &#123;                <span class="hljs-keyword">int</span> temp=<span class="hljs-number">1</span>&lt;&lt;j;                <span class="hljs-keyword">if</span>(!(i&amp;temp))<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//第j门没做</span>                <span class="hljs-keyword">int</span> score=Time[i-temp]+t[j].actu-t[j].limit;<span class="hljs-comment">//讲道理也不是很懂为什么是i-temp...</span>                <span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">0</span>)score=<span class="hljs-number">0</span>;                <span class="hljs-keyword">if</span>(dp[i-temp]+score&lt;dp[i])<span class="hljs-comment">//若最后做第j门作业，所扣的分数少于之前的分数</span>                &#123;                    dp[i]=dp[i-temp]+score;<span class="hljs-comment">//作为此状态的最优解</span>                    Time[i]=Time[i-temp]+t[j].actu;<span class="hljs-comment">//到达状态i花费的时间</span>                    path[i]=j;                &#125;            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[tot<span class="hljs-number">-1</span>]);        output(tot<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="POJ-3666"><a href="#POJ-3666" class="headerlink" title="POJ 3666"></a><strong>POJ 3666</strong></h5><p>题意：给出长度为n的整数数列,每次可以将一个数加1或者减1,最少要多少次可以将其变成单调增或者单调减(不严格)。</p><pre><code class="hljs markdown">解题思路：对于某个位置而言，一定改成和他前一个一样，或者和他后一个一样，所以最后形成的序列的数都在原序列里出现过，考虑b数组保存排完序后的原数组值，dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>] = min(dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">k</span>])+a[<span class="hljs-string">i</span>]-b[<span class="hljs-string">j</span>], 1<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">=k</span>&lt;=<span class="hljs-string">j。dp[i</span>=<span class="hljs-string">当前考虑的前i个数][j</span>=<span class="hljs-string">第i个数在总序列中排第j小]</span>=<span class="hljs-string">当前的情况的最小改动量。什么意思呢，就是求当前dp[i][j]时候，考虑前i-1个数字，取第i-1个数字在第k（k</span>=<span class="hljs-string">1…j）小中的最小改动量，再加上第i个数字成为第j小的改动量。</span></span></span></code></pre><h5 id="51nod-1007"><a href="#51nod-1007" class="headerlink" title="51nod 1007"></a><strong>51nod 1007</strong></h5><p>题意：将一堆正整数分为2组，要求2组的和相差最小。<em>**</em></p><p>解题思路：分成两组要相差最小，肯定是一组大于sum/2一组小于sum/2或者两组都是sum/2，就相当于其中一组与sum/2相差最小，然后转化为容量为sum/2的01背包问题即可。</p><h5 id="51nod-1021"><a href="#51nod-1021" class="headerlink" title="51nod 1021"></a><strong>51nod 1021</strong></h5><p>题意：现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。</p><p>解题思路：</p><pre><code class="hljs markdown">dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]：将i到j合并成一堆的最小代价比如i=1,j=4,dp[<span class="hljs-string">1</span>][<span class="hljs-symbol">4</span>]=min(dp[<span class="hljs-string">1</span>][<span class="hljs-symbol">3</span>]+dp[<span class="hljs-string">4</span>][<span class="hljs-symbol">4</span>],dp[<span class="hljs-string">1</span>][<span class="hljs-symbol">2</span>]+dp[<span class="hljs-string">3</span>][<span class="hljs-symbol">4</span>],dp[<span class="hljs-string">1</span>][<span class="hljs-symbol">1</span>]+dp[<span class="hljs-string">2</span>][<span class="hljs-symbol">4</span>])+sum[<span class="hljs-string">1</span>][<span class="hljs-symbol">4</span>];</code></pre><h5 id="51nod-1084"><a href="#51nod-1084" class="headerlink" title="51nod 1084"></a><strong>51nod 1084</strong></h5><p>题意：</p><p>一个M*N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，先从左上走到右下，再从右下走到左上。第1遍时只能向下和向右走，第2遍时只能向上和向左走。两次如果经过同一个格子，则该格子的奖励只计算一次，求能够获得的最大价值。</p><pre><code class="hljs markdown">解题思路：从左上角到右下角再回到左上角，这个过程可以看作从左上角同时走两路到右下角，我们记录两路当前的位置，这样就可以处理“同一个格子的数只能取一次”了。但是如果用dp[<span class="hljs-string">x1</span>][<span class="hljs-symbol">y1</span>][<span class="hljs-string">x2</span>][<span class="hljs-symbol">y2</span>]记录状态，这显然不可以。因为两路是同时走得，到达某一状态，它们走过的步数是相同，而且有了步数和行号就可以确定列号了，因此用dp[<span class="hljs-string">x1</span>][<span class="hljs-symbol">x2</span>][<span class="hljs-string">step</span>]记录状态就可以了。</code></pre><h5 id="51nod-1202"><a href="#51nod-1202" class="headerlink" title="51nod 1202"></a><strong>51nod 1202</strong></h5><p>题意：对于给出序列a，有些子序列可能是相同的，这里只算做1个，请输出a的不同子序列的数量。由于答案比较大，输出Mod 10^9 + 7的结果即可。</p><p>解题思路：假设dp[i]表示前i项形成的子序列（含空）的个数。下标从1开始，初值是dp[0] = 1，对应代表空子序列。我们考虑第i项，如果所有的数都不相等，应该有dp[i] = dp[i – 1] * 2，其实就是考虑把第i个数放到最后或者不放到最后的情况，原来恰好以第j个数结尾的那些被我们算了两次，因为以第j个数结尾可以换成以第i个数结尾是一样的。如何计算出这个数的个数呢？ 其实这个数等于dp[j – 1]，因为前面(j – 1)个数的子序列最后跟上第j个数就可以了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树专题</title>
    <link href="/2018/01/26/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%93%E9%A2%98/"/>
    <url>/2018/01/26/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="Kruskal模板"><a href="#Kruskal模板" class="headerlink" title="Kruskal模板"></a><strong>Kruskal模板</strong></h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> u,v,cost;&#125;eg[<span class="hljs-number">50010</span>];<span class="hljs-keyword">int</span> par[<span class="hljs-number">1010</span>],high[<span class="hljs-number">1010</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(edge x,edge y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x.cost&lt;y.cost;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        par[i]=i;        high[i]=<span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> par[x]=<span class="hljs-built_in">find</span>(par[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    x=<span class="hljs-built_in">find</span>(x);    y=<span class="hljs-built_in">find</span>(y);    <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(high[x]&lt;high[y])par[x]=y;    <span class="hljs-keyword">else</span>    &#123;        par[y]=x;        <span class="hljs-keyword">if</span>(high[x]==high[y])high[x]++;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,i,sum,num;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;m;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;eg[i].u,&amp;eg[i].v,&amp;eg[i].cost);    sort(eg,eg+m,cmp);    init(n);    sum=<span class="hljs-number">0</span>;num=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;m;i++)    &#123;        <span class="hljs-keyword">if</span>(!same(eg[i].u,eg[i].v))        &#123;            unite(eg[i].u,eg[i].v);            sum=sum+eg[i].cost;            num++;        &#125;        <span class="hljs-keyword">if</span>(num==n<span class="hljs-number">-1</span>)<span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,sum);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="Prim优化模板"><a href="#Prim优化模板" class="headerlink" title="Prim优化模板"></a><strong>Prim优化模板</strong></h5><p><a href="http://www.cnblogs.com/yspworld/p/4546098.html" target="_blank" rel="noopener">http://www.cnblogs.com/yspworld/p/4546098.html</a></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to,cost;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(edge x,edge y)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> x.cost&gt;y.cost;    &#125;&#125;;<span class="hljs-built_in">vector</span>&lt;edge&gt;v[<span class="hljs-number">1010</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>,cnt=n<span class="hljs-number">-1</span>;    <span class="hljs-built_in">fill</span>(vis+<span class="hljs-number">1</span>,vis+<span class="hljs-number">1</span>+n,<span class="hljs-literal">false</span>);    priority_queue&lt;edge,<span class="hljs-built_in">vector</span>&lt;edge&gt;,cmp&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>();i++)        q.push(v[<span class="hljs-number">1</span>][i]);   <span class="hljs-comment">//将起点的所有连接边全部加入队列中来</span>    vis[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">while</span>(!q.empty()&amp;&amp;cnt)    &#123;        edge e=q.top();        q.pop();        <span class="hljs-keyword">if</span>(vis[e.to])<span class="hljs-keyword">continue</span>;        ans=ans+e.cost;        cnt--;        vis[e.to]=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[e.to].<span class="hljs-built_in">size</span>();i++)            <span class="hljs-keyword">if</span>(!vis[v[e.to][i].to])                q.push(v[e.to][i]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,m,i,a,b,c;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)        v[i].<span class="hljs-built_in">clear</span>();    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;m;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);        v[a].push_back(edge&#123;b,c&#125;);        v[b].push_back(edge&#123;a,c&#125;);    &#125;    prim();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="POJ-2421"><a href="#POJ-2421" class="headerlink" title="POJ 2421 "></a><strong>POJ 2421 </strong></h5><p>题意：</p><p>​       已经给了一些路，然后让你求其余的。</p><p>解题思路：</p><p>​      用kruskal的时候要注意给出的边是不是成环的，还是得判断一下。</p><h5 id="POJ-1679"><a href="#POJ-1679" class="headerlink" title="POJ 1679 "></a><strong>POJ 1679 </strong></h5><p>题意：</p><p>​       给一个有权值的无向图，判断最小生成树是否唯一。</p><p>解题思路：</p><p>​      求一下次小生成树即可。这里要注意每次生成一个次小生成树的时候要判断是否成功生成。</p><h5 id="ZOJ-1586"><a href="#ZOJ-1586" class="headerlink" title="ZOJ 1586 "></a><strong>ZOJ 1586 </strong></h5><p>题意：</p><p>​       在某个外星球有些叫QS的外星人。他们之间要相互联系。但是要买网络适配器，当然不同的QS喜欢不同价格的适配器。而且还需要买网络电缆，而且都需要费用。让你求用最小的花费去建立他们之间的联系。</p><p>解题思路：</p><p>​       注意不能之后再加适配器的价格，因为这样的话考虑最短路的时候就没有把适配器的价格考虑进去了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集专题</title>
    <link href="/2018/01/26/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%93%E9%A2%98/"/>
    <url>/2018/01/26/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="普通并查集模板"><a href="#普通并查集模板" class="headerlink" title="普通并查集模板"></a><strong>普通并查集模板</strong></h5><pre><code class="hljs c++"><span class="hljs-keyword">int</span> par[<span class="hljs-number">1010</span>],high[<span class="hljs-number">1010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        par[i]=i;        high[i]=<span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> par[x]=<span class="hljs-built_in">find</span>(par[x]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    x=<span class="hljs-built_in">find</span>(x);    y=<span class="hljs-built_in">find</span>(y);    <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(high[x]&lt;high[y])par[x]=y;   <span class="hljs-comment">//启发式合并</span>    <span class="hljs-keyword">else</span>    &#123;        par[y]=x;        <span class="hljs-keyword">if</span>(high[x]==high[y])high[x]++;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);&#125;</code></pre><h5 id="带权并查集模板"><a href="#带权并查集模板" class="headerlink" title="带权并查集模板"></a><strong>带权并查集模板</strong></h5><pre><code class="hljs c++"><span class="hljs-keyword">int</span> par[<span class="hljs-number">10010</span>],high[<span class="hljs-number">10010</span>];<span class="hljs-comment">//保存奇偶</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10010</span>;i++)    &#123;        par[i]=i;        high[i]=<span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">int</span> tmp=par[x];    par[x]=Find(par[x]);    high[x]=(high[x]+high[tmp])%<span class="hljs-number">2</span>;   <span class="hljs-comment">//把沿途子节点的所有父节点的权值处理一下，比如本来high[x]和high[temp]相反，就相反一下</span>    <span class="hljs-keyword">return</span> par[x];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> px=Find(x);    <span class="hljs-keyword">int</span> py=Find(y);    <span class="hljs-keyword">if</span>(px==py)    &#123;        <span class="hljs-keyword">if</span>(high[x]==(high[y]+z)%<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//判断是否符合奇偶</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    par[py]=px;    high[py]=(high[x]-high[y]+z+<span class="hljs-number">2</span>)%<span class="hljs-number">2</span>;   <span class="hljs-comment">//可能是负的，所以要+2</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> Find(x)==Find(y);&#125;</code></pre><h5 id="HDU-1213"><a href="#HDU-1213" class="headerlink" title="HDU 1213"></a><strong>HDU 1213</strong></h5><p>为啥用set就错了???</p><h5 id="POJ-1182"><a href="#POJ-1182" class="headerlink" title="POJ 1182"></a><strong>POJ 1182</strong></h5><p>题意：</p><p>​       三类动物A、B、C构成食物链循环，告诉两个动物的关系（同类或天敌），判断那个关系是和前面已有的冲突。</p><p>解题思路：</p><p>​       对于每只动物i创建3个元素i-A, i-B, i-C, 并用这3*N个元素建立并查集。这个并查集维护如下信息：对于1，合并x-A和y-A、x-B和y-B、x-C和y-C；对于2，合并x-A和y-B、x-B和y-C、x-C和y-A。不过在合并之前需要先判断合并是否会产生矛盾。例如在第一种信息的情况下，需要检查比如x-A和y-B或者y-C是否在同一组等信息。</p><h5 id="POJ-1308"><a href="#POJ-1308" class="headerlink" title="POJ 1308"></a><strong>POJ 1308</strong></h5><p>题意：</p><p>​       判断有向图是否成树。</p><p>解题思路：</p><p>​      成树的条件：不能有环（只要判断x,y的根是否是同一个即可），顶点数=边数-1，每个顶点的入度&lt;=1，自己不能指向自己。</p><h5 id="HDU-3038"><a href="#HDU-3038" class="headerlink" title="HDU 3038"></a><strong>HDU 3038</strong></h5><p>题意：</p><p>​       有n次询问，给出a到b区间的总和，问这n次给出的总和中有几次是和前面已近给出的是矛盾的。</p><p>解题思路：</p><p>​       带权并查集。<a href="http://blog.csdn.net/Yonggie/article/details/76885820。对于A~B之间的和是S，其实可以理解成B比A-1大S，然后并查集，rank[i]来记录每个点到根的相对深度，这里find函数就要变一变了。" target="_blank" rel="noopener">http://blog.csdn.net/Yonggie/article/details/76885820。对于A~B之间的和是S，其实可以理解成B比A-1大S，然后并查集，rank[i]来记录每个点到根的相对深度，这里find函数就要变一变了。</a></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(par[x]==x)<span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">int</span> tmp=par[x];    par[x]=<span class="hljs-built_in">find</span>(par[x]);    high[x]=high[x]+high[tmp];   <span class="hljs-comment">//把沿途子节点的所有父节点的权值都加上</span>    <span class="hljs-keyword">return</span> par[x];&#125;因为要知道每个点到根的距离，所以可以路径压缩。合并点的时候如果同个根的话就判断一下，其他就合并一下，把右边的树的根向左边树的根连边，更新一下根的相关标记就可以了。<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> z)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> px=<span class="hljs-built_in">find</span>(x);    <span class="hljs-keyword">int</span> py=<span class="hljs-built_in">find</span>(y);    <span class="hljs-keyword">if</span>(px==py)    &#123;        <span class="hljs-keyword">if</span>(high[x]+z==high[y])<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    par[py]=px;    high[py]=high[x]-high[y]+z;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="POJ-1733"><a href="#POJ-1733" class="headerlink" title="POJ 1733"></a><strong>POJ 1733</strong></h5><p>题意：</p><p>​       给一个序列这个序列都是由0和1组成，现在随意拿出来一个序列，然后说出他的和是奇数还是偶数，因为有可能存在假话，让你判断前多少条没有假话，也就是查找第一个假话的位置-1。</p><p>解题思路：</p><p>​       带权并查集+离散化。带权部分和上题相似。在unite的时候判断是否符合奇偶利用奇偶性，在更新连过去的根的high[i]的时候，因为high[py]=(high[x]-high[y]+z+2)%2;，括号里面可能是负的，所以要+2，find函数中high[x]=(high[x]+high[tmp])%2;（把沿途子节点的所有父节点的权值处理一下，比如本来high[x]和high[temp]相反，就相反一下）。离散化部分可以用map来映射一下，key存该数字，value存下标（注意后面是mp[a]==0所以下标从1开始）。</p><p>还是把草稿纸拍下来比较清楚吧www</p><p><img src="http://imglf1.nosdn.127.net/img/ajhrcUFValVhVzdCV2kyQTU1ZXJtWHBuVDE1eVVZQ3c5RlZ1N2NydE1JWExRYXRzNGMyNkxRPT0.png?=imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2" srcset="/img/loading.gif" alt="img"></p><h5 id="POJ-1456"><a href="#POJ-1456" class="headerlink" title="POJ 1456 "></a><strong>POJ 1456 </strong></h5><p>题意：</p><p>​       有N件商品，知道了商品的价值和销售的最后期限，只要在最后日期之前销售处，就能得到相应的利润，并且销售该商品需要1天时间，求出最大利润。</p><p>解题思路：</p><p>​       直接贪心就可以水过，但是这里可以用并查集优化，优化的是先把所有产品按照利润从大到小排序，然后看截止日期这种情况，par[i]里面放截止日期，如果这个截止日期被占用了的话，就往前推，表示如果再有截止日期为这个日期的物品的话，这个物品找根的时候就是日期往前推，par[i]=i-1，对于每一个p[i].t，先找一下它的根，如果根&gt;0的话，就说明可以用。</p><p><strong>POJ 2912</strong> </p><p>题意：</p><p>​       给出n个人玩剪刀石头布的游戏，其中有一个人是裁判，剩下的人分为3组，每一组的人只出某一种手型，裁判可以任意出。问是否能判断出哪个人是裁判。</p><p>解题思路：</p><p>​       食物链的做法就可以了，这里要判断裁判，就枚举每一个人，与他相关的局数就跳过去，如果这个人是裁判的时候没有出错的话，就说明这个人可能是裁判了，如果有多种裁判情况的话，就输出Can not determine；如果没有裁判的话，输出Impossible；只有一个裁判的话，就输出其他所有的出错局数最大的。</p><h5 id="ZOJ-3261"><a href="#ZOJ-3261" class="headerlink" title="ZOJ 3261 "></a><strong>ZOJ 3261 </strong></h5><p>题意：</p><p>​       有一些点，还有一些边，每个点上都有一个权值，然后有一些询问，分为两种，query a 询问与a直接或者间接想连的点中最大权值的是那个点，输出那个点，如果那个点的权值小于等于a的权值，那么就输出-1，还有另一种操作就是destroy a b意思是删除a b的关系。</p><p>解题思路：</p><p>​       并查集不能实现删边操作，所以就倒着来，先删掉所有该删的边之后，倒着来回答问题，如果遇到删边的话，就添边即可。</p><h5 id="POJ-1984"><a href="#POJ-1984" class="headerlink" title="POJ 1984"></a><strong>POJ 1984</strong></h5><p>题意：</p><p>​       有多个点，在平面上位于坐标点上，给出一些关系，表示某个点在某个点的正东/西/南/北方向多少距离，然后给出一系列询问，表示在第几个关系给出后询问某两点的曼哈顿距离，或者未知则输出-1。</p><p>解题思路：</p><p>​      带权并查集。跟之前的题目都差不多，只不过变成二维的了。</p><p><img src="http://imglf0.nosdn.127.net/img/ajhrcUFValVhVzdFYjdsb1k1VnF4UXd4d0hMTWxJQUlYUEdSY21hSXluM2gyZHh6TCticU1RPT0.png?=imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2" srcset="/img/loading.gif" alt="img"><strong>POJ 1417 </strong></p><p>题意：</p><p>​        有这么一群人，一群好人，和一群坏人，好人永远会说实话，坏人永远说假话，现在给你一组对话和好人与坏人的数目P1， P2。数据里面的no是A说B是坏人， yes代表A说B是好人，就是这样，问题能不能从这些话里面得出来唯一的解，就是可以确定谁是好人谁是坏人，如果不能输出no，如果可以输出所有的好人。</p><p>解题思路：</p><pre><code class="hljs markdown">如果两个人是yes的话，就说明是同类，如果两个人是no的话，说明不是同类，用带权并查集合并（这样相对于只有同类合并会少几个集合），然后判断是否唯一，每个集合又分成两个小集合表示两种类型的个数，而我们要求的是在所有大集合中选出一个小集合然后加起来看能不能组 合成p1，并且要唯一，这里我们可以想到用背包来做，dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]表示前i个大集合好人为j个的方案数，第i种状态只能由第i-1种状态而来，我们用w0[<span class="hljs-string">i</span>],w1[<span class="hljs-string">i</span>]表示第i个集合两个小集合的个数 ，所以dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]可以由dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">j-w0[</span>]i]和dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">j-w1[i</span>]]得来，这样我们只需判断dp[<span class="hljs-string">cnt</span>][<span class="hljs-symbol">p1</span>]是否等于1，这题还有麻烦的就是输出好人的编号，这里我们可以利用边的权值，w0存的全是权值为0的，w1存的全是权值为1的，然后最后只需判断下第i个集合是由w0还是w1组合而来，这里可以利用dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">p1-w0[i</span>]]的值来判断，如果等于1则表示是由w0组合否则就是w1，dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">p1-w0[i</span>]]==1可以得到dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">p1</span>]==1，因为这里已经表示答案唯一，所以只有一种情况！</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路专题</title>
    <link href="/2018/01/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B8%93%E9%A2%98/"/>
    <url>/2018/01/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="Dijkstra模板"><a href="#Dijkstra模板" class="headerlink" title="Dijkstra模板"></a><strong>Dijkstra模板</strong></h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to,cost;&#125;;<span class="hljs-built_in">vector</span>&lt;edge&gt;v[<span class="hljs-number">1010</span>];<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;p;<span class="hljs-keyword">int</span> dis[<span class="hljs-number">1010</span>];<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">fill</span>(dis+<span class="hljs-number">1</span>,dis+n+<span class="hljs-number">1</span>,INF);    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    priority_queue&lt;p,<span class="hljs-built_in">vector</span>&lt;p&gt;,greater&lt;p&gt; &gt;q;    q.push(p(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        p temp=q.top();        q.pop();        <span class="hljs-keyword">int</span> w=temp.first;<span class="hljs-keyword">int</span> id=temp.second;        <span class="hljs-keyword">if</span>(w&gt;dis[id])<span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)        &#123;            edge &amp;e=v[id][i];            <span class="hljs-keyword">if</span>(w+e.cost&lt;dis[e.to])            &#123;                dis[e.to]=w+e.cost;                q.push(p(dis[e.to],e.to));            &#125;        &#125;    &#125;&#125;</code></pre><h5 id="floyd模板"><a href="#floyd模板" class="headerlink" title="floyd模板"></a><strong>floyd模板</strong></h5><pre><code class="hljs matlab"><span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=n;k++)    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>;<span class="hljs-built_in">i</span>&lt;=n;<span class="hljs-built_in">i</span>++)    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>;<span class="hljs-built_in">j</span>&lt;=n;<span class="hljs-built_in">j</span>++)    dis[<span class="hljs-built_in">i</span>][<span class="hljs-built_in">j</span>]=dis[<span class="hljs-built_in">i</span>][<span class="hljs-built_in">j</span>]||(dis[<span class="hljs-built_in">i</span>][k]&amp;&amp;dis[k][<span class="hljs-built_in">j</span>]);</code></pre><h5 id="spfa模板"><a href="#spfa模板" class="headerlink" title="spfa模板"></a><strong>spfa模板</strong></h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cost;&#125;;<span class="hljs-built_in">vector</span>&lt;edge&gt;v[<span class="hljs-number">2510</span>];<span class="hljs-keyword">double</span> dis[<span class="hljs-number">2510</span>];<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">2510</span>];<span class="hljs-keyword">int</span> cnt[<span class="hljs-number">2510</span>];<span class="hljs-keyword">int</span> n,tp;<span class="hljs-keyword">double</span> w;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">fill</span>(dis+<span class="hljs-number">1</span>,dis+<span class="hljs-number">1</span>+n,INF);    <span class="hljs-built_in">fill</span>(vis+<span class="hljs-number">1</span>,vis+<span class="hljs-number">1</span>+n,<span class="hljs-literal">false</span>);    <span class="hljs-built_in">fill</span>(cnt+<span class="hljs-number">1</span>,cnt+<span class="hljs-number">1</span>+n,<span class="hljs-number">0</span>);    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;q.push(<span class="hljs-number">1</span>);    vis[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;cnt[<span class="hljs-number">1</span>]++;    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        tp=q.front();vis[tp]=<span class="hljs-literal">false</span>;        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[tp].<span class="hljs-built_in">size</span>();i++)        &#123;            edge &amp;e=v[tp][i];            <span class="hljs-keyword">if</span>(dis[tp]+e.cost&lt;dis[e.to])            &#123;                dis[e.to]=dis[tp]+e.cost;                <span class="hljs-keyword">if</span>(!vis[e.to])                &#123;                   q.push(e.to);                   vis[e.to]=<span class="hljs-literal">true</span>;                   cnt[e.to]++;                   <span class="hljs-keyword">if</span>(cnt[e.to]&gt;n)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">//判断负环</span>                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><h5 id="POJ-2253"><a href="#POJ-2253" class="headerlink" title="POJ 2253"></a><strong>POJ 2253</strong></h5><p>题意：</p><p>​      有两只青蛙和若干块石头，现在已知这些东西的坐标，两只青蛙A坐标和青蛙B坐标是第一个和第二个坐标，现在A青蛙想要到B青蛙那里去，并且A青蛙可以借助任意石头的跳跃，而从A到B有若干通路，问从A到B的所有通路上的最大边。</p><p>解题思路：</p><p>​      求所有通路中间最长的一段路的最小值，让dis[i]存从1到i的最长的一段路，然后max(dis[id],e.cost)&lt;dis[e.to]更新即可。</p><h5 id="POJ-1797"><a href="#POJ-1797" class="headerlink" title="POJ 1797 "></a><strong>POJ 1797 </strong></h5><p>题意：</p><p>​       找一条从 1 到 n 的道路，使得这条道路的每段距离中的最小值最大。</p><p>解题思路：</p><p>​       求所有通路中间最短的一段路的最大值，让dis[i]存从1到i的最短的一段路，然后min(dis[id],e.cost)&gt;dis[e.to]更新即可。</p><h5 id="POJ-3268"><a href="#POJ-3268" class="headerlink" title="POJ 3268"></a><strong>POJ 3268</strong></h5><p>题意：</p><p>​       有编号为1－N的牛，它们之间存在一些单向的路径。给定一头牛的编号，其他牛要去拜访它并且拜访完之后要返回自己原来的位置，求这些牛中所花的最长的来回时间是多少。</p><p>解题思路：</p><p>​       返回的最短路直接把原来的出边变成入边再dijkstra一次即可。</p><h5 id="POJ-3660"><a href="#POJ-3660" class="headerlink" title="POJ 3660"></a><strong>POJ 3660</strong></h5><p>题意：</p><p>​       有n头牛比赛，m种比赛结果，最后问你一共有多少头牛的排名被确定了，其中如果a战胜b，b战胜c，则也可以说a战胜c，即可以传递胜负。求能确定排名的牛的数目。</p><p>解题思路：</p><p>​      传递闭包再根据出度+入度即可。</p><h5 id="POJ-1860"><a href="#POJ-1860" class="headerlink" title="POJ 1860"></a><strong>POJ 1860</strong></h5><p>题意：</p><p>​       给定N种货币，某些货币之间可以相互兑换，现在给定一些兑换规则，问能否从某一种货币开始兑换，经过一些中间货币之后，最后兑换回这种货币，并且得到的钱比之前的多。</p><p>解题思路：</p><p>​       判断有没有正权回路，如果有正权回路的话会一直循环下去，就相当于最短路里面判断有没有负权回路，dis[i]里面装可以换的钱，如果松弛成功（钱变多了）就更新，spfa计数判断某个点进入队列的次数超过n次就有正权回路。</p><h5 id="POJ-3159"><a href="#POJ-3159" class="headerlink" title="POJ 3159"></a><strong>POJ 3159</strong></h5><p>题意：</p><p>​      给n个人分糖果，m组数据a，b，c；意思是a比b少的糖果个数绝对不超过c个，也就是d(b)-d(a) &lt; c，求1比n少的糖果数的最大值。</p><p>解题思路：</p><p>​      差分约束，因为要使dis[B]&lt;dis[A]+e.cost，所以修改一下松弛条件dis[id]+e.cost&lt;dis[e.to]即可（因为刚开始初始化的dis[e.to]是INF，所以松弛要使它变小）。</p><p>给出一些形如x-y&lt;=b不等式的约束，问你是否满足有解的问题，这类问题可以转换成图论里的最短路径问题。</p><pre><code class="hljs markdown">在单源最短路径的算法中有一步是“若d[<span class="hljs-string">v</span>] &gt; d[<span class="hljs-string">u</span>]+cost[<span class="hljs-string">u</span>][<span class="hljs-symbol">v</span>]，则d[<span class="hljs-string">v</span>]= d[<span class="hljs-string">u</span>] + cost[<span class="hljs-string">u</span>][<span class="hljs-symbol">v</span>]，这样就满足d[<span class="hljs-string">v</span>]-d[<span class="hljs-string">u</span>]<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">=cost[u][v]”。</span></span></span></code></pre><p>如此，如果要求最大值，把每个不等式变为标准x-y&lt;=k的形式，然后建立一条从y到x的权值为k的边，求出最短路径即可；</p><p>如果要求最小值，把每个不等式变为标准x-y&gt;=k的形式，然后建立一条从y到x的权值为k的边，求出最长路径即可；</p><p>注意：x-y&lt;k,x-y&lt;=k-1，大于同理；一般题目中除了明面上的约束，还会有一些隐藏的约束；由于差分约束系统常出现负权，故一般用SPFA；如果存在负环，则此约束系统不存在。</p><p>这里直接spfa会超时…说是要手写stack…用dijkstra+priority_queue也可，不过要用链式向前星来存储边。</p><p>链式向前星：<a href="http://blog.csdn.net/acdreamers/article/details/16902023" target="_blank" rel="noopener">http://blog.csdn.net/acdreamers/article/details/16902023</a></p><p>结构体：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> to;    <span class="hljs-keyword">int</span> cost;    <span class="hljs-keyword">int</span> next;&#125;eg[<span class="hljs-number">150010</span>];head[]数组一般初始化为<span class="hljs-number">-1</span>,对于加边的add函数是这样的:<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    eg[top].cost=c;    eg[top].to=b;    eg[top].next=head[a];    head[a]=top++;&#125;</code></pre><p>遍历时：</p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)</code></pre><h5 id="POJ-1062"><a href="#POJ-1062" class="headerlink" title="POJ 1062"></a><strong>POJ 1062</strong></h5><p>题意：</p><p>​       有N个物品，每个物品都有自己的价格，但同时某些物品也可以由其他的（可能不止一个）替代品，这些替代品的价格比较“优惠”，问怎么样选取可以让你的花费最少来购买到物品1。</p><p>解题思路：</p><p>​       建图只要设立一个原点即可，这里要注意题目条件是连间接接触都不行的，所以要枚举范围，而不是直接判断相邻的。</p><h5 id="LightOJ-1074"><a href="#LightOJ-1074" class="headerlink" title="LightOJ 1074"></a><strong>LightOJ 1074</strong></h5><p>题意：</p><p>​       给定每条街的拥挤度p(x)，街a到街b的时间就是(p(b)-p(a))*3，求第一个点到第k个点的最短路，若无法到达或结果小于3，输出’?’。</p><p>解题思路：</p><p>​       这里可能会出现负环的情况…这样的话while(!q.empty())会停不下来，判断个负环，然后dfs标记所有负环上的点，注意while(!q.empty())里面不要忘了if(cir[i])continue;</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>   <span class="hljs-comment">//dfs标记环上的点</span></span><span class="hljs-function"></span>&#123;    cir[x]=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[x].<span class="hljs-built_in">size</span>();i++)        <span class="hljs-keyword">if</span>(!cir[v[x][i].to])            dfs(v[x][i].to);&#125;</code></pre><h5 id="HDU-4725"><a href="#HDU-4725" class="headerlink" title="HDU 4725"></a><strong>HDU 4725</strong></h5><p>题意：</p><p>​       每个点放在一层，然后给了n个点，相邻的两层距离是固定的t，有额外m条边，然后求1到n的最短路径，如果没有则输出-1。</p><p>解题思路：</p><p>​       难点在于建图。要将层抽象出来成为n个点（对应编号依次为n+1~n+n），然后层与层建边，点与点建边，层与在该层上的点建边（边长为0）（这时只要考虑该层进入这个点），点与相邻层建边（边长为c）（这时只要考虑从点出去），spfa+vector会TLE，用dijkstra+vector，或者spfa+链式前向星。</p><h5 id="POJ-3169"><a href="#POJ-3169" class="headerlink" title="POJ 3169 "></a><strong>POJ 3169 </strong></h5><p>题意：</p><p>​       一些母牛按序号排成一条直线。有两种要求，A和B距离不得超过X，还有一种是C和D距离不得少于Y，问可能的最大距离。如果没有输出-1，如果可以随便排输出-2，否则输出最大的距离。</p><p>解题思路：</p><p>​       差分约束。根据题目可得三个要求：s[i+1]-s[i]&gt;=0;s[B]-s[A]&lt;=D(ML);s[B]-s[A]&gt;=D(MD)。看s[B]-s[A]&lt;=D这个条件，因为最开始dis[i]初始化为INF，所以if(s[A]+D&lt;s[B])s[B]=s[A]+D，是不是觉得这个条件很眼熟？就是最短路松弛的条件呀…所以就是最短路啦…也就是题目要求的最长…建边即可(A,B,D)，这样子一来，也可以把其他条件变一变，也可以变成这个样子来建边，s[A]-s[B]&lt;=-D，建边(B,A,-D)，s[i]-s[i+1]&lt;=0，建边(i+1,i,0)，建好图就跑一下spfa。如果出现负环，则说明无解，因为可以一直松弛下去，如果dis[i]==INF，就相当于1到i不连通，没有约束，则说明可以是任意解。</p><h5 id="POJ-4370"><a href="#POJ-4370" class="headerlink" title="POJ 4370 "></a><strong>POJ 4370 </strong></h5><p>题意：</p><p>​       一个n*n的01矩阵，满足以下条件</p><p>X12+X13+…X1n=1<br>X1n+X2n+…Xn-1n=1<br>for each i (1&lt;i&lt;n), satisfies ∑Xki (1&lt;=k&lt;=n)=∑Xij (1&lt;=j&lt;=n).</p><p>另给出一个矩阵C，求∑Cij*Xij(1&lt;=i,j&lt;=n)的最小值。</p><p>解题思路：</p><p>​       每个Xij都可以看做是一条路，X12+X13+……+X1n=1说明1的出度是1，X1n+X2n+……+Xn-1n=1说明n的入度是1，Xki(1&lt;=k&lt;=n) = Xij(1&lt;=j&lt;=n)说明其他点的入度等于出度，定一个超级原点和一个超级汇点，Xij=1的就是要选的那条路，这里跑一下1~n的最短路即可，但是，还要考虑一种情况，题没有说1的入度和n的出度情况，所以，可能存在1号点经过其它点成环，n号点经过其它点成环，这两个环的花费之和的情况，那么怎么求1或者n的最小花费环呢？可以直接搜索，也可以在跑最短路的时候先别把起始点入队，把起始点连接的所有点入队，这样跑完之后，到起始点的最短距离就是最小环了。</p><p>最短路中dijkstra最终所有最短路走的边，可以根据每次标记d[i]:这个点紧连的那条边的编号来得到。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索专题</title>
    <link href="/2018/01/26/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/"/>
    <url>/2018/01/26/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>不要忘记更新vis呀…不更新会TLE…</p><p>找KFC那道不要对每一个KFC都bfs一遍…直接一遍bfs标出到每个位置的最少步数就好了…</p><p>fire那道要注意看清题目是多起点…让fire先跑一遍bfs标记好vis数组就好了…vis里面装fire到这里的时间…</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 6170 正则表达式</title>
    <link href="/2018/01/26/HDU-6170-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2018/01/26/HDU-6170-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><em>：匹配前面的子表达式零次或多次。要匹配 </em> 字符，请使用 *。</p><p>.：匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</p><p>注意.*这种情况要特殊处理一下即可。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">std</span>::ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> t;    <span class="hljs-built_in">cin</span>&gt;&gt;t;    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">string</span> a,b;        <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;        b=regex_replace(b,regex(<span class="hljs-string">"\\.\\*"</span>),<span class="hljs-string">"(.)\\1*"</span>);        <span class="hljs-keyword">if</span>(regex_match(a,regex(b)))<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"yes"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"no"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nbuoj 2704 贪心吃法</title>
    <link href="/2018/01/26/nbuoj-2704-%E8%B4%AA%E5%BF%83%E5%90%83%E6%B3%95/"/>
    <url>/2018/01/26/nbuoj-2704-%E8%B4%AA%E5%BF%83%E5%90%83%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>加工生产调度的贪心…用到了johnson算法…</p><p><a href="https://wenku.baidu.com/view/9c31776727d3240c8447ef42.html###" target="_blank" rel="noopener">https://wenku.baidu.com/view/9c31776727d3240c8447ef42.html###</a></p><p>策略是这样子的…不知道为什么…</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包相关</title>
    <link href="/2018/01/26/%E8%83%8C%E5%8C%85%E7%9B%B8%E5%85%B3/"/>
    <url>/2018/01/26/%E8%83%8C%E5%8C%85%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/tinyguyyy/article/details/51203935" target="_blank" rel="noopener">http://blog.csdn.net/tinyguyyy/article/details/51203935</a></p><h5 id="0-1背包的滚动数组优化"><a href="#0-1背包的滚动数组优化" class="headerlink" title="0-1背包的滚动数组优化"></a><strong>0-1背包的滚动数组优化</strong></h5><pre><code class="hljs markdown">每一次c[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]改变的值只与c[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">x</span>] &#123;x:1...j&#125;有关c[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">x</span>]是前一次i循环保存下来的值，因此，可以将c缩减成一维数组，可以把二维数组变成一维数组减少内存。</code></pre><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=num;i++)  <span class="hljs-keyword">for</span>(j=w;j&gt;=d[i].wi;j--)      dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-d[i].wi]+d[i].pi);</code></pre><pre><code class="hljs markdown">状态转移方程转换为 c[j] = max(c[j], c[j-w[i]]+v[i]);并且，我们注意到状态转移方程，每一次推导c[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]是通过c[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">j-w[i</span>]]来推导的，而不是通过c[<span class="hljs-string">i</span>][<span class="hljs-symbol">j-w[i</span>]]（所以完全背包是从小到大的）因此，j的扫描顺序应该改成从大到小否则，第i次求c数组，必然先求的c[<span class="hljs-string">j-w[i</span>]]的值(即c[<span class="hljs-string">i</span>][<span class="hljs-symbol">j-w[i</span>]])，再求c[<span class="hljs-string">j</span>](<span class="hljs-link">即c[i][j]</span>)的值由于j递增,那么状态方程就成为下面这个样子了c[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>] = max(c[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">j</span>], c[<span class="hljs-string">i</span>][<span class="hljs-symbol">j-w[i</span>]]+v[i])显然不符合题意</code></pre><h5 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a><strong>多重背包问题</strong></h5><p>前两种方法就不多说啦…<br>第三种二进制优化方法：<br>我们试试看，比如Ci  = 14，我们可以把它化成如下4个物品：<br>重量是Wi，体积是Vi<br>重量是2 <em> Wi , 体积是2 </em> Vi<br>重量是4 <em> Wi , 体积是4 </em> Vi<br>重量是7 <em> Wi , 体积是7 </em> Vi<br>注意最后我们最后我们不能取，重量是8 <em> Wi , 体积是8 </em> Vi 因为那样总的个数是1 ＋ 2 ＋ 4 ＋ 8 ＝ 15个了，我们不能多取对吧？<br>我们用这4个物品代替原来的14个物品，大家可以试试原来物品无论取多少个，重量和体积都可以靠我们这几个物品凑出来，这说明我们这种分配方式和原来是等价的。</p><p>这样就可以把问题转化为0-1背包问题了…</p><p>那为什么是等效的呢？？？</p><p> 其实还有更快的方法…从Ci/2开始循环，那样循环的次数就少了。 </p><h5 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a><strong>完全背包问题</strong></h5><p><strong><img src="http://imglf4.nosdn.127.net/img/ajhrcUFValVhVzZ6SzhHV2JOWi9pM3V6dFJQV0lJOFczSVpYN0pDdmUwc3N0S3dSYzlvRjN3PT0.png?=imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2" srcset="/img/loading.gif" alt="img"></strong></p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;=m;j++)<span class="hljs-keyword">if</span>(j&gt;=need[i])dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j-need[i]]+value[i]);<span class="hljs-keyword">else</span> dp[i][j]=dp[i<span class="hljs-number">-1</span>][j];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=need[i];j&lt;=m;j++)dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-need[i]]+value[i]);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数</title>
    <link href="/2018/01/26/%E5%A4%A7%E6%95%B0/"/>
    <url>/2018/01/26/%E5%A4%A7%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>大数问题总是写不对…可以说是很弱了…</p><p>讲讲要怎么写吧…</p><p>加法的话：</p><p>还是把字符串化成数组吧…纯字符串做真的…</p><p>限定一个最大长度 然后就去掉前导零…进位的时候直接i+1加加就可以了不要再用c啦…还有注意数组的清零咯w</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1183 编辑距离</title>
    <link href="/2018/01/26/51nod-1183-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2018/01/26/51nod-1183-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p>DP…这里只是求编辑距离，有时候可能还要回溯找到发生了什么…</p><pre><code class="hljs markdown">DP...这里只是求编辑距离，有时候可能还要回溯找到发生了什么...令f[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]表示a串前i个，b串前j个的编辑距离状态转移：若a串第i个与b串第j个相等，那么f[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]=f[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">j-1</span>]否则，f[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]可由3个状态转移而来：①f[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">j-1</span>]+ f(i, j) 当第一个字符串的第i个字符不等于第二个字符串的第j个字符时，f(i, j) = 1；否则，f(i, j) = 0。②f[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">j</span>]+1 删去a[i]，等价于在b[j]后插入a[i]（删除就相当于插入了）③f[<span class="hljs-string">i</span>][<span class="hljs-symbol">j-1</span>]+1 删去b[j]，等价于在a[i]后插入b[j]初始化:f[<span class="hljs-string">0</span>][<span class="hljs-symbol">i</span>]=i  f[<span class="hljs-string">i</span>][<span class="hljs-symbol">0</span>]=i</code></pre><pre><code class="hljs c++"><span class="hljs-keyword">int</span> dp[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> a[<span class="hljs-number">1010</span>],b[<span class="hljs-number">1010</span>];    <span class="hljs-keyword">int</span> i,j;    gets(a);gets(b);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-built_in">strlen</span>(a);i++)    dp[i][<span class="hljs-number">0</span>]=i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-built_in">strlen</span>(b);i++)    dp[<span class="hljs-number">0</span>][i]=i;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">strlen</span>(a);i++)    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-built_in">strlen</span>(b);j++)    <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>]==b[j<span class="hljs-number">-1</span>])dp[i][j]=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>,dp[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>),dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]);     <span class="hljs-comment">//这里注意a[i-1],a是从0开始的 </span>    <span class="hljs-keyword">else</span> dp[i][j]=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>,dp[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>),dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[<span class="hljs-built_in">strlen</span>(a)][<span class="hljs-built_in">strlen</span>(b)]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1134 最长递增子序列</title>
    <link href="/2018/01/26/51nod-1134-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2018/01/26/51nod-1134-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>用了O(n^2)的方法会超时…<br>所以学习了另一种O(nlogn)的方法：</p><p>纯说一些东西有点抽象，所以还是举个栗子：</p><p>定义d[k]:长度为k的上升子序列的最末元素，若有多个长度为k的上升子序列，则记录最小的那个最末元素。</p><p>举例：原序列为1，5，8，3，6，7</p><p>栈为1，5，8，此时读到3，用3替换5，得到1，3，8； 再读6，用6替换8，得到1，3，6；再读7，得到最终栈为1，3，6，7。最长递增子序列为长度4。</p><p>找位置的时候就可以用到二分啦…</p><p>这里还用到了lower_bound函数(从已经排好序的的序列a中利用二分搜索找出指向满足ai&gt;=k的最小的指针。类似的函数还有upper_bound，这一函数求出的是指向ai&gt;k的ai的最小的指针。长度为n的有序数组a中k的个数，可以用upper_bound(a,a+n,k)-lower_bound(a,a+n,k)求出)</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><span class="hljs-keyword">int</span> a[<span class="hljs-number">50100</span>];<span class="hljs-keyword">int</span> dp[<span class="hljs-number">50100</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,i,loc,len;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);    <span class="hljs-built_in">fill</span>(dp,dp+n,INF);    len=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        loc=lower_bound(dp,dp+len,a[i])-dp;        dp[loc]=a[i];        <span class="hljs-keyword">if</span>(loc==len)len++;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,len);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态压缩dp</title>
    <link href="/2018/01/26/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/"/>
    <url>/2018/01/26/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/</url>
    
    <content type="html"><![CDATA[<p>状压dp也是以前的坑了…填坑ing…</p><h5 id="在状压dp中位运算的常见应用"><a href="#在状压dp中位运算的常见应用" class="headerlink" title="在状压dp中位运算的常见应用"></a><strong>在状压dp中位运算的常见应用</strong></h5><p>1.判断一个数字x二进制下第i位是不是等于1。</p><p>方法：x&amp;(1&lt;&lt;(i-1))</p><p>将1左移i-1位，相当于制造了一个只有第i位上是1，其他位上都是0的二进制数。然后与x做与运算，如果结果&gt;0，说明x第i位上是1，反之则是0。</p><p>2.将一个数字x二进制下第i位更改成1。</p><p>方法：x=x|(1&lt;&lt;(i-1))</p><p>证明方法与1类似，此处不再重复证明。</p><p>3.把一个数字二进制下最靠右的第一个1去掉。</p><p>方法：x=x&amp;(x-1)</p><p>4.把一个数字二进制下第i位置0</p><p>方法：x=x&amp;~(1&lt;&lt;(i-1))</p><div class="table-container"><table><thead><tr><th>功能</th><th>示例</th><th>位运算</th></tr></thead><tbody><tr><td>去掉最后一位</td><td>(101101-&gt;10110)</td><td>x&gt;&gt;1</td></tr><tr><td>在最后加一个0</td><td>(101101-&gt;1011010)</td><td>x&lt;&lt;1</td></tr><tr><td>在最后加一个1</td><td>(101101-&gt;1011011)</td><td>x&lt;&lt;1+1</td></tr><tr><td>把最后一位变成1</td><td>(101100-&gt;101101)</td><td>x\</td><td>1</td></tr><tr><td>把最后一位变成0</td><td>(101101-&gt;101100)</td><td>x\</td><td>1-1</td></tr><tr><td>最后一位取反</td><td>(101101-&gt;101100)</td><td>x^1</td></tr><tr><td>把右数第k位变成1</td><td>(101001-&gt;101101,k=3)</td><td>x\</td><td>(1&lt;&lt;(k-1))</td></tr><tr><td>把右数第k位变成0</td><td>(101101-&gt;101001,k=3)</td><td>x&amp;~(1&lt;&lt;(k-1))</td></tr><tr><td>右数第k位取反</td><td>(101001-&gt;101101,k=3)</td><td>x^(1&lt;&lt;(k-1))</td></tr><tr><td>取末三位</td><td>(1101101-&gt;101)</td><td>x&amp;7</td></tr><tr><td>取末k位</td><td>(1101101-&gt;1101,k=5)</td><td>x&amp;((1&lt;&lt;k)-1)</td></tr><tr><td>取右数第k位</td><td>(1101101-&gt;1,k=4)</td><td>x&gt;&gt;(k-1)&amp;1</td></tr><tr><td>把末k位变成1</td><td>(101001-&gt;101111,k=4)</td><td>x\</td><td>(1&lt;&lt;k-1)</td></tr><tr><td>末k位取反</td><td>(101001-&gt;100110,k=4)</td><td>x^ (1&lt;&lt;k-2)</td></tr><tr><td>把右边连续的1变成0</td><td>(100101111-&gt;100100000)</td><td>x&amp;(x+1)</td></tr><tr><td>把右起第一个0变成1</td><td>(100101111-&gt;100111111)</td><td>x\</td><td>(x+1)</td></tr><tr><td>把右边连续的0变成1</td><td>(11011000-&gt;11011111)</td><td>x\</td><td>(x-1)</td></tr><tr><td>取右边连续的1</td><td>(100101111-&gt;1111)</td><td>(x^(x+1))&gt;&gt;1</td></tr><tr><td>去掉右起第一个1的左边</td><td>(100101000-&gt;1000)</td><td>x&amp;(x^(x-1))</td></tr></tbody></table></div><h5 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a><strong>适用情况</strong></h5><p>看到N和M范围差别特别大，而且N的范围特别小时（也有可能都很小，在20以内时），首先就应该想到正确算法与这两个范围有关！</p><p>因此进一步可以考虑使用状压dp求解！！</p><h5 id="poj-3254"><a href="#poj-3254" class="headerlink" title="poj 3254"></a><strong>poj 3254</strong></h5><p>题意：有n*m大的一个地方，1表示土地肥沃可以种植物，0表示不能种植物，问：在不许有两个植物相邻的情况下，有多少种放置的方法。</p><p>思路：参考博客：<a href="http://blog.csdn.net/mengxiang000000/article/details/51075506" target="_blank" rel="noopener">http://blog.csdn.net/mengxiang000000/article/details/51075506</a></p><p>1⃣️预处理出来每一行不相邻的情况。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span><span class="hljs-comment">//去除所有相邻的情况</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>);i++)        <span class="hljs-keyword">if</span>((i&amp;(i&lt;&lt;<span class="hljs-number">1</span>))==<span class="hljs-number">0</span>)<span class="hljs-comment">//i左移一位,相邻就相当于左移之后的数字和原数字相与都是0</span>            fit[++num]=i;&#125;</code></pre><p>2⃣️保存土地的肥沃情况。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> m,n;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;m,&amp;n);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)    &#123;        <span class="hljs-keyword">int</span> x;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);        mp[i]=(mp[i]&lt;&lt;<span class="hljs-number">1</span>)+x;    &#125;</code></pre><p>3⃣️动态规划。</p><p>dp(i)(j):推到第i行，第i行为j状态时的方法数。</p><p>dp(i)(j)=sum{dp(i-1)(k),(1&lt;=k&lt;=num&amp;&amp;k要符合土地肥沃条件和不相邻条件)}</p><p>边界条件就是第一行符合土地肥沃条件的为1，不符合的为0。</p><p>符合土地肥沃条件：</p><p>该状态和土地肥沃情况或运算之后为本来的土地肥沃情况。</p><p>符合不相邻条件：</p><p>该状态和上一行状态与运算之后为0。</p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=num;j++)&#123;    <span class="hljs-keyword">if</span>(fit[j]&gt;=(<span class="hljs-number">1</span>&lt;&lt;n))<span class="hljs-keyword">break</span>;    <span class="hljs-keyword">if</span>((mp[<span class="hljs-number">1</span>]|fit[j])==mp[<span class="hljs-number">1</span>])dp[<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> dp[<span class="hljs-number">1</span>][j]=<span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=m;i++)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=num;j++)    &#123;        <span class="hljs-keyword">if</span>(fit[j]&gt;=(<span class="hljs-number">1</span>&lt;&lt;n))<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span>((mp[i]|fit[j])==mp[i])<span class="hljs-comment">//在i行出现j状态是否符合土地条件</span>        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=num;k++)            &#123;                <span class="hljs-keyword">if</span>((fit[k]&amp;fit[j])==<span class="hljs-number">0</span>)<span class="hljs-comment">//是否符合上下行不能相邻条件</span>                &#123;                    dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][k])%MOD;                &#125;            &#125;        &#125;    &#125;</code></pre><p>4⃣️把最后一行的所有方法数字相加即可。</p><p>完整代码：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> fit[<span class="hljs-number">500</span>];<span class="hljs-comment">//每行中不相邻的情况数</span><span class="hljs-keyword">int</span> mp[<span class="hljs-number">15</span>];<span class="hljs-comment">//保存每一行可否放牛情况</span><span class="hljs-keyword">int</span> dp[<span class="hljs-number">15</span>][<span class="hljs-number">500</span>];<span class="hljs-comment">//第i行为j状态时的情况数</span><span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span><span class="hljs-comment">//去除所有相邻的情况</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>);i++)        <span class="hljs-keyword">if</span>((i&amp;(i&lt;&lt;<span class="hljs-number">1</span>))==<span class="hljs-number">0</span>)<span class="hljs-comment">//i左移一位</span>            fit[++num]=i;    <span class="hljs-comment">//printf("%d\n",num);</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    init();    <span class="hljs-keyword">int</span> m,n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;m,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)        &#123;            <span class="hljs-keyword">int</span> x;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            mp[i]=(mp[i]&lt;&lt;<span class="hljs-number">1</span>)+x;        &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=num;j++)    &#123;        <span class="hljs-keyword">if</span>(fit[j]&gt;=(<span class="hljs-number">1</span>&lt;&lt;n))<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span>((mp[<span class="hljs-number">1</span>]|fit[j])==mp[<span class="hljs-number">1</span>])dp[<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> dp[<span class="hljs-number">1</span>][j]=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=m;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=num;j++)        &#123;            <span class="hljs-keyword">if</span>(fit[j]&gt;=(<span class="hljs-number">1</span>&lt;&lt;n))<span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span>((mp[i]|fit[j])==mp[i])<span class="hljs-comment">//在i行出现j状态是否符合土地条件</span>            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=num;k++)                &#123;                    <span class="hljs-keyword">if</span>((fit[k]&amp;fit[j])==<span class="hljs-number">0</span>)<span class="hljs-comment">//是否符合上下行不能相邻条件</span>                    &#123;                        dp[i][j]=(dp[i][j]+dp[i<span class="hljs-number">-1</span>][k])%MOD;                    &#125;                &#125;            &#125;            <span class="hljs-comment">//printf("row=%d state=%d : %d\n",i,fit[j],dp[i][j]);</span>        &#125;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=num;i++)        ans=(ans+dp[m][i])%MOD;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速取幂法&amp;&amp;矩阵快速幂</title>
    <link href="/2018/01/25/%E5%BF%AB%E9%80%9F%E5%8F%96%E5%B9%82%E6%B3%95-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2018/01/25/%E5%BF%AB%E9%80%9F%E5%8F%96%E5%B9%82%E6%B3%95-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h5 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a><strong>快速幂</strong></h5><p><img src="http://imglf0.nosdn.127.net/img/c1ZPVVVibTlzNjcvRmFDcWs0TnVrTzgvRHgzbXc4SFRMWjF6NlluaWw5M2RHN1U5aCtGV09BPT0.jpg?=imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2" srcset="/img/loading.gif" alt="img"></p><p><img src="http://imglf2.nosdn.127.net/img/c1ZPVVVibTlzNjcvRmFDcWs0TnVrS2xJTit5UUxNME13MTNFV0tHNU5GL0dsbHFiam5NaFlRPT0.jpg?=imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2" srcset="/img/loading.gif" alt="img"></p><p>写成函数：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">PowerMod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k;    k=a;    k=k%c;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)        ans=(ans*k)%c;        b&gt;&gt;=<span class="hljs-number">1</span>;        k=(k*k)%c;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre><h5 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a><strong>矩阵快速幂</strong></h5><p>以求斐波那契数列第n(1 &lt;= n &lt;= 10^18)项为例，由于结果很大，输出F(n) % 1000000009的结果即可。</p><p>因为<img src="https://pic1.zhimg.com/c132dc66340f9c3ac73b9820c3a1b8f4_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>所以<img src="https://pic3.zhimg.com/e162736510efa03aab42c651ee722cda_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>求Fib(n) % P的问题转为了求矩阵<img src="https://pic4.zhimg.com/a559bdc82eb5a6a7e261cff2248e70bf_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>矩阵快速幂的写法跟快速取幂法相似：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];&#125;m,r;<span class="hljs-function">mat <span class="hljs-title">mult</span><span class="hljs-params">(mat x,mat y)</span></span><span class="hljs-function"></span>&#123;    mat res=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">int</span> i,j,k;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;k++)        res.a[i][j]=(res.a[i][j]+(x.a[i][k]*y.a[k][j])%MOD)%MOD;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function">mat <span class="hljs-title">PowerMod</span><span class="hljs-params">(mat x,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n)</span></span><span class="hljs-function"></span>&#123;    mat ans=&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)    ans.a[i][i]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)            ans=mult(ans,x);        x=mult(x,x);        n=n/<span class="hljs-number">2</span>;        &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;n);    m.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;m.a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;m.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;m.a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    r=PowerMod(m,n<span class="hljs-number">-2</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,r.a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1079 中国剩余定理</title>
    <link href="/2018/01/25/51nod-1079-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    <url>/2018/01/25/51nod-1079-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h5 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h5><p>一个正整数K，给出K Mod 一些质数的结果，求符合条件的最小的K。</p><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>参考博客：<a href="http://www.cnblogs.com/linyujun/p/5199415.html" target="_blank" rel="noopener">http://www.cnblogs.com/linyujun/p/5199415.html</a></p><p>举个栗子，K%3=2，K%5=3，K%7=2。</p><p>我们需要构造这个答案</p><p>5×7×inv(5×7,3) % 3  =  1</p><p>3×7×inv(3×7,5) % 5  =  1</p><p>3×5×inv(3×5,7) % 7  =  1</p><p>然后两边同乘你需要的数</p><p>2×5×7×inv(5×7,3) % 3  =  2</p><p>3×3×7×inv(3×7,5) % 5  =  3</p><p>2×3×5×inv(3×5,7) % 7  =  2</p><p>令 </p><p>a=2×5×7×inv(5×7,3) </p><p>b=3×3×7×inv(3×7,5) </p><p>c=2×3×5×inv(3×5,7) </p><p>那么</p><p>a % 3 = 2</p><p>b % 5 = 3</p><p>c % 7 = 2</p><p>其实答案就是a+b+c</p><p>因为</p><p>a%5 = a%7 = 0 因为a是5的倍数，也是7的倍数</p><p>b%3 = b%7 = 0 因为b是3的倍数，也是7的倍数</p><p>c%3 = c%5 = 0 因为c是3的倍数，也是5的倍数</p><p>所以</p><p>(a + b + c) % 3 = (a % 3) + (b % 3) + (c % 3) = 2 + 0 + 0 = 2</p><p>(a + b + c) % 5 = (a % 5) + (b % 5) + (c % 5) = 0 + 3 + 0 = 3</p><p>(a + b + c) % 7 = (a % 7) + (b % 7) + (c % 7) = 0 + 0 + 2 = 2</p><p>但是答案，不只一个，有无穷个，每105个就是一个答案（105 = 3 <em> 5 </em> 7）</p><p>根据计算，答案等于233233%105 = 23</p><p>如果题目问你最小的那个答案，那就是23了。</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;ll p[<span class="hljs-number">110</span>],m[<span class="hljs-number">110</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">extgcd</span><span class="hljs-params">(ll a,ll b,ll d,ll &amp;x,ll &amp;y)</span>   <span class="hljs-comment">//a,b都为正整数</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;d=a;x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;&#125;    <span class="hljs-keyword">else</span>&#123;extgcd(b,a%b,d,y,x);y=y-x*(a/b);&#125;&#125;<span class="hljs-function">ll <span class="hljs-title">inverse</span><span class="hljs-params">(ll a,ll p)</span></span><span class="hljs-function"></span>&#123;    ll d,x,y;    extgcd(a,p,d,x,y);    <span class="hljs-keyword">return</span> (x%p+p)%p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    ll mul=<span class="hljs-number">1</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;p[i],&amp;m[i]);        mul*=p[i];    &#125;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        ll temp=mul/p[i];        ll tp=(inverse(temp,p[i]))%mul;        temp=(temp*m[i])%mul;        ans=(ans+(temp*tp)%mul)%mul;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1073 约瑟夫环</title>
    <link href="/2018/01/25/51nod-1073-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    <url>/2018/01/25/51nod-1073-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>假设现在是6个人（编号从0到5）报数，报到（2-1）的退出，即<m=2>。那么第一次编号为1的人退出圈子，从他之后的人开始算起，序列变为2,3,4,5,0，即问题变成了这5个人报数的问题，将序号做一下转换：</p><a id="more"></a><p>2 —&gt;0</p><p>3 —&gt;1</p><p>4 —&gt;2</p><p>5 —&gt;3</p><p>0 —&gt;4</p><p>现在假设x为0,1,2,3,4的解，x’设为那么原问题的解（这里注意，2,3,4,5,0的解就是0,1,2,3,4,5的解，因为1出去了，结果还是一个），根据观察发现，x与x’关系为x’=(x+m)%n，因此只要求出x，就可以求x’。 </p><p>令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]<br>递推公式<br>f[1]=0;<br>f[i]=(f[i-1]+m)%i;  (i&gt;1)<br>有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1。<br>由于是逐级递推，不需要保存每个f[i]：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,k,s=<span class="hljs-number">0</span>,i;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;k);     <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=n;i++)        s=(s+k)%i;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,s+<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1384 全排列</title>
    <link href="/2018/01/25/51nod-1384-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2018/01/25/51nod-1384-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>这道题跟之前写的dfs不同的一点是可以有重复的字母，想了一下dfs改不了，所以只能利用set容器了，set容器有唯一性，而且已经从小到大排列好了，还不用sort了。</strong></p><a id="more"></a><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">char</span> s[<span class="hljs-number">10</span>],as[<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> vis[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> len;<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt;qpl;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">if</span>(x==len)qpl.insert(as);    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)        &#123;            <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-number">0</span>)            &#123;                as[x]=s[i];                vis[i]=<span class="hljs-number">1</span>;                pl(x+<span class="hljs-number">1</span>);                vis[i]=<span class="hljs-number">0</span>;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    gets(s);    len=<span class="hljs-built_in">strlen</span>(s);    sort(s,s+len);    pl(<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt;::iterator it=qpl.<span class="hljs-built_in">begin</span>();it!=qpl.<span class="hljs-built_in">end</span>();it++)    <span class="hljs-built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>另外也可以利用STL中的库函数next_permutation：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">char</span> s[<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len;    gets(s);    len=<span class="hljs-built_in">strlen</span>(s);    <span class="hljs-keyword">int</span> l=<span class="hljs-built_in">strlen</span>(s);    sort(s,s+l);    <span class="hljs-keyword">do</span>    &#123;        <span class="hljs-built_in">puts</span>(s);    &#125;<span class="hljs-keyword">while</span>(next_permutation(s,s+l));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51nod 1058 1130 N的阶乘的长度及斯特林近似</title>
    <link href="/2018/01/25/51nod-1058-1130-N%E7%9A%84%E9%98%B6%E4%B9%98%E7%9A%84%E9%95%BF%E5%BA%A6%E5%8F%8A%E6%96%AF%E7%89%B9%E6%9E%97%E8%BF%91%E4%BC%BC/"/>
    <url>/2018/01/25/51nod-1058-1130-N%E7%9A%84%E9%98%B6%E4%B9%98%E7%9A%84%E9%95%BF%E5%BA%A6%E5%8F%8A%E6%96%AF%E7%89%B9%E6%9E%97%E8%BF%91%E4%BC%BC/</url>
    
    <content type="html"><![CDATA[<p><strong>1058**</strong>(1&lt;=n&lt;=10^6)：**</p><p><strong>n!的长度等于log10(n!)</strong></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,i;    <span class="hljs-keyword">double</span> sum=<span class="hljs-number">1</span>;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)   sum=sum+<span class="hljs-built_in">log10</span>(i);   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,(<span class="hljs-keyword">int</span>)sum);    return0;&#125;</code></pre><p><strong>1130(1&lt;=n&lt;=10^9)</strong></p><p><strong>通过斯特林公式优化：</strong></p><p><strong><img src="http://upload.wikimedia.org/math/e/6/5/e656c0c9a9bd7e763310012120a00317.png" srcset="/img/loading.gif" alt="img">（e =2.718）</strong></p><p><strong>斯特林公式可以用来估算某数的大小，结合lg可以估算某数的位数，或者可以估算某数的阶乘是另一个数的倍数。</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI 3.1415926535898</span> <span class="hljs-comment">//这里要长一点</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> e 2.718281828459</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,t,j,n;    <span class="hljs-keyword">double</span> sum;   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);   <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;t;j++)    &#123;      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);      sum=<span class="hljs-number">0.5</span>*<span class="hljs-built_in">log10</span>(<span class="hljs-number">2</span>*PI*n)+n*<span class="hljs-built_in">log10</span>(n/e);      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)sum+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector用法</title>
    <link href="/2018/01/25/vector%E7%94%A8%E6%B3%95/"/>
    <url>/2018/01/25/vector%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>1&gt;. a.size()                 //获取向量中的元素个数</p><p>​    2&gt;. a.empty()                //判断向量是否为空</p><p>​    3&gt;. a.clear()                //清空向量中的元素</p><p>​    4&gt;. 复制</p><p>​        a = b ;            //将b向量复制到a向量中</p><p>​    5&gt;. 比较</p><p>​        保持 ==、!=、&gt;、&gt;=、&lt;、&lt;= 的惯有含义 ;</p><p>​        如: a == b ;    //a向量与b向量比较, 相等则返回1</p><p>​    6&gt;. 插入 - insert</p><p>​        ①、 a.insert(a.begin(), 1000);            //将1000插入到向量a的起始位置前</p><p>​        ②、 a.insert(a.begin(), 3, 1000) ;        //将1000分别插入到向量元素位置的0-2处(共3个元素)</p><p>​        ③、 vector<int> a(5, 1) ;</p><p>​            vector<int> b(10) ;</p><p>​            b.insert(b.begin(), a.begin(), a.end()) ;        //将a.begin(), a.end()之间的全部元素插入到b.begin()前</p><p>​    7&gt;. 删除 - erase</p><p>​        ①、 b.erase(b.begin()) ;                     //将起始位置的元素删除</p><p>​        ②、 b.erase(b.begin(), b.begin()+3) ;        //将(b.begin(), b.begin()+3)之间的元素删除</p><p>​    8&gt;. 交换 - swap</p><p>​        b.swap(a) ;            //a向量与b向量进行交换</p><p>1.push_back   在数组的最后添加一个数据<br>2.pop_back    去掉数组的最后一个数据<br>3.at                得到编号位置的数据<br>4.begin           得到数组头的指针<br>5.end             得到数组的最后一个单元+1的指针<br>6．front        得到数组头的引用<br>7.back            得到数组的最后一个单元的引用<br>8.max_size     得到vector最大可以是多大<br>9.capacity       当前vector分配的大小<br>10.size           当前使用数据的大小<br>11.resize         改变当前使用数据的大小，如果它比当前使用的大，者填充默认值<br>12.reserve      改变当前vecotr所分配空间的大小<br>13.erase         删除指针指向的数据项<br>14.clear          清空当前的vector<br>15.rbegin        将vector反转后的开始指针返回(其实就是原来的end-1)<br>16.rend          将vector反转构的结束指针返回(其实就是原来的begin-1)<br>17.empty        判断vector是否为空<br>18.swap         与另一个vector交换数据</p><p>​         3.2  详细的函数实现功能：其中vector<int> c.</p><p>​                             c.clear()         移除容器中所有数据。</p><p>​                             c.empty()         判断容器是否为空。</p><p>​                             c.erase(pos)        删除pos位置的数据</p><p>​                             c.erase(beg,end) 删除[beg,end)区间的数据</p><p>​                             c.front()         传回第一个数据。</p><p>​                             c.insert(pos,elem)  在pos位置插入一个elem拷贝</p><p>​                             c.pop_back()     删除最后一个数据。</p><p>​                             c.push_back(elem) 在尾部加入一个数据。</p><p>​                             c.resize(num)     重新设置该容器的大小</p><p>​                             c.size()         回容器中实际数据的个数。</p><p>​                             c.begin()           返回指向容器第一个元素的迭代器</p><p>​                             c.end()             返回指向容器最后一个元素的迭代器</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数学</title>
    <link href="/2018/01/25/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    <url>/2018/01/25/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="错排公式"><a href="#错排公式" class="headerlink" title="错排公式"></a><strong>错排公式</strong></h3><p>对于<script type="math/tex">D[n]</script>都有<script type="math/tex">D[n]=(n-1)*(D[n-1]+D[n-2])</script>【特殊的，<script type="math/tex">D[0]=1</script>,<script type="math/tex">D[1]=0</script>，<script type="math/tex">D[2]=1</script>】。</p><p><script type="math/tex">D[n]=n!*(\frac{1}{2!}-\frac{1}{3!}+\frac{1}{4!}- \frac{1}{5!}+ ··· ··· +\frac{(-1)^{n-1}}{(n-1)!}+\frac{(-1)^n}{n!})</script>。</p><p>下面拓展一下i个人有j个人是正确的；</p><p>i个人有j个时正确的，有三种情况，</p><p>1：前i-1个人有j-1个正确,然后分配给第i个人他自己的物品。</p><p>2：前i-1个人有j个正确，分配给第i个人他自己的物品，然后再把第i个人和前i-1个人拥有不正确物品的人交换</p><p>3：前i-1个人，有j+1个人正确，分配给$d_i$个人他自己的物品，然后和前i-1个人拥有正确物品的人交换</p><p>结果就是：</p><p><img src="http://imglf4.nosdn.127.net/img/ajhrcUFValVhVzZ3Y3I5Q0EvOXRxUmtCaG9mNHlLaEJtdDlBN3RsNG44MTFPbUpBSzBxeXJBPT0.png?=imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2" srcset="/img/loading.gif" alt="img"></p><p>小tip：</p><p>当指数很大取模时，可以多次快速幂。</p><p>比如2的10的24次方的次方，可以拆成2的10的12次方取模，再对得数取模。</p><h3 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h3><h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h4><h5 id="整数的有序拆分"><a href="#整数的有序拆分" class="headerlink" title="整数的有序拆分"></a>整数的有序拆分</h5><p>将n个相同物体分配到m个不同位置上，称为整数的有序拆分，拆分数等于方程<script type="math/tex">n=x_1+x_2+...+x_m</script>的解的个数。</p><p><strong>无空位时</strong>，拆分数为<script type="math/tex">C_{n-1}^{m-1}</script>。</p><p><strong>可以有空位时</strong>，拆分数为<script type="math/tex">C_{n+m-1}^{n}=C_{n+m-1}^{m-1}</script>。</p><p>例：</p><p>8台计算机分配给3个单位，第一个单位的分配量不超过3台，第二个单位的分配量不超过4台，第三个单位的分配量不超过5台，问有几种分派方案？</p><p>解：<script type="math/tex">G(x)=(1+x+x^2+x^3)(1+x+x^2+x^3+x^4)(1+x+x^2+x^3+x^4+x^5)</script>，化简之后（其实可以写个程序跑一跑），<script type="math/tex">x^8</script>的系数为14，所以共14种分配方案。</p><h5 id="整数的无序拆分"><a href="#整数的无序拆分" class="headerlink" title="整数的无序拆分"></a>整数的无序拆分</h5><p>将n个相同物体分配到m个相同的位置上，称为整数的无序拆分。</p><p><strong>无空位时，</strong></p><p>将正整数n分成m个部分，<script type="math/tex">n=n_1+n_2+...+n_m(m\geq 1,n_i\geq 1)</script>，且不考虑<script type="math/tex">n_i</script>的次序，满足<script type="math/tex">n_1\geq n_2...\geq n_m</script>，拆分数记为<script type="math/tex">P_m(n)</script>。</p><p>定理：正整数n拆分成m个部分的方案数等于整数n的拆分中最大部分为m的方案数。</p><p>若整数n拆分成1,2,…,m的和，并允许重复，其母函数为<script type="math/tex">G(x)=(1+x+x^2+...)(1+x^2+{(x^2)}^2+...)...(1+x^m+{(x^m)^2}+...)</script>。</p><p><strong>可以有空位时，</strong></p><p>当<script type="math/tex">n\geq m</script>时，方案数=<script type="math/tex">P_1(n)+P_2(n)+...+P_m(n)</script>。</p><p>当<script type="math/tex">n<m</script>时，方案数=<script type="math/tex">P_1(n)+P_2(n)+...+P_n(n)</script>。</p><p>整数n拆分中，所有部分均为奇数，其母函数为<script type="math/tex">G(x)=(1+x+x^2+...)(1+x^3+{(x^3)}^2+...)(1+x^5+{(x^5)}^2+...)...</script>。</p><p>整数n拆分中，所有部分不相等，其母函数为</p><p><script type="math/tex">G(x)=(1+x)(1+x^2)(1+x^3)...</script>。</p><p>例：</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尺取法</title>
    <link href="/2018/01/25/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
    <url>/2018/01/25/%E5%B0%BA%E5%8F%96%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>举个栗子看张图就可以懂了www</p><p>给定长度为n的数列整数a0,a1,a2,a3 ….. an-1以及整数S。求出综合不小于S的连续子序列的长度的最小值。如果解不存在，则输出0。（10&lt;n&lt;10^5，0&lt;ai&lt;10^4，S&lt;10^8）</p><a id="more"></a><p>这里我们拿第一组测试数据举例子，即 n=10, S = 15, a = {5,1,3,5,10,7,4,9,2,8}</p><p><img src="http://images.cnitblog.com/blog/597004/201408/291224259702079.jpg" srcset="/img/loading.gif" alt="img">这幅图便是尺取法怎么“取”的过程了。</p><p>整个过程分为4步：</p><p>1.初始化左右端点</p><p>2.不断扩大右端点，直到满足条件</p><p>3.如果第二步中无法满足条件，则终止，否则更新结果</p><p>4.将左端点扩大1，然后回到第二步</p><p>用尺取法来优化，使复杂度降为了O(n)。</p><p>最后，再给一个尺取法的定义以便更好理解：返回的推进区间开头和结尾，求满足条件的最小区间的方法称为尺取法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java相关</title>
    <link href="/2018/01/25/java%E7%9B%B8%E5%85%B3/"/>
    <url>/2018/01/25/java%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h5 id="java队列"><a href="#java队列" class="headerlink" title="java队列"></a><strong>java队列</strong></h5><p>add 增加一个元素      如果队列已满，则抛出一个IllegalSlabEepeplian异常</p><p>remove   移除并返回队列头部的元素    如果队列为空，则抛出一个NoSuchElementException异常</p><p>element  返回队列头部的元素             如果队列为空，则抛出一个NoSuchElementException异常</p><p>offer       添加一个元素并返回true       如果队列已满，则返回false<br>poll         移除并返问队列头部的元素    如果队列为空，则返回null<br>peek       返回队列头部的元素             如果队列为空，则返回null<br>put         添加一个元素                      如果队列满，则阻塞<br>take        移除并返回队列头部的元素     如果队列为空，则阻塞</p><p>举个栗子：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> hhhhh;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Queue;publicclass Main2 &#123;<span class="hljs-function">publicstaticvoid <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>Queue&lt;String&gt;q=<span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();q.offer(<span class="hljs-string">"A"</span>);<span class="hljs-keyword">for</span>(inti=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<span class="hljs-keyword">char</span> []s=&#123;(<span class="hljs-keyword">char</span>) (<span class="hljs-string">'0'</span>+i)&#125;;String str=<span class="hljs-keyword">new</span> String(s);q.offer(str);&#125;q.offer(<span class="hljs-string">"10"</span>);q.offer(<span class="hljs-string">"J"</span>);q.offer(<span class="hljs-string">"Q"</span>);q.offer(<span class="hljs-string">"K"</span>);System.out.println(<span class="hljs-string">"The order that others were removed:"</span>);<span class="hljs-keyword">while</span>(q.size()!=<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span>(inti=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;String temp=q.poll();q.offer(temp);&#125;String temp=q.poll();System.out.println(temp);&#125;System.out.println(<span class="hljs-string">"the last one is："</span>);System.out.println(q.poll());&#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AC自动机</title>
    <link href="/2018/01/25/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2018/01/25/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h5 id="字典树（数组实现）"><a href="#字典树（数组实现）" class="headerlink" title="字典树（数组实现）"></a><strong>字典树（数组实现）</strong></h5><p><a href="http://www.cnblogs.com/TheRoadToTheGold/p/6290732.html" target="_blank" rel="noopener">http://www.cnblogs.com/TheRoadToTheGold/p/6290732.html</a></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> trie[<span class="hljs-number">500005</span>][<span class="hljs-number">26</span>];<span class="hljs-comment">//编号为i的节点的第j个孩子是编号为k的节点</span><span class="hljs-keyword">int</span> num[<span class="hljs-number">500005</span>];<span class="hljs-comment">//每个编号被访问的次数</span><span class="hljs-keyword">int</span> tot=<span class="hljs-number">1</span>;<span class="hljs-comment">//第一种编号</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> zs[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(zs);    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">int</span> id=zs[i]-<span class="hljs-string">'a'</span>;<span class="hljs-comment">//第二种编号</span>        <span class="hljs-keyword">if</span>(!trie[pos][id])<span class="hljs-comment">//如果对应字符还没有值</span>            trie[pos][id]=tot++;        pos=trie[pos][id];<span class="hljs-comment">//继续往下走</span>        num[pos]++;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">char</span> zs[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(zs);    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">int</span> id=zs[i]-<span class="hljs-string">'a'</span>;        <span class="hljs-keyword">if</span>(!trie[pos][id])            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        pos=trie[pos][id];    &#125;    <span class="hljs-keyword">return</span> num[pos];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> zs[<span class="hljs-number">15</span>];    <span class="hljs-built_in">memset</span>(trie,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(trie));    <span class="hljs-built_in">memset</span>(num,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(num));    <span class="hljs-keyword">while</span>(gets(zs))    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(zs,<span class="hljs-string">"\0"</span>)==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        Insert(zs);    &#125;    <span class="hljs-keyword">while</span>(gets(zs))        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,Find(zs));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a><strong>AC自动机</strong></h5><p><strong>参考博客：</strong></p><p><a href="https://subetter.com/algorithms-and-mathematics/aho-corasick-algorithm.html" target="_blank" rel="noopener">https://subetter.com/algorithms-and-mathematics/aho-corasick-algorithm.html</a></p><p><a href="http://blog.csdn.net/baidu_30541191/article/details/47447175" target="_blank" rel="noopener">http://blog.csdn.net/baidu_30541191/article/details/47447175</a></p><p><strong>步骤：</strong></p><p>现给定 3 个单词 {“china”, “hit”, “use”}，再给定一段文本 “chitchat”，求有多少个单词出现在文本中。</p><p>1.根据单词 {“china”, “hit”, “use”} 建立字典树。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuw5h1joawj30ge0bemxd.jpg" srcset="/img/loading.gif" alt="img"></p><p>2.根据所给文本 “chitchat” 依次匹配，图中所示 “chi” 为匹配成功的字符串。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuw5hvguwqj30ge0be0t0.jpg" srcset="/img/loading.gif" alt="img"></p><p>3.当匹配到第四个字符时，“t”和 “n” 匹配失败。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fuw5iaxokxj30ge0be74k.jpg" srcset="/img/loading.gif" alt="img"></p><p>4.我们此时是知道已匹配成功的字符串的，即 “chi”。</p><p>AC 算法的核心就是<strong>在所有给定的单词中，找到这样的一个单词，使其与已匹配成功字符串的相同前后缀最长，利用这个最长的相同前后缀实现搜索跳转。</strong>如上图，单词 “hit” 与已匹配成功字符串 “chi” 的最长相同前后缀为 “hi”，因此下一步从单词“hit” 的“t”开始搜索。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuw5itn5rhj30ge0bedg7.jpg" srcset="/img/loading.gif" alt="img"></p><p>5.此时 “t” 是匹配的，在文本 “chitchat” 中找到一个单词“hit”。</p><p>其实到这里，AC 算法的思想已经基本呈现在大家面前了。剩下的问题就是如何解决第（3）步所述的 “核心”。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuw5j6vp21j30ge0bemxg.jpg" srcset="/img/loading.gif" alt="img"></p><p><strong>创建失配指针：</strong></p><p>在每个结点里设置一个指针（我们称之为 fail 指针），指向跳转的位置。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuw5k8dc69j30ge0beq3r.jpg" srcset="/img/loading.gif" alt="img"></p><p>对于跳转位置的选择，基于以下两点：</p><ol><li>对于根结点的所有儿子结点，它们的fail指针指向根结点；</li><li>对于其它结点，不妨设该结点上的字符为<code>ch</code>，沿着它的父亲结点的fail指针走，直到走到一个结点，它的儿子中也有字符为<code>ch</code>的结点，然后把该结点的fail指针指向那个字符为<code>ch</code>的结点。如果一直走到了根结点都没找到，那就把fail指针指向根结点。</li></ol><p><strong>模板：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> cnt,ans;<span class="hljs-keyword">char</span> a[<span class="hljs-number">1000010</span>];<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> son[<span class="hljs-number">26</span>];    <span class="hljs-keyword">int</span> fail;    <span class="hljs-keyword">int</span> num;&#125;nd[<span class="hljs-number">1000010</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(a);    <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">if</span>(!nd[cur].son[a[i]-<span class="hljs-string">'a'</span>])            nd[cur].son[a[i]-<span class="hljs-string">'a'</span>]=++cnt;        cur=nd[cur].son[a[i]-<span class="hljs-string">'a'</span>];    &#125;    nd[cur].num++;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_fail</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)    &#123;        nd[nd[<span class="hljs-number">0</span>].son[i]].fail=<span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(nd[<span class="hljs-number">0</span>].son[i])            q.push(nd[<span class="hljs-number">0</span>].son[i]);    &#125;    <span class="hljs-keyword">while</span>(!q.empty())    &#123;        <span class="hljs-keyword">int</span> u=q.front();        q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)        &#123;            <span class="hljs-keyword">if</span>(nd[u].son[i])            &#123;                nd[nd[u].son[i]].fail=nd[nd[u].fail].son[i];                q.push(nd[u].son[i]);            &#125;            <span class="hljs-keyword">else</span>                nd[u].son[i]=nd[nd[u].fail].son[i];        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">strlen</span>(a);    <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        cur=nd[cur].son[a[i]-<span class="hljs-string">'a'</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=cur;j!=<span class="hljs-number">0</span>&amp;&amp;nd[j].num!=<span class="hljs-number">-1</span>;j=nd[j].fail)        &#123;            ans+=nd[j].num;            nd[j].num=<span class="hljs-number">-1</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    cnt=<span class="hljs-number">0</span>;    nd[<span class="hljs-number">0</span>].fail=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(n--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);        Insert();    &#125;    build_fail();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,a);    ans=<span class="hljs-number">0</span>;    query();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补算法计划</title>
    <link href="/2018/01/25/%E8%A1%A5%E7%AE%97%E6%B3%95%E8%AE%A1%E5%88%92/"/>
    <url>/2018/01/25/%E8%A1%A5%E7%AE%97%E6%B3%95%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>（有下划线的表示还不了解）</p><p><strong>动态规划</strong></p><p>基础</p><ul><li><p>线性dp、区间dp，主要就是状态方程的设计和状态的转移</p></li><li><p>背包dp，及其扩展 《背包九讲》是很好的学习资料</p></li><li><p><u>用dp递推概率、期望（dp求期望一般分为两种。一种是dp状态保存的是概率，则期望=概率*花费。另一种是dp状态直接保存期望，这样一般都是逆推的。）</u></p></li><li><p>树形dp（有些会套个背包dp，有些需要多次树形dp）</p></li><li><p>状态压缩dp</p></li><li><p>数位dp</p></li><li><p>RMQ、<u>二维RMQ</u></p></li></ul><p>进阶</p><ul><li><p><u>dp优化</u></p><p><u>使用数据结构优化，如线段树、树状数组、单调队列、单调栈、维护前缀和 …</u></p><p><u>斜率优化（具有单调性可直接用单调队列或者二分，不具单调性要用平衡二叉树动态维护凸壳）</u></p><p><u>四边形不等式优化</u></p></li><li><p><u>插头dp</u></p></li></ul><p><strong>数据结构</strong></p><p>基础</p><ul><li><p>队列、栈</p></li><li><p>树、图的存储、遍历 邻接表和邻接矩阵</p></li><li><p>单调队列、单调栈</p></li><li><p>线段树、树状数组</p></li><li><p>并查集、带权并查集</p></li><li><p>堆、优先队列</p></li><li><p><u>平衡二叉树</u></p><p><u>Treap</u></p><p><u>Spaly必须会</u></p><p><u>[红黑树]</u></p><p><u>[AVL树]</u></p></li><li><p>Hash散列表</p></li></ul><p>进阶</p><ul><li>分块数组（分块的思想很强大）</li><li>二维线段树（就是线段树套线段树，其实还有个[矩形树]）、二维树状数组（就是树状数组套树状数组）</li><li>树链剖分</li><li><u>树套树，如线段树套平衡二叉树、树状数组套平衡二叉树 …</u></li><li><u>Link-Cut-Tree（解决一类动态树的问题，可以说是树的剖分+Splay）</u></li><li><u>可持久化数据结构，如主席树、可持久化线段树、可持久化字典树、可持久化并查集、可持久化Treap …</u></li></ul><p><strong>搜索</strong></p><p>基础</p><ul><li>深搜</li><li>广搜</li><li>记忆化搜索（也可以放到dp分类里）</li><li>使用优先队列的广搜</li><li>模拟退火、爬山算法</li></ul><p>进阶</p><ul><li><u>搜索剪枝</u></li><li><u>双向广搜</u></li><li><u>A<em>、IDA</em></u></li><li><u>舞蹈链</u></li></ul><p><strong>图论</strong></p><p>基础</p><ul><li><p>最短路（Dijkstra、Spfa、Floyd）</p></li><li><p>最小生成树（Prim、Kruskal）</p></li><li><p>拓扑排序</p></li><li><p>二分图最大匹配（匈牙利算法）</p><p>二分图的最小顶点覆盖</p><p>DAG图的最小路径覆盖</p><p>二分图的最大独立集</p></li><li><p>二分图最优匹配（KM算法）</p></li><li><p>二分图多重匹配</p></li><li><p>网络流</p><p>最大流（Dinic、Sap）</p><p><u>最小费用最大流</u></p><p><u>带上下界的最大流</u></p></li><li><p>有向图强连通分量的Tarjan算法</p></li><li><p><u>最近公共祖先 Tarjan算法实现与RMQ实现各有千秋</u></p></li><li><p>差分约束系统</p></li><li><p>欧拉回路</p></li><li><p><u>构造哈密顿回路</u></p></li><li><p><u>最大团</u></p></li><li><p><u>无向图全局最小割（StoerWagner）</u></p></li></ul><p>进阶</p><ul><li><p><u>次小生成树</u></p></li><li><p><u>最优比率生成树</u></p></li><li><p><u>[度限制生成树]</u></p></li><li><p><u>[第k小生成树]</u></p></li><li><p><u>次短路、第k短路</u></p></li><li><p><u>网络流 胡伯涛的《最小割模型在信息学竞赛中的应用》是很好的学习资料</u></p><p>最大权闭合图</p><p><u>最大密度子图</u></p><p><u>二分图最小点权覆盖集</u></p><p><u>二分图最大点权独立集</u></p><p><u>区间k覆盖的模型</u></p><p><u>平面图网络流</u></p></li><li><p>无向图的割点和桥、边双联通分量、点双联通分量</p></li><li><p><u>2-SAT</u></p></li><li><p><u>最小树形图</u></p></li><li><p><u>一般图匹配</u></p></li><li><p><u>生成树计数、最小生成树计数</u></p></li></ul><p><strong>数学</strong></p><p>基础</p><p>数论</p><ul><li><p>欧几里得算法、扩展欧几里得算法</p><p>乘法逆元</p><p>中国剩余定理</p><p>欧拉函数</p><p><u>欧拉定理</u></p><p>Miller_Rabin大素数判定</p><p>Pollard_rho大整数拆分</p></li><li><p>线性代数</p><p>矩阵乘法&amp;快速幂</p><p>高斯消元</p></li><li><p>组合数学</p><p>容斥原理</p><p>鸽巢原理</p><p><u>[母函数]</u></p><p><u>[稳定婚姻问题]</u></p></li><li><p>概率统计</p></li><li><p>群论</p><p><u>置换群</u></p><p><u>BurnSide引理</u></p><p><u>Polya定理</u></p></li></ul><p>进阶</p><ul><li><u>莫比乌斯反演</u></li><li><u>BSGS</u></li><li><u>FFT</u></li><li><u>……</u></li><li>数学的进阶内容太多了</li></ul><p><strong>字符串</strong></p><p>基础</p><ul><li>KMP、扩展KMP</li><li>字典树</li><li>最长回文子串的Manacher算法</li><li>字符串最小/最大表示法</li><li><u>许多字符串问题可以用dp甚至贪心求解</u></li></ul><p>进阶</p><ul><li>AC自动机、Trie图</li><li><u>回文树</u></li><li><u>后缀数组、后缀自动机、后缀树</u></li><li><u>序列自动机</u></li></ul><p><strong>计算几何</strong></p><p>基础</p><ul><li>向量的点积、叉积</li><li>极角排序</li><li>Graham扫描法</li><li><u>二维最近点对</u></li><li><u>最小覆盖圆</u></li><li><u>圆面积并</u></li><li>……</li><li>计算几何的题目各种各样</li></ul><p>进阶</p><ul><li><u>半平面交</u></li><li><u>旋转卡壳</u></li><li><u>三维凸包</u></li><li>……</li><li>计算几何的题目各种各样</li></ul><p><strong>杂</strong></p><p><strong>博弈</strong></p><p>一些经典的博弈、SG函数、<u>必胜必败态搜索</u></p><p><strong>STL</strong></p><p>vector、set/mutiset、map、queue、stack、deque、string、<u>rope</u>…</p><p><strong>排序</strong></p><p>虽然都用sort但是堆排序的原理还是要知道的</p><p><strong>分治</strong></p><p><u>普通的分治</u></p><p><u>CDQ分治</u></p><p><u>整体二分</u></p><p><u>树分治</u></p><p><strong>二分、三分</strong></p><p><strong>2-points</strong></p><p><strong>01分数规划</strong></p><p><strong>构造</strong></p><p><strong><u>树的同构（树的hash）</u></strong></p><p><strong>莫队算法、[树上莫队]</strong></p><p><strong>找规律、打表</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题日程(๑•̀ㅂ•́)و✧</title>
    <link href="/2018/01/25/%E5%88%B7%E9%A2%98%E6%97%A5%E7%A8%8B-%E0%B9%91%E2%80%A2%CC%80%E3%85%82%E2%80%A2%CC%81-%D9%88%E2%9C%A7/"/>
    <url>/2018/01/25/%E5%88%B7%E9%A2%98%E6%97%A5%E7%A8%8B-%E0%B9%91%E2%80%A2%CC%80%E3%85%82%E2%80%A2%CC%81-%D9%88%E2%9C%A7/</url>
    
    <content type="html"><![CDATA[<p><del>[kuangbin带你飞]专题一 简单搜索</del></p><p><del>[kuangbin带你飞]专题四 最短路练习</del></p><p><del>[kuangbin带你飞]专题五 并查集</del></p><p><del>[kuangbin带你飞]专题六 最小生成树</del> </p><p><del>[kuangbin带你飞]专题十二 基础DP1</del></p><p><del>[kuangbin带你飞]专题十四 数论基础</del></p><p><del>[kuangbin带你飞]专题十六 KMP &amp; 扩展KMP &amp; Manacher</del></p><p><del>[kuangbin带你飞]专题十七 AC自动机</del></p><p><del>[kuangbin带你飞]专题七 线段树</del></p><p><del>[kuangbin带你飞]专题九 连通图</del></p><p>[kuangbin带你飞]专题十 匹配问题</p><p>[kuangbin带你飞]专题十一 网络流</p><p>[kuangbin带你飞]专题十五 数位DP</p><p>[kuangbin带你飞]专题十八 后缀数组</p><p>[kuangbin带你飞]专题二十一 概率&amp;期望</p><p>[kuangbin带你飞]专题二十二 区间DP</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2018/01/25/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2018/01/25/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>以求区间和为例</p><p><a href="https://wenku.baidu.com/view/a79fd201f78a6529647d536a.html?from=search" target="_blank" rel="noopener">https://wenku.baidu.com/view/a79fd201f78a6529647d536a.html?from=search</a></p><p><a href="http://blog.csdn.net/zearot/article/details/52280189" target="_blank" rel="noopener">http://blog.csdn.net/zearot/article/details/52280189</a></p><p><a href="http://blog.csdn.net/zearot/article/details/48299459" target="_blank" rel="noopener">http://blog.csdn.net/zearot/article/details/48299459</a></p><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a><strong>模板</strong></h5><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> left,right,val,f;&#125;node[<span class="hljs-number">10010</span>&lt;&lt;<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> id)</span>   <span class="hljs-comment">//建树</span></span><span class="hljs-function"></span>&#123;    node[id].left=l;    node[id].right=r;    node[id].f=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(l==r)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;node[id].val);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    build(l,m,id&lt;&lt;<span class="hljs-number">1</span>);    build(m+<span class="hljs-number">1</span>,r,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    node[id].val=node[id&lt;&lt;<span class="hljs-number">1</span>].val+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l1=node[id&lt;&lt;<span class="hljs-number">1</span>].left;    <span class="hljs-keyword">int</span> r1=node[id&lt;&lt;<span class="hljs-number">1</span>].right;    <span class="hljs-keyword">int</span> l2=node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].left;    <span class="hljs-keyword">int</span> r2=node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].right;    node[id&lt;&lt;<span class="hljs-number">1</span>].f+=node[id].f;    node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].f+=node[id].f;    node[id&lt;&lt;<span class="hljs-number">1</span>].val+=node[id].f*(r1-l1+<span class="hljs-number">1</span>);    node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val+=node[id].f*(r2-l2+<span class="hljs-number">1</span>);    node[id].f=<span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loc,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> id)</span>   <span class="hljs-comment">//单点修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l==r)    &#123;        node[id].val+=c;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f)down(id);    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(loc&lt;=m)update1(loc,c,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">else</span> update1(loc,c,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);    node[id].val=node[id&lt;&lt;<span class="hljs-number">1</span>].val+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loc,<span class="hljs-keyword">int</span> id)</span>   <span class="hljs-comment">//单点查询</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l==r)    &#123;        ans=node[id].val;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f)down(id);    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(loc&lt;=m)query1(loc,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">else</span> query1(loc,id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> id)</span>   <span class="hljs-comment">//区间修改</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        node[id].val+=c*(r-l+<span class="hljs-number">1</span>);        node[id].f+=c;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f)down(id);    <span class="hljs-keyword">int</span> m=(l+r)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)update2(L,R,c,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)update2(L,R,c,(id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>));    node[id].val=node[id&lt;&lt;<span class="hljs-number">1</span>].val+node[id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">query2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> L,<span class="hljs-keyword">int</span> R,<span class="hljs-keyword">int</span> id)</span>   <span class="hljs-comment">//区间查询</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l=node[id].left;    <span class="hljs-keyword">int</span> r=node[id].right;    <span class="hljs-keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)    &#123;        ans+=node[id].val;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(node[id].f)down(id);    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(L&lt;=m)query2(L,R,id&lt;&lt;<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(R&gt;m)query2(L,R,(id&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n,q,ope,x,y,z;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;q);    <span class="hljs-keyword">while</span>(q--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;ope);        <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">1</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);            update1(x,y,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">2</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);            query1(x,<span class="hljs-number">1</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">3</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);            update2(x,y,z,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ope==<span class="hljs-number">4</span>)        &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);            ans=<span class="hljs-number">0</span>;            query2(x,y,<span class="hljs-number">1</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>素数筛法</title>
    <link href="/2018/01/25/%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/"/>
    <url>/2018/01/25/%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h5 id="埃及筛法"><a href="#埃及筛法" class="headerlink" title="埃及筛法"></a><strong>埃及筛法</strong></h5><pre><code class="hljs c++"><span class="hljs-keyword">int</span> pri[MAXN],num=<span class="hljs-number">0</span>;<span class="hljs-keyword">bool</span> vis[MAXN];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum[MAXN],a[MAXN];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;MAXN;i++)    &#123;        <span class="hljs-keyword">if</span>(vis[i]==<span class="hljs-literal">false</span>)pri[num++]=i;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;num&amp;&amp;i*pri[j]&lt;MAXN;j++)        &#123;            vis[i*pri[j]]=<span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(i%pri[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><h5 id="区间筛法"><a href="#区间筛法" class="headerlink" title="区间筛法"></a><strong>区间筛法</strong></h5><p>给定整数a和b，请问区间[a,b)内有多少个素数？</p><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> is_prime[MAX_L];<span class="hljs-keyword">bool</span> is_prime_small[MAX_SQRT_B];<span class="hljs-comment">//对区间[a,b]内的整数执行筛法。is_prime[i-a]=true:i是素数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">segment_sieve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i,j;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i*i&lt;b;i++)is_prime_small[i]=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;b-a;i++)is_prime[i]=<span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i*i&lt;b;i++)    &#123;        <span class="hljs-keyword">if</span>(is_prime_small[i])        &#123;            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">2</span>*i;j*j&lt;b;j=j+i)is_prime_small[j]=<span class="hljs-literal">false</span>;   <span class="hljs-comment">//筛[2,√b]</span>            <span class="hljs-comment">//(a+i-1)/i得到最接近a的i的倍数，最低是i的2倍，然后筛选</span>            <span class="hljs-keyword">for</span>(j=<span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>,(a+i<span class="hljs-number">-1</span>)/i)*i;j&lt;b;j=j+i)is_prime[j-a]=<span class="hljs-literal">false</span>;   <span class="hljs-comment">//筛[a,b)</span>        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数位DP</title>
    <link href="/2018/01/25/%E6%95%B0%E4%BD%8DDP/"/>
    <url>/2018/01/25/%E6%95%B0%E4%BD%8DDP/</url>
    
    <content type="html"><![CDATA[<p>通常的数位dp可以写成如下形式：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>];ll dp[<span class="hljs-number">20</span>][state];<span class="hljs-comment">//不同题目状态不同</span><span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-comment">/*state变量*/</span>,<span class="hljs-keyword">bool</span> lead<span class="hljs-comment">/*前导零*/</span>,<span class="hljs-keyword">bool</span> limit<span class="hljs-comment">/*数位上界变量*/</span>)</span><span class="hljs-comment">//不是每个题都要判断前导零</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了</span>    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */</span>    <span class="hljs-comment">//第二个就是记忆化(在此前可能不同题目还能有一些剪枝)</span>    <span class="hljs-keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[pos][state];    <span class="hljs-comment">/*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/</span>    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;<span class="hljs-comment">//根据limit判断枚举的上界up;这个的例子前面用213讲过了</span>    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-comment">//开始计数</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)<span class="hljs-comment">//枚举，然后把不同情况的个数加到ans就可以了</span>    &#123;        <span class="hljs-keyword">if</span>() ...        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>()...        ans+=dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-comment">/*状态转移*/</span>,lead &amp;&amp; i==<span class="hljs-number">0</span>,limit &amp;&amp; i==a[pos]) <span class="hljs-comment">//最后两个变量传参都是这样写的</span>        <span class="hljs-comment">/*这里还算比较灵活，不过做几个题就觉得这里也是套路了</span><span class="hljs-comment">        大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论</span><span class="hljs-comment">        去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目</span><span class="hljs-comment">        要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类，</span><span class="hljs-comment">        前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/</span>    &#125;    <span class="hljs-comment">//计算完，记录状态</span>    <span class="hljs-keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][state]=ans;    <span class="hljs-comment">/*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/</span>    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)<span class="hljs-comment">//把数位都分解出来</span>    &#123;        a[pos++]=x%<span class="hljs-number">10</span>;<span class="hljs-comment">//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行</span>        x/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span><span class="hljs-comment">/*从最高位开始枚举*/</span>,<span class="hljs-comment">/*一系列状态 */</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>);<span class="hljs-comment">//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ll le,ri;    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;le,&amp;ri))    &#123;        <span class="hljs-comment">//初始化dp数组为-1,这里还有更加优美的优化,后面讲</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(ri)-solve(le<span class="hljs-number">-1</span>));    &#125;&#125;</code></pre><p>无注释版：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dp[<span class="hljs-number">20</span>][state];<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-comment">/*state变量*/</span>,<span class="hljs-keyword">bool</span> lead,<span class="hljs-keyword">bool</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[pos][state];    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)    &#123;        <span class="hljs-keyword">if</span>() ...        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>()...        ans+=dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-comment">/*状态转移*/</span>,lead &amp;&amp; i==<span class="hljs-number">0</span>,limit &amp;&amp; i==a[pos])    &#125;    <span class="hljs-keyword">if</span>(!limit &amp;&amp; !lead) dp[pos][state]=ans;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        a[pos++]=x%<span class="hljs-number">10</span>;        x/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-comment">/*一系列状态 */</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> le,ri;    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;le,&amp;ri))    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(ri)-solve(le<span class="hljs-number">-1</span>));    &#125;&#125;</code></pre><h4 id="HDU2089"><a href="#HDU2089" class="headerlink" title="HDU2089"></a>HDU2089</h4><p><strong>题意：</strong></p><p>不吉利的数字为所有含有4或62的号码。对于每个整数对，输出一个不含有不吉利数字的统计个数。</p><p><strong>思路：</strong></p><p>$dp[pos][pre]$：长度为pos的前一位是否为6的不含有不吉利数字的个数。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> p[<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> dp[<span class="hljs-number">10</span>][<span class="hljs-number">2</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> pre,<span class="hljs-keyword">int</span> state,<span class="hljs-keyword">bool</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(!limit&amp;&amp;dp[pos][state]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> dp[pos][state];    <span class="hljs-keyword">int</span> up=limit?p[pos]:<span class="hljs-number">9</span>;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)    &#123;        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">4</span>)<span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>&amp;&amp;pre==<span class="hljs-number">6</span>)<span class="hljs-keyword">continue</span>;        ans+=dfs(pos<span class="hljs-number">-1</span>,i,i==<span class="hljs-number">6</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>,limit&amp;&amp;i==p[pos]);    &#125;    <span class="hljs-keyword">if</span>(!limit)dp[pos][state]=ans;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        p[pos++]=x%<span class="hljs-number">10</span>;        x/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l,r;    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(l==<span class="hljs-number">0</span>&amp;&amp;r==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,solve(r)-solve(l<span class="hljs-number">-1</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="HDU3652"><a href="#HDU3652" class="headerlink" title="HDU3652"></a>HDU3652</h4><p><strong>题意：</strong></p><p>给出一个n，求比n小的包含13且能被13整除的数字个数。</p><p><strong>思路：</strong></p><script type="math/tex; mode=display">dp[pos][ext][mod][cur]$$：长度为pos的是否存在13的余数为mod的前一位是否为1的数字个数。**代码：**<pre><code class="hljs c++"><span class="hljs-keyword">int</span> dp[<span class="hljs-number">15</span>][<span class="hljs-number">2</span>][<span class="hljs-number">15</span>][<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> a[<span class="hljs-number">15</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> ext,<span class="hljs-keyword">int</span> mod,<span class="hljs-keyword">int</span> cur,<span class="hljs-keyword">bool</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//printf("%d %d %d %d %d\n",pos,ext,mod,cur,limit);</span>    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> (ext&amp;&amp;mod==<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(!limit&amp;&amp;dp[pos][ext][mod][cur]!=<span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> dp[pos][ext][mod][cur];    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)        ans+=dfs(pos<span class="hljs-number">-1</span>,ext||(cur&amp;&amp;i==<span class="hljs-number">3</span>),(mod*<span class="hljs-number">10</span>+i)%<span class="hljs-number">13</span>,i==<span class="hljs-number">1</span>,limit&amp;&amp;i==a[pos]);    <span class="hljs-keyword">if</span>(!limit)dp[pos][ext][mod][cur]=ans;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        a[pos++]=x%<span class="hljs-number">10</span>;        x/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,solve(n));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>#### BZOJ1026**题意：**不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。[A,B]总共有多少个windy数？**思路：**$$dp[pos][pre]$$：长度为len，前面一位为pre的数字个数。注意一下前导零就可以了。**代码：**<pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>];ll dp[<span class="hljs-number">20</span>][<span class="hljs-number">10</span>];<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> pre,<span class="hljs-keyword">bool</span> lead,<span class="hljs-keyword">bool</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//printf("%d %d %d %d\n",pos,pre,lead,limit);</span>    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1l</span>l;    <span class="hljs-keyword">if</span>(!limit&amp;&amp;!lead&amp;&amp;dp[pos][pre]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> dp[pos][pre];    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)    &#123;        <span class="hljs-keyword">if</span>(!lead&amp;&amp;<span class="hljs-built_in">abs</span>(pre-i)&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">continue</span>;        ans+=dfs(pos<span class="hljs-number">-1</span>,i,lead&amp;&amp;i==<span class="hljs-number">0</span>,limit&amp;&amp;i==a[pos]);    &#125;    <span class="hljs-keyword">if</span>(!limit&amp;&amp;!lead)dp[pos][pre]=ans;    <span class="hljs-comment">//printf("%d %d %d:%lld\n",pos,pre,limit,ans);</span>    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        a[pos++]=x%<span class="hljs-number">10</span>;        x/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ll l,r;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;l,&amp;r);    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-comment">//printf("%lld\n",solve(r));</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(r)-solve(l<span class="hljs-number">-1</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>#### CodeForces55D**题意：**一个正整数是漂亮数 ，当且仅当它能够被自身的各非零数字整除。求给定范围中有多少个漂亮数。**思路：**一个数可以被各位数字整除就相当于可以被各位数字的最大公倍数整除。$$dp[len][lcm][mod]$$：长度为len的各位数字的最大公倍数为lcm的被2520除余数为mod的数字个数。因为lcm最大可以是2520（0～9的最大公约数），直接开$$19*2520*2520$$会爆，但是可以存在的lcm并没有这么多，所以离散化一下就好了。**代码：**<pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>];ll dp[<span class="hljs-number">20</span>][<span class="hljs-number">100</span>][<span class="hljs-number">2525</span>];<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;mp;<span class="hljs-keyword">int</span> cnt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a&lt;b)&#123;<span class="hljs-keyword">int</span> temp;temp=a;a=b;b=temp;&#125;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">while</span>(a%b)&#123;<span class="hljs-keyword">int</span> r=a%b;a=b;b=r;&#125;    <span class="hljs-keyword">return</span> b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> b;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">return</span> a*b/gcd(a,b);&#125;<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> lc,<span class="hljs-keyword">int</span> mod,<span class="hljs-keyword">bool</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> lc==<span class="hljs-number">0</span>||mod%lc==<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">if</span>(!mp[lc])mp[lc]=++cnt;    temp=mp[lc];    <span class="hljs-keyword">if</span>(!limit&amp;&amp;dp[pos][temp][mod]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> dp[pos][temp][mod];    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)        ans+=dfs(pos<span class="hljs-number">-1</span>,lcm(lc,i),(mod*<span class="hljs-number">10</span>+i)%<span class="hljs-number">2520</span>,limit&amp;&amp;i==a[pos]);    <span class="hljs-keyword">if</span>(!limit)dp[pos][temp][mod]=ans;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        a[pos++]=x%<span class="hljs-number">10</span>;        x/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    ll l,r;    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dp));    cnt=<span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;l,&amp;r);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(r)-solve(l<span class="hljs-number">-1</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>#### POJ3252**题意：**求区间[a,b]中，转换成2进制后，0的个数>=1的个数的数字的个数**思路：**$$dp[pos][num0][num1]$$：长度为pos的0的个数为num0的1的个数为num1的满足条件的数的个数。注意处理前导0就好了。**代码：**<pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">100</span>];ll dp[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> num0,<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">bool</span> lead,<span class="hljs-keyword">bool</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> num0&gt;=num1;    <span class="hljs-keyword">if</span>(!limit&amp;&amp;!lead&amp;&amp;dp[pos][num0][num1]!=<span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> dp[pos][num0][num1];    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">1</span>;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)        ans+=dfs(pos<span class="hljs-number">-1</span>,i==<span class="hljs-number">0</span>&amp;&amp;!lead?num0+<span class="hljs-number">1</span>:num0,i==<span class="hljs-number">1</span>?num1+<span class="hljs-number">1</span>:num1,lead&amp;&amp;i==<span class="hljs-number">0</span>,limit&amp;&amp;i==a[pos]);    <span class="hljs-comment">//printf("%d %d %d %d:%lld\n",pos,num0,num1,limit,ans);</span>    <span class="hljs-keyword">if</span>(!limit&amp;&amp;!lead)dp[pos][num0][num1]=ans;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        a[pos++]=x%<span class="hljs-number">2</span>;        x/=<span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dp));    ll l,r;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;l,&amp;r);    <span class="hljs-comment">//scanf("%lld",&amp;l);</span>    <span class="hljs-comment">//printf("%lld\n",solve(l));</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(r)-solve(l<span class="hljs-number">-1</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>#### HDU4734**题意：**求F(0)~F(B)中,有几个小于等于 F(A)的;对于数字$$A_nA_{n-1}A_{n-2} ... A_2A_1$$，$$ F(x) = A_n * 2^{n-1} + A_{n-1} * 2^{n-2} + ... + A_2 * 2 + A_1 * 1$$。**思路：**因为有多组，所以F(A)总是在变的，所以这个状态记录就不能只是记录长度为pos的值为val的数字个数，而应该，$$dp[pos][tot]$$：长度为pos的函数值小于tot的数字个数。所以转移就是$$dp[pos][tot]+=dp[pos-1][tot-i*(1<<pos)]$$。**代码：**<pre><code class="hljs c++"><span class="hljs-keyword">int</span> sum;<span class="hljs-keyword">int</span> pre[<span class="hljs-number">20</span>];<span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>];<span class="hljs-keyword">int</span> dp[<span class="hljs-number">20</span>][<span class="hljs-number">10000</span>];<span class="hljs-comment">//长度为i且小于等于j的数的个数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        sum+=x%<span class="hljs-number">10</span>*(<span class="hljs-number">1</span>&lt;&lt;pos);        pos++;        x/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-comment">//printf("%d\n",sum);</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> tot,<span class="hljs-keyword">bool</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//printf("%d %d %d\n",pos,tot,limit);</span>    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> tot&gt;=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(!limit&amp;&amp;dp[pos][tot]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> dp[pos][tot];    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)    &#123;        <span class="hljs-keyword">if</span>(tot-i*(<span class="hljs-number">1</span>&lt;&lt;pos)&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        ans+=dfs(pos<span class="hljs-number">-1</span>,tot-i*(<span class="hljs-number">1</span>&lt;&lt;pos),limit&amp;&amp;i==up);    &#125;    <span class="hljs-keyword">if</span>(!limit)dp[pos][tot]=ans;    <span class="hljs-comment">//printf("%d %d %d:%d\n",pos,tot,limit,ans);</span>    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        a[pos++]=x%<span class="hljs-number">10</span>;        x/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span>,sum,<span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    <span class="hljs-keyword">int</span> l,r;    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kase=<span class="hljs-number">1</span>;kase&lt;=t;kase++)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;l,&amp;r);        calc(l);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case #%d: %d\n"</span>,kase,solve(r));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>#### HDU3709**题意：**给定区间[a,b]，求区间内平衡数的个数。所谓平衡数即有一位做平衡点，左右两边数字的力矩相等。**思路：**本来是想四维的，结果MLE了。三维也是可以的。$$dp[d][pos][sum]$$：平衡点为d，长度为pos，力矩和为sum的数字个数。注意重复0的计算要减去。**代码：**<pre><code class="hljs c++"><span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>];ll dp[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>][<span class="hljs-number">2000</span>];<span class="hljs-keyword">int</span> sign;<span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> d,<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> sum,<span class="hljs-keyword">bool</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//if(d==0)printf("%d %d %d %d %d\n",d,pos,l,r,limit);</span>    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> sum==<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(!limit&amp;&amp;dp[d][pos][sum]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> dp[d][pos][sum];    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)    &#123;        <span class="hljs-comment">//printf("i=%d %d %d %d %d %d\n",i,d,pos-1,pos&lt;d?l+(d-pos)*i:l,pos&gt;d?r+(pos-d)*i:r,limit&amp;&amp;i==a[pos]);</span>        ans+=dfs(d,pos<span class="hljs-number">-1</span>,sum+(pos-d)*i,limit&amp;&amp;i==a[pos]);    &#125;    <span class="hljs-keyword">if</span>(!limit)dp[d][pos][sum]=ans;    <span class="hljs-comment">//if(d==0)printf("%d %d %d %d %d:%lld\n",d,pos,l,r,limit,ans);</span>    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        a[pos++]=x%<span class="hljs-number">10</span>;        x/=<span class="hljs-number">10</span>;    &#125;    ll ans=<span class="hljs-number">0</span>;    sign=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;pos;i++)    &#123;        ll temp=dfs(i,pos<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>);        <span class="hljs-comment">//printf("%d:%lld\n",i,temp);</span>        ans+=temp;    &#125;    <span class="hljs-keyword">return</span> ans-pos;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t;    ll l,r;    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dp));    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;l,&amp;r);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(r)-solve(l<span class="hljs-number">-1</span>));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>#### HDU4507**题意：**如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关：1、整数中某一位是7；2、整数的每一位加起来的和是7的整数倍；3、这个整数是7的整数倍；求在一定区间内和7无关的数字的平方和。**思路：**$$dp[pos][mod][tot]$$：长度为pos的每位加起来的和的余数为mod的余数为tot的数字。考虑一个例子，245,213,257，它们的平方和应该这样算：$$245^2+213^2+257^2</script><script type="math/tex; mode=display">=(200+45)^2+(200+13)^2(200+57)^2</script><script type="math/tex; mode=display">=200^2*3+45^2+13^2+57^2+2*200*(45+13+57)</script><p>所以知道不仅要记录平方和，还要记录个数，和。</p><p>然后记忆化搜索就可以了。</p><p><strong>代码：</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    ll num,sum,sqsum;<span class="hljs-comment">//个数、和、平方和</span>&#125;dp[<span class="hljs-number">20</span>][<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>];ll xs[<span class="hljs-number">20</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    xs[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">18</span>;i++)        xs[i]=(xs[i<span class="hljs-number">-1</span>]*<span class="hljs-number">10</span>)%MOD;&#125;<span class="hljs-function">node <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> mod,<span class="hljs-keyword">int</span> tot,<span class="hljs-keyword">int</span> pre,<span class="hljs-keyword">bool</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//printf("%d %d %d %d\n",pos,mod,tot,limit);</span>    <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">-1</span>)    &#123;        node temp;        <span class="hljs-keyword">if</span>(mod!=<span class="hljs-number">0</span>&amp;&amp;tot!=<span class="hljs-number">0</span>)        &#123;            temp.num=<span class="hljs-number">1l</span>l;            temp.sum=<span class="hljs-number">0</span>;            temp.sqsum=<span class="hljs-number">0</span>;            <span class="hljs-comment">//printf("%lld %lld %lld\n",temp.num,temp.sum,temp.sqsum);</span>        &#125;        <span class="hljs-keyword">else</span> temp.num=temp.sum=temp.sqsum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> temp;    &#125;    <span class="hljs-keyword">if</span>(!limit&amp;&amp;dp[pos][mod][tot].num!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> dp[pos][mod][tot];    <span class="hljs-keyword">int</span> up=limit?a[pos]:<span class="hljs-number">9</span>;    node ans;    ans.num=ans.sum=ans.sqsum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=up;i++)    &#123;        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">7</span>)<span class="hljs-keyword">continue</span>;        node temp=dfs(pos<span class="hljs-number">-1</span>,(mod+i)%<span class="hljs-number">7</span>,(tot*<span class="hljs-number">10</span>+i)%<span class="hljs-number">7</span>,i,limit&amp;&amp;i==up);        ans.num=(ans.num+temp.num)%MOD;        ans.sum=(ans.sum+(temp.num*i*xs[pos]%MOD+temp.sum)%MOD)%MOD;        ans.sqsum=(ans.sqsum+((i*i*xs[pos]%MOD*xs[pos]%MOD*temp.num%MOD+temp.sqsum)%MOD+<span class="hljs-number">2</span>*i*xs[pos]%MOD*temp.sum%MOD)%MOD)%MOD;    &#125;    <span class="hljs-keyword">if</span>(!limit)dp[pos][mod][tot]=ans;    <span class="hljs-comment">//printf("%d %d %d %d:%lld %lld %lld\n",pos,mod,tot,limit,ans.num,ans.sum,ans.sqsum);</span>    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">node <span class="hljs-title">solve</span><span class="hljs-params">(ll x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(x)    &#123;        a[pos++]=x%<span class="hljs-number">10</span>;        x/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> dfs(pos<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    init();    <span class="hljs-keyword">int</span> t;    ll l,r;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>;j++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">10</span>;k++)                dp[i][j][k].num=dp[i][j][k].sum=dp[i][j][k].sqsum=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(t--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;l,&amp;r);        <span class="hljs-comment">//scanf("%lld",&amp;l);</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,(solve(r).sqsum-solve(l<span class="hljs-number">-1</span>).sqsum+MOD)%MOD);        <span class="hljs-comment">//node temp=solve(l);</span>        <span class="hljs-comment">//printf("%lld %lld %lld\n",temp.num,temp.sum,temp.sqsum);</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数取模</title>
    <link href="/2018/01/25/%E7%BB%84%E5%90%88%E6%95%B0%E5%8F%96%E6%A8%A1/"/>
    <url>/2018/01/25/%E7%BB%84%E5%90%88%E6%95%B0%E5%8F%96%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<p>组合数取模就是求<script type="math/tex">C_{n}^{m}\%p</script>的值。</p><hr><p><script type="math/tex">1\leq m\leq n\leq1000和1\leq p\leq 10^9</script>。</p><p>这个问题比较简单，组合数的计算可以靠<strong>杨辉三角</strong>，那么由于n和m的范围小，直接两层循环即可。</p><p><script type="math/tex">C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}</script>；</p><pre><code class="hljs c++">c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5003</span>;i++)<span class="hljs-comment">//j是上面，i是下面</span>&#123;    c[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)    &#123;        c[i][j]=(c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%MOD;        <span class="hljs-comment">//printf("%lld %lld %lld\n",i,j,c[i][j]);</span>    &#125;&#125;</code></pre><hr><p><script type="math/tex">1\leq m\leq n\leq10^8和2\leq p\leq 10^5</script>，并且p是素数。</p><p>这个问题有个叫做Lucas的定理。</p><p> <strong>题意：</strong>求<script type="math/tex">C_{n}^{m}\%p</script>，其中<script type="math/tex">1\leq p\leq 10^9</script>，并且p是素数。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">PowerMod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k;    k=a;    k=k%c;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)        ans=(ans*k)%c;        b&gt;&gt;=<span class="hljs-number">1</span>;        k=(k*k)%c;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(m&gt;n)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)    &#123;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a=(n+i-m)%p;        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b=i%p;        ans=ans*(a*PowerMod(b,p<span class="hljs-number">-2</span>,p)%p)%p;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Lucas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,m;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;n,&amp;m)!=EOF)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,Lucas(n,m,MOD));   <span class="hljs-comment">//n为下面的数，m为上面的数</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><p><script type="math/tex">1\leq m\leq n\leq10^6和2\leq p\leq 10^5</script>，并且p可能为合数。</p><p>这样的话先采取暴力分解，然后快速幂即可。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">200005</span>;<span class="hljs-keyword">bool</span> prime[N];<span class="hljs-keyword">int</span> p[N];<span class="hljs-keyword">int</span> cnt;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">isprime</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cnt = <span class="hljs-number">0</span>;    <span class="hljs-built_in">memset</span>(prime,<span class="hljs-literal">true</span>,<span class="hljs-keyword">sizeof</span>(prime));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>; i&lt;N; i++)    &#123;        <span class="hljs-keyword">if</span>(prime[i])        &#123;            p[cnt++] = i;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+i; j&lt;N; j+=i)                prime[j] = <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;<span class="hljs-function">LL <span class="hljs-title">quick_mod</span><span class="hljs-params">(LL a,LL b,LL m)</span></span><span class="hljs-function"></span>&#123;    LL ans = <span class="hljs-number">1</span>;    a %= m;    <span class="hljs-keyword">while</span>(b)    &#123;        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)        &#123;            ans = ans * a % m;            b--;        &#125;        b &gt;&gt;= <span class="hljs-number">1</span>;        a = a * a % m;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">LL <span class="hljs-title">Work</span><span class="hljs-params">(LL n,LL p)</span></span><span class="hljs-function"></span>&#123;    LL ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(n)    &#123;        ans += n / p;        n /= p;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function">LL <span class="hljs-title">Solve</span><span class="hljs-params">(LL n,LL m,LL P)</span></span><span class="hljs-function"></span>&#123;    LL ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;cnt &amp;&amp; p[i]&lt;=n; i++)    &#123;        LL x = Work(n, p[i]);        LL y = Work(n - m, p[i]);        LL z = Work(m, p[i]);        x -= (y + z);        ans *= quick_mod(p[i],x,P);        ans %= P;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> T;    isprime();    <span class="hljs-built_in">cin</span>&gt;&gt;T;    <span class="hljs-keyword">while</span>(T--)    &#123;        LL n,m,P;        <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;P;        n += m - <span class="hljs-number">2</span>;        m--;        <span class="hljs-built_in">cout</span>&lt;&lt;Solve(n,m,P)&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>逆元求取组合数</strong></p><p>由定理可知：如果用C(n, r)表示n-元素集的r-组合的个数，有</p><p>C(n,r)=n!r!∗(n−r)!</p><p>而我们的目标就是计算 C(n,r)%mod 的值。</p><p>由数论的知识我们知道，模运算的加法，减法，乘法和四则运算类似，即：<br>模运算与基本四则运算有些相似，但是除法例外。其规则如下：</p><ul><li>(a + b) % p = (a % p + b % p) % p</li><li>(a - b) % p = (a % p - b % p) % p</li><li>(a <em> b) % p = (a % p </em> b % p) % p</li></ul><p>但对于除法却不成立，即(a / b) % p ≠ (a % p / b % p) % p 。</p><p>显然数学家们是不能忍受这种局面的，他们扔出了<strong>“逆元”</strong>来解决这个问题。那么什么是逆元？ 逆元和模运算中的除法又有说明关系呢？</p><p>首先给出数论中的解释：</p><blockquote><p>对于正整数 a 和 p，如果有 ax≡1(modp)，那么把这个同余方程中 x 的最小正整数解叫做 a 模 p 的逆元。</p></blockquote><p>什么意思呢？ 就是指，如果 ax%p=1 ， 那么x的最小正整数解就是 a 的逆元。</p><p>现在我们来解决模运算的除法问题。假设 </p><p>ab</p><p>同时存在另一个数 x 满足</p><p>ax%p=m</p><p>由模运算对乘法成立，两边同时乘以 b ，得到：</p><p>a%p=(m(b%p))%p</p><p>如果 a 和 b 均小于模数 p 的话，上式可以改写为：</p><p>a=bm%p</p><p>等式两边再同时乘以 x, 得到： </p><p>ax%p=m%p=xbm%p</p><p>因此可以得到： </p><p>bx%p=1</p><p>哎，x是b的逆元呀（x 在模运算的乘法中等同于 1b, 这就是逆元的意义）</p><p>由以上过程我们看到，求取 (ab%p) 等同于 求取 (a∗(b的逆元)%p) 。 因此，求模运算的除法问题就转化为就一个数的逆元问题了。</p><p>而求取一个数的逆元，有两种方法</p><blockquote><ol><li>拓展欧几里得算法</li><li>费马小定理</li></ol></blockquote><p>对于利用拓展欧几里得算法求逆元，很显然，如果bx%p=1，那么 bx+py=1, 直接利用 exgcd(b, p, x, y)（代码实现在后面给出），则 (x%p+p)%p 即为 b 的逆元。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=MAXN;i++)        fac[i]=fac[i<span class="hljs-number">-1</span>]*i%MOD;    inv[MAXN]=PowerMod(fac[MAXN],MOD<span class="hljs-number">-2</span>,MOD);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=MAXN<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)        inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%MOD;&#125;<span class="hljs-function">ll <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(n&lt;m)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> fac[n]*inv[m]%MOD*inv[n-m]%MOD;&#125;</code></pre><p>对于第二种方法，因为在算法竞赛中模数p总是质数，所以可以利用<a href="http://baike.baidu.com/view/263807.htm" target="_blank" rel="noopener">费马小定理</a> ： </p><p>bp−1%p=1</p><p>可以直接得到 b 的逆元是 bp−2 , 使用 <strong>快速幂</strong> 求解即可。</p><p>明白了以上几个关键点，那么求取组合数 C(n,r) 的算法就呼之欲出了：</p><ol><li>求取1到n的阶乘对 mod 取模的结果存入数组 JC[] 中；</li><li>求取 C(n,r) 时， 先利用“拓展欧几里得算法”或者“费马小定理+快速幂”求 JC[r]的逆元存入临时变量 x1 ;</li><li>然后计算JC[n]∗x1%mod 存入临时变量 x2;（x2 即为n!r!%mod 的值）</li><li>求取JC[n - r] 的逆元存入临时变量 x3;</li><li>则可以得到 C(n,r)=x2∗x3%mod</li></ol><p>下面是方法二的代码片段：</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;const LL maxn(1000005), mod(1e9 + 7);LL Jc[maxn]; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calJc</span><span class="hljs-params">()</span>    <span class="hljs-comment">//求maxn以内的数的阶乘</span></span><span class="hljs-function"></span>&#123;   Jc[<span class="hljs-number">0</span>] = Jc[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;   <span class="hljs-keyword">for</span>(LL i = <span class="hljs-number">2</span>; i &lt; maxn; i++)       Jc[i] = Jc[i - <span class="hljs-number">1</span>] * i % mod;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">//拓展欧几里得算法求逆元</span><span class="hljs-comment">void exgcd(LL a, LL b, LL &amp;x, LL&amp;y)    //拓展欧几里得算法</span><span class="hljs-comment">&#123;</span><span class="hljs-comment">   if(!b) x = 1, y = 0;</span><span class="hljs-comment">   else</span><span class="hljs-comment">    &#123;</span><span class="hljs-comment">       exgcd(b, a % b, y, x);</span><span class="hljs-comment">       y -= x * (a / b);</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment"> </span><span class="hljs-comment">LL niYuan(LL a, LL b)   //求a对b取模的逆元</span><span class="hljs-comment">&#123;</span><span class="hljs-comment">   LL x, y;</span><span class="hljs-comment">   exgcd(a, b, x, y);</span><span class="hljs-comment">   return (x + b) % b;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span> <span class="hljs-comment">//费马小定理求逆元</span><span class="hljs-function">LL <span class="hljs-title">pow</span><span class="hljs-params">(LL a, LL n, LL p)</span>    <span class="hljs-comment">//快速幂 a^n % p</span></span><span class="hljs-function"></span>&#123;   LL ans = <span class="hljs-number">1</span>;   <span class="hljs-keyword">while</span>(n)    &#123;       <span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) ans = ans * a % p;       a = a * a % p;       n &gt;&gt;= <span class="hljs-number">1</span>;    &#125;   <span class="hljs-keyword">return</span> ans;&#125; <span class="hljs-function">LL <span class="hljs-title">niYuan</span><span class="hljs-params">(LL a, LL b)</span>   <span class="hljs-comment">//费马小定理求逆元</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(a, b - <span class="hljs-number">2</span>, b);&#125; <span class="hljs-function">LL <span class="hljs-title">C</span><span class="hljs-params">(LL a, LL b)</span>    <span class="hljs-comment">//计算C(a, b)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">return</span> Jc[a] * niYuan(Jc[b], mod) % mod       * niYuan(Jc[a - b], mod) % mod;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论相关</title>
    <link href="/2018/01/25/%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/"/>
    <url>/2018/01/25/%E6%95%B0%E8%AE%BA%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h5 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a><strong>费马小定理</strong></h5><p>假如p是质数，且gcd(a,p)=1，那么 <script type="math/tex">a^{p-1}≡1（mod p）</script>，即：假如a是整数，p是质数，且a,p互质(即两者只有一个公约数1)，那么a的(p-1)次方除以p的余数恒等于1。</p><p>和同余定理可以一起用在当指数很大的时候。比如要整体MOD 1e9+7，可以对指数MOD 1e9+6，然后再将快速幂得到的MOD 1e9+7。参见nbuoj2700。</p><p>逆元一般用扩展欧几里得算法来求得，如果<img src="http://img.blog.csdn.net/20140613102712781" srcset="/img/loading.gif" alt="img">为素数，那么还可以根据费马小定理得到逆元为<img src="http://img.blog.csdn.net/20140613103413828" srcset="/img/loading.gif" alt="img">。</p><h5 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h5><p>如果ax≡1 (mod p),且gcd(a,p)=1（a与p互质），则称a关于模p的乘法逆元为x。<br>a和p互质，a才有关于p的逆元。b的逆元，我们用inv(b)来表示，那么(a/b)%p=(a×inv(b))%p=(a%p×inv(b)%p)%p，这样就把除法，完全转换为乘法了 。<br>逆元的求法：<br>方法一：用费马小定理。<br>在p是素数的情况下，x^(p−2)即为x关于p的逆元。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">PowerMod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k;    k=a;    k=k%c;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)        ans=(ans*k)%c;        b=b/<span class="hljs-number">2</span>;        k=(k*k)%c;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Fermat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> PowerMod(x,p<span class="hljs-number">-2</span>,p);&#125;</code></pre><p>方法二：用扩展欧几里得算法。<br>因为ax≡1(mod p)，所以ax-py=1，应用一下扩展欧几里得算法即可。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">extgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> d,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span>   <span class="hljs-comment">//a,b都为正整数</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;d=a;x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;&#125;    <span class="hljs-keyword">else</span>&#123;extgcd(b,a%b,d,y,x);y=y-x*(a/b);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> d,x,y;    extgcd(a,p,d,x,y);    <span class="hljs-keyword">return</span> d==<span class="hljs-number">1</span>?(x%p+p)%p:<span class="hljs-number">-1</span>; <span class="hljs-comment">//x是应为正整数，即需要若x为负整数，则需要将之化正，即与负数取模同理，将x加上p，直至x&gt;0为止，所得的数即为最小的乘法逆元。</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a,p;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;p);    inverse(a,p);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>方法三：线性时间求所有逆元。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mutl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mod)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> inv[M];inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//边界条件 </span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=M;i++) inv[i]=((-(mod/i)*inv[mod%i])%mod+mod)%mod; <span class="hljs-comment">//防止出现负数 </span><span class="hljs-keyword">return</span> ; &#125;</code></pre><p>这个方法不限于求单个逆元，比前两个好，它可以在O(n)的复杂度内算出n个数的逆元，递归就是上面的写法，加一个记忆性递归，就可以了，递推这么写：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> inv[N];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;    inv[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;N;i++)&#123;        inv[i]=(p-p/i)*inv[p%i]%p;    &#125;&#125;</code></pre><p>阶乘的逆元</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    fac[<span class="hljs-number">0</span>]=fac[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=MAXN;i++)        fac[i]=fac[i<span class="hljs-number">-1</span>]*i%MOD;    inv[MAXN]=PowerMod(fac[MAXN],MOD<span class="hljs-number">-2</span>,MOD);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=MAXN<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)        inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%MOD;&#125;</code></pre><h5 id="调和级数"><a href="#调和级数" class="headerlink" title="调和级数"></a>调和级数</h5><p>1+1/2+1/3+……+1/n=ln(n)。</p><h5 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h5><p>任何一个大于1的自然数N，有标准分解式<script type="math/tex">N=p_1^{a_1}p_2^{a_2}...p_n^{a_n}</script>。</p><p>它的正因子个数为<script type="math/tex">(1+a_1)(1+a_2)...(1+a_n)</script>。</p><p>正因子数之和为<script type="math/tex">(1+p_1+p_1^2+...+p_1^{a_1})(1+p_2+p_2^2+...+p_2^{a_2})...(1+p_n+p_n^2+...+p_n^{a_n})</script>。</p><h5 id="费马大定理"><a href="#费马大定理" class="headerlink" title="费马大定理"></a>费马大定理</h5><p>当整数n&gt;2时，关于x,y,z的方程<script type="math/tex">x^n+y^n=z^n</script>没有正整数解。</p><h5 id="勾股数的构造"><a href="#勾股数的构造" class="headerlink" title="勾股数的构造"></a>勾股数的构造</h5><p><script type="math/tex">a^2+b^2=c^2</script>，已知a，构造出b和c。</p><p>若a=1或a=2，无解；</p><p>若a为奇数，<script type="math/tex">b=\frac{a^2-1}{2}</script>，<script type="math/tex">c=\frac{a^2+1}{2}</script>；</p><p>若a为偶数，<script type="math/tex">b=\frac{a^2}{4}-1</script>，<script type="math/tex">c=\frac{a^2}{4}+1</script>。</p><p>过程：</p><p>因为<script type="math/tex">a=b^2-c^2</script>所以<script type="math/tex">a=(b+c)*(b-c)</script>。</p><p>当<script type="math/tex">a^2\%2=1</script>时，<script type="math/tex">\left\{\begin{array}{}c+b=a^2 \\c-b=1\end{array}\right.</script>。</p><p>当<script type="math/tex">a^2\%2=0</script>时，<script type="math/tex">\left\{\begin{array}{}c+b=\frac{a^2}{2} \\c-b=2\end{array}\right.</script>。</p><p>解方程即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度和低精度的乘除法&amp;&amp;大数取模</title>
    <link href="/2018/01/25/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%92%8C%E4%BD%8E%E7%B2%BE%E5%BA%A6%E7%9A%84%E4%B9%98%E9%99%A4%E6%B3%95-%E5%A4%A7%E6%95%B0%E5%8F%96%E6%A8%A1/"/>
    <url>/2018/01/25/%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%92%8C%E4%BD%8E%E7%B2%BE%E5%BA%A6%E7%9A%84%E4%B9%98%E9%99%A4%E6%B3%95-%E5%A4%A7%E6%95%B0%E5%8F%96%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h5 id="高低精度乘除法"><a href="#高低精度乘除法" class="headerlink" title="高低精度乘除法"></a><strong>高低精度乘除法</strong></h5><p>直接每位相乘即可，再考虑最后进位，除法也考虑进位。</p><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;len;j++)            a[i][j]=a[i<span class="hljs-number">-1</span>][j]*(<span class="hljs-number">4</span>*i<span class="hljs-number">-2</span>);        c=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;len;j++)        &#123;            a[i][j]=a[i][j]+c;            c=a[i][j]/<span class="hljs-number">10</span>;            a[i][j]=a[i][j]%<span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">while</span>(c!=<span class="hljs-number">0</span>)        &#123;            a[i][len++]=c%<span class="hljs-number">10</span>;            c=c/<span class="hljs-number">10</span>;        &#125;        c=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(j=len<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)        &#123;            a[i][j]=<span class="hljs-number">10</span>*c+a[i][j];            c=a[i][j]%(i+<span class="hljs-number">1</span>);            a[i][j]=a[i][j]/(i+<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">for</span>(j=len<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)            <span class="hljs-keyword">if</span>(a[i][j]!=<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        len=j+<span class="hljs-number">1</span>;        l[i]=j+<span class="hljs-number">1</span>;</code></pre><h5 id="大数取模"><a href="#大数取模" class="headerlink" title="大数取模"></a><strong>大数取模</strong></h5><pre><code class="hljs c++"><span class="hljs-keyword">char</span> s[<span class="hljs-number">200</span>];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mod 10000010;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">while</span>(gets(s))&#123;   <span class="hljs-keyword">int</span> k=<span class="hljs-built_in">strlen</span>(s),sum=<span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)  sum=(sum*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">'0'</span>)%mod;    /当然要是担心sum还可能溢出，那就对里边再拆开来取余  <span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;&#125; &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈</title>
    <link href="/2018/01/25/%E5%8D%9A%E5%BC%88/"/>
    <url>/2018/01/25/%E5%8D%9A%E5%BC%88/</url>
    
    <content type="html"><![CDATA[<h5 id="Bash游戏（同余）："><a href="#Bash游戏（同余）：" class="headerlink" title="Bash游戏（同余）："></a><strong>Bash游戏（同余）：</strong></h5><p>有一堆石子共有N个。A B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N和K，问最后谁能赢得比赛。</p><p>小学的时候沉迷的游戏…</p><p>如果n可以整除k+1的话，B有必胜策略，只要报k+1-A报的数就可以了。</p><p>如果不整除的话，由于A先手，所以A就胜了。</p><h5 id="Nim游戏（异或）："><a href="#Nim游戏（异或）：" class="headerlink" title="Nim游戏（异或）："></a><strong>Nim游戏（异或）：</strong></h5><p>有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。</p><p>如果把n堆抽象为n个非负整数,再将n个整数转化为二进制,然后对n个二进制数按位相加(不进位),若每一位相加都为偶数,那么称这个状态为偶状态,否则称它为奇状态.</p><p>事实一：假设轮到你行动了，这时堆里的Nim和为0。这样不管你怎么做，你动作后的Nim和不会等于0.</p><p>事实二：假设轮到你行动了，这时堆里的Nim和不为0。但是可以保证的是，存在一种取法能在你行动后的堆的Nim和为0。</p><p>现在如果你是玩家A，所以你先走。接着假设现在堆里的Nim和不等于0.你的策略将会是这样:如果可能尽可能使得下一个Nim和，也就是你动作后的Nim和为0.这也意味着无论B如何动作通过事实1可知，B的这个动作会把下个Nim和变得不为0.</p><p>让我们开始，在表中记录每一步的Nim和：</p><div class="table-container"><table><thead><tr><th>下一个要走的玩家</th><th>Nim和</th><th>能否变为0？</th><th>下个Nim和</th></tr></thead><tbody><tr><td>A</td><td>非0</td><td>能</td><td>0</td></tr><tr><td>B</td><td>0</td><td>否</td><td>非0</td></tr><tr><td>A</td><td>非0</td><td>能</td><td>0</td></tr><tr><td>B</td><td>0</td><td>否</td><td>非0</td></tr><tr><td>A</td><td>非0</td><td>能</td><td>0</td></tr><tr><td>……</td><td></td><td></td></tr></tbody></table></div><p>这个像乒乓球一样的Nim和不断在0和非0之间转化，意味着你保证能赢！如果B注定要赢，她将要把最后一个硬币攒在手中。也就是说：她需要一个动作来产生零Nim和，但在我们看来这是不可能的。你的每次动作，都在把Nim和减少到0。当游戏进行到快到结尾时时，零Nim和就等价于没有一个硬币剩余——这时你就赢了。</p><p>那么对于n堆物品,只要判断它是否是奇状态就可以判断是否先手有必赢策略.</p><p>以非零Nim和打头的游戏，玩家A都有一个必胜策略。策略就是在每一步都让下一个Nim和减少到0.</p><p>如果游戏开始时为零Nim和，那么玩家B有一个必胜策略。当轮到B动作时不管玩家A在第一步做了什么将会留下一个非零Nim和。那么按同上的理由，必胜策略掌握在了B的手中。</p><p>但是求每个数的二进制表示略显麻烦,可以用位运算.</p><p>XOR 和判断: 如果有奇数个二进制数在第K位为1 那么在这一位上的和为奇,同样的，偶数个1和为偶.</p><p>很明显位运算xor满足我们的要求,偶数个1异或和为0,奇数个为1。</p><p>当这些数都做异或运算时等于0时,先手输，否则后手输。</p><p>如果Nim游戏中的规则稍微变动一下,每次最多只能取K个,怎么处理?</p><p>方法是将每堆石子数mod (k+1).</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,n,k,sum=<span class="hljs-number">0</span>,ch;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">while</span>(n--)    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;ch);        sum=sum^ch;    &#125;    <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"B\n"</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"A\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="反Nim游戏："><a href="#反Nim游戏：" class="headerlink" title="反Nim游戏："></a><strong>反Nim游戏：</strong></h5><p>在反尼姆博奕中判断必胜局面的条件有两点，满足任意一点先手都能取胜，即必胜局面。   </p><p>1：各堆石子数目异或结果不等于0，且存在有石子数目大于1的石子堆。</p><p>2：各堆石子数目异或结果等于0，且所有石子堆数目全部为1。</p><h5 id="Wythoff游戏（黄金分割）："><a href="#Wythoff游戏（黄金分割）：" class="headerlink" title="Wythoff游戏（黄金分割）："></a><strong>Wythoff游戏（黄金分割）：</strong></h5><p>有两堆各若干的物品，两人轮流从其中一堆取至少一件物品，至多不限，或从两堆中同时取相同件物品，规定最后取完者胜利。</p><p>这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势（先手必败）。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。</p><p>可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k。</p><p>若两堆物品的初始值为（x，y），且x&lt;y，则另z=y-x；记w=（int）[((sqrt(5)+1)/2）*z  ]；若w=x，则先手必败，否则先手必胜。</p><p>给你一个局面，让你求先手输赢，假设先手赢的话输出他第一次的取法。</p><p>​       首先讨论在两边同时取的情况，很明显两边同时取的话，不论怎样取他的差值是不会变的，那么我们可以根据差值计算出其中的小的值，然后加上差值就是大的一个值，当</p><p>然能取的条件是求出的最小的值不能大于其中小的一堆的石子数目。</p><p>​      加入在一堆中取的话，可以取任意一堆，那么其差值也是不定的，但是我们可以枚举差值，差值范围是0 —- 大的石子数目，然后根据上面的理论判断满足条件的话就是一种合理的取法。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a,b;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;b)!=EOF)    &#123;        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>&amp;&amp;b==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span>(a&gt;b)swap(a,b);        <span class="hljs-keyword">int</span> d=b-a;        <span class="hljs-keyword">int</span> x=(<span class="hljs-keyword">int</span>)((<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5</span>)+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>*d);<span class="hljs-comment">//这里注意！</span>        <span class="hljs-keyword">if</span>(x==a)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);            <span class="hljs-keyword">int</span> ans1,ans2;            <span class="hljs-keyword">if</span>(a&gt;x)            &#123;                ans1=x;                ans2=b-a+x;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,ans1,ans2);            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=b;i++)            &#123;                ans1=a;ans2=b-i;                <span class="hljs-keyword">if</span>(ans1&gt;ans2)swap(ans1,ans2);                d=ans2-ans1;                x=(<span class="hljs-keyword">int</span>)((<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5</span>)+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>*d);                <span class="hljs-keyword">if</span>(x==ans1)                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,ans1,ans2);            &#125;            <span class="hljs-keyword">if</span>(a!=b)<span class="hljs-comment">//如果a和b相同的话在a堆取和在b堆取是一样的</span>            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=a;i++)                &#123;                    ans1=a-i;ans2=b;                    <span class="hljs-keyword">if</span>(ans1&gt;ans2)swap(ans1,ans2);                    d=ans2-ans1;                    x=(<span class="hljs-keyword">int</span>)((<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">5</span>)+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>*d);                    <span class="hljs-keyword">if</span>(x==ans1)                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,ans1,ans2);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="斐波那契博弈（找规律）："><a href="#斐波那契博弈（找规律）：" class="headerlink" title="斐波那契博弈（找规律）："></a><strong>斐波那契博弈（找规律）：</strong></h5><p>1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜。</p><p>n = 2时输出second；<br>n = 3时也是输出second；<br>n = 4时，第一个人想获胜就必须先拿1个，这时剩余的石子数为3，此时无论第二个人如何取，第一个人都能赢，输出first；<br>n = 5时，first不可能获胜，因为他取2时，second直接取掉剩下的3个就会获胜，当他取1时，这样就变成了n为4的情形，所以输出的是second；<br>n = 6时，first只要去掉1个，就可以让局势变成n为5的情形，所以输出的是first；   n = 7时，first取掉2个，局势变成n为5的情形，故first赢，所以输出的是first；<br>n = 8时，当first取1的时候，局势变为7的情形，第二个人可赢，first取2的时候，局势变成n为6得到情形，也是第二个人赢，取3的时候，second直接取掉剩下的5个，所以n = 8时，输出的是second；<br> …………<br> 从上面的分析可以看出，n为2、3、5、8时，这些都是输出second，即必败点，仔细的人会发现这些满足斐波那契数的规律，可以推断13也是一个必败点。<br> 借助“Zeckendorf定理”（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。n=12时，只要谁能使石子剩下8且此次取子没超过3就能获胜。因此可以把12看成8+4，把8看成一个站，等价与对4进行”气喘操作”。又如13，13=8+5，5本来就是必败态，得出13也是必败态。也就是说，只要是斐波那契数，都是必败点。</p><p>先手胜当且仅当n不是斐波那契数（n为物品总数）</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制相关</title>
    <link href="/2018/01/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%85%B3/"/>
    <url>/2018/01/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><strong>枚举</strong></h5><p>正负数十进制转二进制（位运算）（用枚举法做POJ1222）</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x,i;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">5</span>;i&gt;=<span class="hljs-number">0</span>;i--)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,x&gt;&gt;i&amp;<span class="hljs-number">1</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>intput:</p><p>1</p><p>output:</p><p>000001</p><p>重点就在 <strong>x&gt;&gt;i&amp;1</strong>，按位与(&amp;) ：0&amp;0=0 ,0&amp;1=0 , 1&amp;0=0 ,1&amp;1=1，奇数的二进制最后一位全部为1，而偶数的二进制最后一位全部为0，那么用按位与运算符我们可以很方便地知道一个数是奇数还是偶数，只要让数字&amp;1 就可以了，因为 奇数&amp;1=1 ，而 偶数&amp;1=0。（类似于C语言书P230利用按位与清零的方法）</p><p>还有一道容斥原理中的二进制法。</p><h5 id="异或找奇数次"><a href="#异或找奇数次" class="headerlink" title="异或找奇数次"></a><strong>异或找奇数次</strong></h5><p>HDU 2095</p><p>统计所有数字出现的次数，然后输出奇数次的那个数。</p><p>利用异或运算。 符号是^. 异或是个位运算符号，具体是怎么操作的请百度，这里有个特性使得他能产生一种巧方法</p><p>a^a=0 0^c=c 看到上面这个式子是否你懂了呢？</p><p> 没错，例如样例 5 1 1 3 2 2 </p><p>如果我们用异或运算计算就是 1^1^3^2^2 </p><p> 由于1^1=0 2^2=0,那么就只剩下了唯一的一个3了。 </p><p>如果有3个3，那么前面偶数个3由于3^3=0,势必也会只留下一个孤单的3. 那么答案就只能是那个多余的数字了。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;  </span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><span class="hljs-function"></span>&#123;      <span class="hljs-keyword">int</span> n,x,ans;      <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)      &#123;          ans = <span class="hljs-number">0</span>;          <span class="hljs-keyword">while</span>(n--)          &#123;              <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;x);              ans ^= x;          &#125;          <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;</code></pre><h5 id="求某数除以最大的2的次方数的余数"><a href="#求某数除以最大的2的次方数的余数" class="headerlink" title="求某数除以最大的2的次方数的余数"></a><strong>求某数除以最大的2的次方数的余数</strong></h5><p>a&amp;-a（比如10，结果就是2，但是如果是8的话，结果是8）</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容斥原理&amp;&amp;欧拉函数</title>
    <link href="/2018/01/25/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    <url>/2018/01/25/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h5 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a><strong>容斥原理</strong></h5><p>求出一个数n在区间[1,m]里面有多少个数与它互质。假设数据不超过int型。</p><p>实现过程分为两步：</p><p>1.求出m的质因子 并保存在数组里面；</p><p>2.求出区间[1,n]里面有多少个数与m不互质。</p><p>二进制法：</p><p>出现奇数个数，就用加法，偶数个数用减法。<br>设质因数的个数为m。<br>有一个数字，它的二进制的每一位表示用了哪些数字，<br>比如5（101），其二进制的第一位和第三位（倒着数）是1，<br>则它表示用了第一个质因数和第三个质因数。<br>从1到m遍历一遍，就把所有的可能都包括了。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> pri[<span class="hljs-number">15</span>];     <span class="hljs-comment">//int型n不会超过10个</span><span class="hljs-keyword">int</span> num;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>     <span class="hljs-comment">//求n的质因子 </span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    num=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)        &#123;            pri[num++]=i;            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)            n=n/i;         &#125;    &#125;    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)pri[num++]=n;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">copr</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> s,j;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum,res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">1</span>&lt;&lt;num;i++)     <span class="hljs-comment">//1&lt;&lt;num相当于2的num次方 </span>    &#123;        s=<span class="hljs-number">0</span>;     <span class="hljs-comment">//1的个数</span>        sum=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;num;j++)        &#123;            <span class="hljs-keyword">if</span>(((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">1</span>&lt;&lt;j)&amp;i)     <span class="hljs-comment">//该结果不为0则倒数第j+1位为1</span>            &#123;                sum=sum*pri[j];                s++;            &#125;         &#125;        <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)res=res+x/sum;        <span class="hljs-keyword">else</span> res=res-x/sum;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>队列法：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> pri[<span class="hljs-number">15</span>];<span class="hljs-keyword">int</span> num;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> zh[<span class="hljs-number">10100</span>];     <span class="hljs-comment">//保存组合的乘积及正负号 </span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>     <span class="hljs-comment">//求n的质因子 </span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    num=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)        &#123;            pri[num++]=i;            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)            n=n/i;         &#125;    &#125;    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)pri[num++]=n;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">copr</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> top=<span class="hljs-number">0</span>,t,i,j;     <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res=<span class="hljs-number">0</span>;    zh[top++]=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;num;i++)    &#123;        t=top;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;t;j++)        zh[top++]=zh[j]pri[i](<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;top;i++)    res=res+x/zh[i];    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h5 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a><strong>欧拉函数</strong></h5><p>指一个数n在[1,n-1]区间有多少个数与它互质。</p><p>比如说，φ[n] = m代表的意思是在区间[1,n-1]里面有m个数与n互质。</p><p>欧拉函数公式：（我们假设n的质因子有x,y（重复的只算一次）） <script type="math/tex">φ[n]=n*(1-\frac{1}{x}) * (1-\frac{1}{y})</script>。若有多个继续添上即可。</p><p>下面介绍一些基本性质： </p><p>1.n≥1,φ(1)=1。 </p><p>2.当n为质数的时候，φ(n)=n−1。 </p><p>3.欧拉函数是积性函数，但不是完全积性。当n,m互质的时候，φ(n∗m)=φ(n)∗φ(m)。 </p><p>4.当n为奇数的时候，φ(2∗n)=φ(n)。 </p><p>5.除了φ(2)时，其他欧拉函数均为偶数。 </p><p>6.小于n，且与n互质的所有数字的和是<script type="math/tex">\frac{φ(n)∗n}{2}</script>。</p><p>求欧拉函数 有两个思路：</p><p>1.筛法，用数组记录每个数的欧拉函数（适用于n不是很大的情况，因为数组不能开无限大）；</p><p>2.直接求法计算单个欧拉函数，对于有些题目会比较慢（对于很大的n依然可以求解）；</p><p>3.线性筛。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> eu[<span class="hljs-number">10001</span>];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">euler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(eu,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(eu));    eu[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;<span class="hljs-number">10001</span>;i++)    <span class="hljs-keyword">if</span>(eu[i]==<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;<span class="hljs-number">10001</span>;j=j+i)        &#123;            <span class="hljs-keyword">if</span>(eu[j]==<span class="hljs-number">0</span>)eu[j]=j;            eu[j]=eu[j]/i*(i<span class="hljs-number">-1</span>);        &#125;    &#125;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">euler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,res=n;    <span class="hljs-keyword">int</span> temp=res;   <span class="hljs-comment">//如果要记忆化的话</span>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)        &#123;            res=res/i*(i<span class="hljs-number">-1</span>);     <span class="hljs-comment">//先除防溢出；不能只能乘(1-1/i)会变成0</span>            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)     <span class="hljs-comment">//去重</span>            n=n/i;        &#125;    &#125;    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)res=res/n*(n<span class="hljs-number">-1</span>);     <span class="hljs-comment">//本来就是质数</span>    <span class="hljs-comment">//phi[temp]=res;   //如果要记忆化的话</span>    <span class="hljs-keyword">return</span> res;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 20000001</span>ll eu[MAXN];ll pri[MAXN];<span class="hljs-keyword">bool</span> vis[MAXN];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    eu[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    ll cnt=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;MAXN;i++)    &#123;        <span class="hljs-keyword">if</span>(!vis[i])&#123;pri[cnt++]=i;eu[i]=i<span class="hljs-number">-1</span>;&#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt&amp;&amp;pri[j]*i&lt;MAXN;j++)        &#123;            vis[i*pri[j]]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(i%pri[j]==<span class="hljs-number">0</span>)            &#123;                eu[i*pri[j]]=eu[i]*pri[j];                <span class="hljs-keyword">break</span>;            &#125;            eu[i*pri[j]]=eu[i]*(pri[j]<span class="hljs-number">-1</span>);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL相关</title>
    <link href="/2018/01/25/STL%E7%9B%B8%E5%85%B3/"/>
    <url>/2018/01/25/STL%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h5 id="优先队列的优先级设置"><a href="#优先队列的优先级设置" class="headerlink" title="优先队列的优先级设置"></a>优先队列的优先级设置</h5><pre><code class="hljs c++">priority_queue&lt;<span class="hljs-keyword">int</span>&gt; 大顶堆priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, less&lt;<span class="hljs-keyword">int</span>&gt; &gt; 大顶堆：表示其他都比堆顶小 <span class="hljs-comment">//&gt;和&gt;之间有空格 防止辨认为输入符号</span>priority_queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; 小顶堆：表示其他都比堆顶大</code></pre><p>结构体设置优先级：</p><p>只可在结构体内部重载小于号。</p><p>两种重置用法：</p><p>运算符重载 + 友元</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fruit</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-built_in">string</span> name;    <span class="hljs-keyword">double</span> price;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (fruit f1, fruit f2)    &#123;        <span class="hljs-keyword">return</span> f1.price &lt; f2.price; <span class="hljs-comment">// 相当于less,这是大顶堆，反之则是小顶堆</span>    &#125;&#125; f1, f2, f3; <span class="hljs-comment">//定义三个结构体变量</span></code></pre><p>调用：</p><pre><code class="hljs abnf">priority_queue&lt;fruit&gt;q<span class="hljs-comment">;</span></code></pre><p>比较运算符外置</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fruit</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-built_in">string</span> name;    <span class="hljs-keyword">double</span> price;&#125; f1, f2, f3; <span class="hljs-comment">//定义三个结构体变量</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(fruit f1, fruit f2)</span> <span class="hljs-comment">// 重载括号</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> f1.price &lt; f2.price; <span class="hljs-comment">// 等同于less</span>    &#125;&#125;;</code></pre><p>调用：</p><pre><code class="hljs c++">priority_queue&lt;fruit,<span class="hljs-built_in">vector</span>&lt;fruit&gt;,cmp&gt;q; <span class="hljs-comment">//这个和基本类型的用法就相似了，只不过是用cmp代替了less或greater。</span></code></pre><h5 id="map的用法"><a href="#map的用法" class="headerlink" title="map的用法"></a>map的用法</h5><p>基本操作：</p><p>begin()          返回指向map头部的迭代器</p><p>clear()         删除所有元素</p><p>count()          返回指定元素出现的次数</p><p>end()            返回指向map末尾的迭代器</p><p>map的遍历：</p><pre><code class="hljs c++"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator it;        <span class="hljs-keyword">for</span>(it=tel.<span class="hljs-built_in">begin</span>();it!=tel.<span class="hljs-built_in">end</span>();it++)        &#123;            <span class="hljs-keyword">if</span>(it-&gt;second&gt;<span class="hljs-number">1</span>)            &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%03d-%04d %d\n"</span>,it-&gt;first/<span class="hljs-number">10000</span>,it-&gt;first%<span class="hljs-number">10000</span>,it-&gt;second);            &#125;        &#125;     <span class="hljs-comment">//it-&gt;first代表键(key)，it-&gt;second代表值(value)</span></code></pre><p>map的一个特性：</p><p>我们知道，map内部本身就是按序存储的（比如红黑树），这样方便实现快速查找。在我们插入<key, value>键值对时，map就会自动按照key的大小顺序进行存储。<strong>因而作为key的类型必须能够进行大小运算的比较。</strong>比如int、double、string、char等类型。</p><h5 id="vector排序"><a href="#vector排序" class="headerlink" title="vector排序"></a>vector排序</h5><p>sort(a.begin(), a.end());</p><p>用自定义的结构体进行sort算法：</p><p>这时候需要自己定义个比较函数，因为sort算法是基于容器中的元素是可以两两比较的，然后从小到大排序，所以要自定义怎么样才是小于（’&lt;’）</p><pre><code class="hljs c++"><span class="hljs-comment">//自定义“小于”</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> student &amp;a, <span class="hljs-keyword">const</span> student &amp;b)</span></span>&#123;    <span class="hljs-keyword">return</span> a.score &lt; b.score;&#125;</code></pre><p>调用：sort(a.begin(),a.end(),comp);</p><p>不过有时候一个排序条件不够，比如要求学生按分数从高到低排序，如果分数相同，则按照年龄从大到小排序</p><p>就需要在comp自定义函数里面修改一下判断了，原来是直接return a.score &lt; b.score</p><p>现在就需要判断</p><pre><code class="hljs c++"><span class="hljs-comment">//自定义“小于”</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> student &amp;a, <span class="hljs-keyword">const</span> student &amp;b)</span></span>&#123;    <span class="hljs-keyword">if</span> (a.score &gt; b.score)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.score == b.score  &amp;&amp; a.age &gt; b.age)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">else</span>                <span class="hljs-comment">///这里的else return false非常重要！！！！！</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><h5 id="vector-insert"><a href="#vector-insert" class="headerlink" title="vector insert()"></a>vector insert()</h5><p>v.insert(v.begin(),8);//在最前面插入新元素  </p><p>v.insert(v.begin()+2,1);//在迭代器中第二个元素前插入新元素   v.insert(v.end(),3);//在向量末尾追加新元素    </p><p>v.insert(v.end(),4,1);//在尾部插入4个1</p><h5 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h5><p>pair是一种模板类型，其中包含两个数据值，两个数据的类型可以不同，基本的定义如下：</p><pre><code class="hljs c++">pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">string</span>&gt;a;</code></pre><p>表示a中有两个类型，第一个元素是int型的，第二个元素是string类型的，如果创建pair的时候没有对其进行初始化，则调用默认构造函数对其初始化。</p><pre><code class="hljs c++">pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt;a(<span class="hljs-string">"James"</span>,<span class="hljs-string">"Joy"</span>);</code></pre><p>也可以像上面一样在定义的时候直接对其初始化。</p><p>由于pair类型的使用比较繁琐，因为如果要定义多个形同的pair类型的时候，可以时候typedef简化声明：</p><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt;author;<span class="hljs-function">author <span class="hljs-title">pro</span><span class="hljs-params">(<span class="hljs-string">"May"</span>,<span class="hljs-string">"Lily"</span>)</span></span>;<span class="hljs-function">author <span class="hljs-title">joye</span><span class="hljs-params">(<span class="hljs-string">"James"</span>,<span class="hljs-string">"Joyce"</span>)</span></span>;</code></pre><p>对于pair类，由于它只有两个元素，分别名为first和second，因此直接使用普通的点操作符即可访问其成员。</p><pre><code class="hljs c++">pair&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt;a(<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"Poly"</span>); <span class="hljs-built_in">string</span> name;name=pair.second;</code></pre><p>可以使用make_pair对已存在的两个数据构造一个新的pair类型：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a=<span class="hljs-number">8</span>;<span class="hljs-built_in">string</span> m=<span class="hljs-string">"James"</span>;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">string</span>&gt;newone;newone=make_pair(a,m);</code></pre><p>两个pairs互相比较时， 第一个元素正具有较高的优先级.<br>例： </p><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> pair&lt;T1, T2&gt;&amp;x, <span class="hljs-keyword">const</span> pair&lt;T1, T2&gt;&amp;y)&#123;<span class="hljs-keyword">return</span> x.first&lt;y.first||((y.first&lt;x.first)&amp;&amp;x.second&lt;y.second);&#125;</code></pre><h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><pre><code class="hljs c++"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; c0; <span class="hljs-comment">//空链表</span><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">//建一个含三个默认值是0的元素的链表</span><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">//建一个含五个元素的链表，值都是2</span><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c4</span><span class="hljs-params">(c2)</span></span>; <span class="hljs-comment">//建一个c2的copy链表</span><span class="hljs-function"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c5</span><span class="hljs-params">(c1.<span class="hljs-built_in">begin</span>(),c1.<span class="hljs-built_in">end</span>())</span></span>; <span class="hljs-comment">////c5含c1一个区域的元素[_First, _Last)</span></code></pre><p>c.assign(n,num)   将n个num拷贝赋值给链表c</p><p>c.assign(beg,end)   将[beg,end)区间的元素拷贝赋值给链表c</p><p>c.insert(pos,num)   在pos位置插入元素num</p><p>c.insert(pos,n,num)   在pos位置插入n个元素num</p><p>c.insert(pos,beg,end)   在pos位置插入区间为[beg,end)的元素</p><p>c.erase(pos)   删除pos位置的元素</p><p>c1.merge(c2)   合并2个有序的链表并使之有序，重新放到c1里，释放c2</p><p>c1.merge(c2,comp)   合并2个有序的链表并使之按照自定义规则排序之后从新放到c1中，释放c2</p><pre><code class="hljs c++">a2.merge(a1,&#123;<span class="hljs-keyword">return</span> n1&gt;n2;&#125;);</code></pre><p>c1.splice(c1.beg,c2)   将c2连接在c1的beg位置,释放c2</p><p>c1.splice(c1.beg,c2,c2.beg)      将c2的beg位置的元素连接到c1的beg位置，并且在c2中施放掉beg位置的元素</p><p>c1.splice(c1.beg,c2,c2.beg,c2.end)      将c2的[beg,end)位置的元素连接到c1的beg位置并且释放c2的[beg,end)位置的元素</p><p>reverse()   反转链表</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2018/01/25/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2018/01/25/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><strong>二叉搜索树</strong></p><p>它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p><p>567432和543267都长这样：</p><p><img src="/Users/apple/Downloads/未命名文件-3.png" srcset="/img/loading.gif" alt="未命名文件-3"></p><h5 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a><strong>二叉树的前序遍历</strong></h5><p>（给出的是二叉搜索树序列）</p><p>遍历顺序规则为【根左右】12457836</p><p><img src="http://img.blog.csdn.net/20150204101904649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTXlfSm9icw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">char</span> val;node *lch,*rch;&#125;;<span class="hljs-function">node *<span class="hljs-title">insert</span><span class="hljs-params">(node *p,<span class="hljs-keyword">char</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;node *p=<span class="hljs-keyword">new</span> node;p-&gt;val=x;p-&gt;lch=p-&gt;rch=<span class="hljs-literal">NULL</span>;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span>(x&lt;p-&gt;val)    p-&gt;lch=insert(p-&gt;lch,x);    <span class="hljs-keyword">else</span> p-&gt;rch=insert(p-&gt;rch,x);    <span class="hljs-keyword">return</span> p;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(node *h)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(h!=<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,h-&gt;val);pre(h-&gt;lch);pre(h-&gt;rch);&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> a[<span class="hljs-number">30</span>];<span class="hljs-keyword">int</span> i;node *h;<span class="hljs-keyword">while</span>(gets(a))&#123;h=<span class="hljs-literal">NULL</span>;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(a);i++)h=insert(h,a[i]);pre(h);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>); &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a><strong>二叉树的中序遍历</strong></h5><p>（给出的是二叉搜索树序列）</p><p>遍历顺序规则为【左根右】42758136</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">char</span> val;node *lch,*rch;&#125;;<span class="hljs-function">node *<span class="hljs-title">insert</span><span class="hljs-params">(node *p,<span class="hljs-keyword">char</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;node *p=<span class="hljs-keyword">new</span> node;p-&gt;val=x;p-&gt;lch=p-&gt;rch=<span class="hljs-literal">NULL</span>;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span>(x&lt;p-&gt;val)    p-&gt;lch=insert(p-&gt;lch,x);    <span class="hljs-keyword">else</span> p-&gt;rch=insert(p-&gt;rch,x);    <span class="hljs-keyword">return</span> p;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(node *h)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(h!=<span class="hljs-literal">NULL</span>)&#123;       in(h-&gt;lch);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,h-&gt;val);in(h-&gt;rch);&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> a[<span class="hljs-number">30</span>];<span class="hljs-keyword">int</span> i;node *h;<span class="hljs-keyword">while</span>(gets(a))&#123;h=<span class="hljs-literal">NULL</span>;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(a);i++)h=insert(h,a[i]);in(h);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>); &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a><strong>二叉树的后序遍历</strong></h5><p>（给出的是二叉搜索树序列）</p><p>遍历顺序规则为【左右根】47852631</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">char</span> val;node *lch,*rch;&#125;;<span class="hljs-function">node *<span class="hljs-title">insert</span><span class="hljs-params">(node *p,<span class="hljs-keyword">char</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;node *p=<span class="hljs-keyword">new</span> node;p-&gt;val=x;p-&gt;lch=p-&gt;rch=<span class="hljs-literal">NULL</span>;<span class="hljs-keyword">return</span> p;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span>(x&lt;p-&gt;val)    p-&gt;lch=insert(p-&gt;lch,x);    <span class="hljs-keyword">else</span> p-&gt;rch=insert(p-&gt;rch,x);    <span class="hljs-keyword">return</span> p;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">post</span><span class="hljs-params">(node *h)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(h!=<span class="hljs-literal">NULL</span>)&#123;       post(h-&gt;lch);post(h-&gt;rch);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,h-&gt;val);&#125;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">char</span> a[<span class="hljs-number">30</span>];<span class="hljs-keyword">int</span> i;node *h;<span class="hljs-keyword">while</span>(gets(a))&#123;h=<span class="hljs-literal">NULL</span>;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(a);i++)h=insert(h,a[i]);post(h);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>); &#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a><strong>二叉树的层次遍历</strong></h5><p>从上到下，从左到右的顺序进行遍历。</p><p><img src="http://img.blog.csdn.net/20150423091747551?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvbWluZ2p1bjEyMzE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" srcset="/img/loading.gif" alt="img"></p><p>样例输入：</p><p>(11,LL) (7,LLL) (8,R) (5,) (4,L) (13,RL) (2,LLR) (1,RRR) (4,RR) ()</p><p>(3,L) (4,R) ()</p><p>样例输出：</p><p>5 4 8 11 13 4 7 2 1</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> v;    <span class="hljs-keyword">bool</span> hv;    node *left,*right;    node():hv(<span class="hljs-literal">false</span>),left(<span class="hljs-literal">NULL</span>),right(<span class="hljs-literal">NULL</span>)&#123;&#125;&#125;;     <span class="hljs-comment">//设置结点</span>node *root;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec;<span class="hljs-keyword">int</span> flag;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> va,<span class="hljs-keyword">char</span> a[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    node *p=root;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(a);i++)    &#123;        <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">'L'</span>)        &#123;            <span class="hljs-keyword">if</span>(p-&gt;left==<span class="hljs-literal">NULL</span>)p-&gt;left=<span class="hljs-keyword">new</span> node;            p=p-&gt;left;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-string">'R'</span>)        &#123;            <span class="hljs-keyword">if</span>(p-&gt;right==<span class="hljs-literal">NULL</span>)p-&gt;right=<span class="hljs-keyword">new</span> node;            p=p-&gt;right;        &#125;    &#125;    <span class="hljs-keyword">if</span>(p-&gt;hv==<span class="hljs-literal">true</span>)flag++;    p-&gt;v=va;    p-&gt;hv=<span class="hljs-literal">true</span>;&#125;     <span class="hljs-comment">//建树</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">queue</span>&lt;node*&gt;Q;    vec.<span class="hljs-built_in">clear</span>();    Q.push(root);    <span class="hljs-keyword">while</span>(!Q.empty())    &#123;        node *temp=Q.front();        Q.pop();        <span class="hljs-keyword">if</span>(temp-&gt;hv==<span class="hljs-literal">false</span>)flag++;        <span class="hljs-keyword">else</span>        &#123;            vec.push_back(temp-&gt;v);            <span class="hljs-keyword">if</span>(temp-&gt;left!=<span class="hljs-literal">NULL</span>)Q.push(temp-&gt;left);            <span class="hljs-keyword">if</span>(temp-&gt;right!=<span class="hljs-literal">NULL</span>)Q.push(temp-&gt;right);        &#125;    &#125;&#125;     <span class="hljs-comment">//遍历</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">input</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> s[<span class="hljs-number">300</span>];    <span class="hljs-keyword">int</span> value;    flag=<span class="hljs-number">0</span>;    root=<span class="hljs-keyword">new</span> node;    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>,s)!=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(s,<span class="hljs-string">"()"</span>)==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;        <span class="hljs-built_in">sscanf</span>(&amp;s[<span class="hljs-number">1</span>],<span class="hljs-string">"%d"</span>,&amp;value);        add(value,<span class="hljs-built_in">strchr</span>(s,<span class="hljs-string">','</span>)+<span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">while</span>(input())    &#123;        bfs();        <span class="hljs-keyword">if</span>(flag!=<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"not complete\n"</span>);        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,vec[<span class="hljs-number">0</span>]);            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;vec.<span class="hljs-built_in">size</span>();i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %d"</span>,vec[i]);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a><strong>二叉树的递归遍历</strong></h5><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span> val;    node *lch,*rch;&#125;;<span class="hljs-function">node *<span class="hljs-title">insert</span><span class="hljs-params">(node *p,<span class="hljs-keyword">char</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)    &#123;        node *p=<span class="hljs-keyword">new</span> node;        p-&gt;val=x;        p-&gt;lch=p-&gt;rch=<span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-keyword">if</span>(x&lt;p-&gt;val)        p-&gt;lch=insert(p-&gt;lch,x);        <span class="hljs-keyword">else</span> p-&gt;rch=insert(p-&gt;rch,x);        <span class="hljs-keyword">return</span> p;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(node *p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,p-&gt;val);        pre(p-&gt;lch);        pre(p-&gt;rch);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(node *p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)    &#123;        in(p-&gt;lch);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,p-&gt;val);        in(p-&gt;rch);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">post</span><span class="hljs-params">(node *p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)    &#123;           post(p-&gt;lch);        post(p-&gt;rch);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,p-&gt;val);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> a[<span class="hljs-number">30</span>];    <span class="hljs-keyword">int</span> i;    node *h;    <span class="hljs-keyword">while</span>(gets(a))    &#123;        h=<span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">strlen</span>(a);i++)            h=insert(h,a[i]);        pre(h);        in(h);        post(h);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);     &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="已知前序、中序遍历，求后序遍历"><a href="#已知前序、中序遍历，求后序遍历" class="headerlink" title="已知前序、中序遍历，求后序遍历"></a><strong>已知前序、中序遍历，求后序遍历</strong></h5><p>参考博客：<a href="http://blog.csdn.net/droidphone/article/details/38063897" target="_blank" rel="noopener">http://blog.csdn.net/droidphone/article/details/38063897</a></p><h5 id="已知中序、后序遍历，求前序遍历"><a href="#已知中序、后序遍历，求前序遍历" class="headerlink" title="已知中序、后序遍历，求前序遍历"></a><strong>已知中序、后序遍历，求前序遍历</strong></h5><p>参考博客：<a href="http://blog.csdn.net/u014536527/article/details/51010702" target="_blank" rel="noopener">http://blog.csdn.net/u014536527/article/details/51010702</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索DFS&amp;BFS</title>
    <link href="/2018/01/25/%E6%90%9C%E7%B4%A2DFS-BFS/"/>
    <url>/2018/01/25/%E6%90%9C%E7%B4%A2DFS-BFS/</url>
    
    <content type="html"><![CDATA[<h5 id="BFS（Breath-First-Search）广度优先搜索"><a href="#BFS（Breath-First-Search）广度优先搜索" class="headerlink" title="BFS（Breath First Search）广度优先搜索"></a><strong>BFS（Breath First Search）广度优先搜索</strong></h5><p>(假装有个图片)</p><p>代码实现：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> <span class="hljs-built_in">map</span>[][];          <span class="hljs-comment">//地图</span><span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;           <span class="hljs-comment">//移动</span><span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;Q;Q.push(start);          <span class="hljs-comment">//起点入队</span>vis[start.x][start.y][start.z]=<span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(!Q.empty())&#123;temp=Q.front();Q.pop();<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<span class="hljs-keyword">if</span>(<span class="hljs-comment">//符合条件)</span>&#123;<span class="hljs-comment">//标记地图</span><span class="hljs-comment">//Q.push()入队</span>&#125;&#125;&#125;&#125;</code></pre><h5 id="DFS（Deep-First-Search）深度优先搜索"><a href="#DFS（Deep-First-Search）深度优先搜索" class="headerlink" title="DFS（Deep First Search）深度优先搜索"></a><strong>DFS（Deep First Search）深度优先搜索</strong></h5><p>深度优先搜索的步骤分为 1.递归下去 2.回溯上来。顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。这里称之为递归下去。</p><p>否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。</p><p>(假装有图片)</p><p>代码实现：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> goal.x,goal.y;<span class="hljs-keyword">int</span> <span class="hljs-built_in">map</span>[][];          <span class="hljs-comment">//存图</span><span class="hljs-keyword">int</span> vis[][];          <span class="hljs-comment">//标记是否访问过</span><span class="hljs-keyword">int</span> dx=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> dy=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;          <span class="hljs-comment">//移动</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;<span class="hljs-keyword">if</span>(x==goal.x&amp;&amp;y==goal.y)&#123;sign++;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<span class="hljs-keyword">if</span>(vis[x+dx[i]][y+dy[i]]==<span class="hljs-number">0</span>)          <span class="hljs-comment">//可以走的地方</span>&#123;vis[x+dx[i]][y+dy[i]]=<span class="hljs-number">1</span>;           <span class="hljs-comment">//标记走过</span>dfs(x+dx[i]][y+dy[i]);           <span class="hljs-comment">//判断下一个</span>vis[x+dx[i]][y+dy[i]]=<span class="hljs-number">0</span>;          <span class="hljs-comment">//状态回溯，清楚标记</span>&#125;&#125;<span class="hljs-keyword">return</span> sign;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归</title>
    <link href="/2018/01/25/%E9%80%92%E5%BD%92/"/>
    <url>/2018/01/25/%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<p>N皇后问题：</p><a id="more"></a><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span><span class="hljs-keyword">int</span> queen[<span class="hljs-number">8</span>];<span class="hljs-keyword">int</span> n,num=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">8</span>)    &#123;        num++;        <span class="hljs-keyword">if</span>(num==n)        &#123;        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,queen[i]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);        &#125;    &#125;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">8</span>;i++)    &#123;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;k;j++)        &#123;            <span class="hljs-keyword">if</span>(queen[j]==iabs(queen[j]-i)==<span class="hljs-built_in">abs</span>(k-j)/行之差等于列之差/)<span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span>(j==k)        &#123;            queen[k]=i;            pl(k+<span class="hljs-number">1</span>);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    pl(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>set容器的一些用法</title>
    <link href="/2018/01/25/set%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/"/>
    <url>/2018/01/25/set%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>erase(iterator)  ,删除定位器iterator指向的值</strong></p><p><strong>erase(first,second),删除定位器first和second之间的值</strong></p><p><strong>erase(key_value),删除键值key_value的值</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator iter;    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator first;    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator second;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">10</span> ; ++i)    &#123;        s.insert(i);    &#125;    <span class="hljs-comment">//第一种删除</span>    s.erase(s.<span class="hljs-built_in">begin</span>());    <span class="hljs-comment">//第二种删除</span>    first = s.<span class="hljs-built_in">begin</span>();    second = s.<span class="hljs-built_in">begin</span>();    second++;    second++;    s.erase(first,second);    <span class="hljs-comment">//第三种删除</span>    s.erase(<span class="hljs-number">8</span>);    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"删除后 set 中元素是 ："</span>;    <span class="hljs-keyword">for</span>(iter = s.<span class="hljs-built_in">begin</span>() ; iter != s.<span class="hljs-built_in">end</span>() ; ++iter)    &#123;        <span class="hljs-built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="hljs-string">" "</span>;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>运行结果：</p><p><img src="http://pic002.cnblogs.com/images/2012/406683/2012081315230691.jpg" srcset="/img/loading.gif" alt="img"></p><p><strong>小结：</strong>set中的删除操作是不进行任何的错误检查的，比如定位器的是否合法等等，所以用的时候自己一定要注意。</p><hr><p><strong>find() </strong> ，返回给定值值得定位器，如果没找到则返回end()。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;    <span class="hljs-function"><span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(a,a+<span class="hljs-number">3</span>)</span></span>;    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter;    <span class="hljs-keyword">if</span>((iter = s.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>)) != s.<span class="hljs-built_in">end</span>())    &#123;        <span class="hljs-built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>-—————————————————————————————————————-</p><p><strong>lower_bound(key_value)</strong> ，返回第一个大于等于key_value的定位器</p><p><strong>upper_bound(key_value)，</strong>返回最后一个大于等于key_value的定位器</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; s;    s.insert(<span class="hljs-number">1</span>);    s.insert(<span class="hljs-number">3</span>);    s.insert(<span class="hljs-number">4</span>);    <span class="hljs-built_in">cout</span>&lt;&lt;*s.lower_bound(<span class="hljs-number">2</span>)&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;*s.lower_bound(<span class="hljs-number">3</span>)&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;*s.upper_bound(<span class="hljs-number">3</span>)&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>运行结果：</p><p><img src="http://pic002.cnblogs.com/images/2012/406683/2012081316162732.jpg" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2018/01/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2018/01/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h5 id="插入排序（稳定）"><a href="#插入排序（稳定）" class="headerlink" title="插入排序（稳定）"></a><strong>插入排序（稳定）</strong></h5><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,temp;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;i++)    &#123;        temp=a[i];        <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>&amp;&amp;a[j]&gt;temp;j--)            a[j+<span class="hljs-number">1</span>]=a[j];        a[j+<span class="hljs-number">1</span>]=temp;    &#125;&#125;</code></pre><p>平均来说插入排序算法复杂度为O(n^2)。</p><h5 id="Shell排序（插入排序改进-不稳定）"><a href="#Shell排序（插入排序改进-不稳定）" class="headerlink" title="Shell排序（插入排序改进 不稳定）"></a><strong>Shell排序（插入排序改进 不稳定）</strong></h5><h5 id="选择排序（不稳定：出现相同数字时相对位置会改变）"><a href="#选择排序（不稳定：出现相同数字时相对位置会改变）" class="headerlink" title="选择排序（不稳定：出现相同数字时相对位置会改变）"></a><strong>选择排序（不稳定：出现相同数字时相对位置会改变）</strong></h5><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i,j,<span class="hljs-built_in">min</span>,temp;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-built_in">min</span>=i;        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;n;j++)        &#123;            <span class="hljs-keyword">if</span>(a[j]&lt;a[<span class="hljs-built_in">min</span>])                <span class="hljs-built_in">min</span>=j;        &#125;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>!=i)        &#123;            temp=a[i];            a[i]=a[<span class="hljs-built_in">min</span>];            a[<span class="hljs-built_in">min</span>]=temp;        &#125;    &#125;&#125;</code></pre><h5 id="二元选择排序（选择排序改进）"><a href="#二元选择排序（选择排序改进）" class="headerlink" title="二元选择排序（选择排序改进）"></a><strong>二元选择排序（选择排序改进）</strong></h5><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h5><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h5><h5 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><strong>桶排序</strong></h5><p>桶排序可以说得上是最简单的排序算法了，但是它的使用范围非常狭窄，不过不可否认的是在其适用范围内，它的性能要比快速排序还要快上很多倍。</p><p>没错，桶排序也是一种非比较型排序算法，这也正是它能够超越快速排序的原因。</p><p>桶排序主要有以下缺陷：</p><p>1.参与排序的数组存放的必须是整数</p><p>2.数组中的最大数和最小数保持在一个合理的间距内</p><p>3.需要额外的内存空间。</p><p>具体见<a href="http://blog.jobbole.com/100361/" target="_blank" rel="noopener">http://blog.jobbole.com/100361/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举</title>
    <link href="/2018/01/25/%E6%9E%9A%E4%B8%BE/"/>
    <url>/2018/01/25/%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<ul><li><p>遇到熄灯问题、特殊密码锁等各个数字之间有关联的问题时，只需先考虑第一个东西的情况。</p></li><li><p>遇到称东西称出哪个是次品时，假设哪一个是次品进行枚举。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些输入输出格式</title>
    <link href="/2018/01/25/%E4%B8%80%E4%BA%9B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/"/>
    <url>/2018/01/25/%E4%B8%80%E4%BA%9B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<ul><li><p><strong>将输出的前面补上0，直到占满指定列宽为止</strong>：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>;  <span class="hljs-keyword">int</span> n = <span class="hljs-number">3</span>;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%0*d"</span>,n,a);        <span class="hljs-comment">//用 * 代替位数</span></code></pre></li></ul><p>​          输出：004</p><ul><li><p><strong>四舍五入保留五位小数</strong></p><p>ans1=(int)(ans1*100000+0.5)/100000.0;</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些函数</title>
    <link href="/2018/01/25/%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/"/>
    <url>/2018/01/25/%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h5 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h5><p>​         sprintf()最常见的应用之一莫过于把整数打印到字符串中，如：<br>​         sprintf(s, “%d”, 123);  //把整数123打印成一个字符串保存在s中；<br>​         sprintf(s, “%8x”, 4567);  //小写16进制，宽度占8个位置，右对齐。</p><h5 id="atoi-atof-atol"><a href="#atoi-atof-atol" class="headerlink" title="atoi(atof)(atol)"></a>atoi(atof)(atol)</h5><p>​         功能：把字符串转换成整型数（浮点数）（长整数）；</p><p>​         表头文件 #include <stdlib.h>；</p><p>​         程序例: </p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt; </span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">int</span> n; <span class="hljs-keyword">char</span> *str = <span class="hljs-string">"1234"</span>; n = atoi(str); <span class="hljs-built_in">printf</span>(<span class="hljs-string">"string = %s integer = %d\n"</span>, str, n); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125; 运行结果是:<span class="hljs-built_in">string</span> =<span class="hljs-number">1234</span> integer=<span class="hljs-number">1234</span></code></pre><p>​         运行结果是:<br>​         string =1234 integer=1234</p><h5 id="lower-bound-upper-bound-函数"><a href="#lower-bound-upper-bound-函数" class="headerlink" title="lower_bound(upper_bound)函数"></a>lower_bound(upper_bound)函数</h5><p>​          头文件：#include <algorithm></p><p>​          lower_bound(a,a+10,x);//在数组a中寻找大于或等于x的第一个位置，所以使用的时候常常要减a。</p><p>​          upper_bound(a,a+10,x);//在数组a中寻找大于x的第一个位置。</p><h5 id="sscanf函数"><a href="#sscanf函数" class="headerlink" title="sscanf函数"></a>sscanf函数</h5><p>功能：从一个字符串中读进与指定格式相符的数据。</p><p>例子：</p><pre><code class="hljs c++"><span class="hljs-keyword">char</span> buf[<span class="hljs-number">512</span>] = ;　　<span class="hljs-built_in">sscanf</span>(<span class="hljs-string">"123456 "</span>, <span class="hljs-string">"%s"</span>, buf);　　<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, buf);</code></pre><p>　　结果为：123456</p><h5 id="next-permutation函数-STL"><a href="#next-permutation函数-STL" class="headerlink" title="next_permutation函数(STL)"></a>next_permutation函数(STL)</h5><p>功能：字典序列举排列。</p><p>例子：</p><pre><code class="hljs c++">sort(p,p+n);<span class="hljs-keyword">do</span>&#123;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,p[i]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;<span class="hljs-keyword">while</span>(next_permutation(p,p+n));</code></pre><h5 id="strchr-s-c-函数"><a href="#strchr-s-c-函数" class="headerlink" title="strchr(s,c)函数"></a>strchr(s,c)函数</h5><p>strchr(s,c)：查找字符串s中首次出现字符c的位置；如果找到指定的字符则返回该字符所在地址，否则返回 NULL。</p><h5 id="memset-a-0-sizeof-a-函数"><a href="#memset-a-0-sizeof-a-函数" class="headerlink" title="memset(a,0,sizeof(a))函数"></a>memset(a,0,sizeof(a))函数</h5><p>头文件：#include<string.h></p><p>只可以填充0或者-1。</p><h5 id="fill-arr-arr-n-key-函数"><a href="#fill-arr-arr-n-key-函数" class="headerlink" title="fill(arr, arr + n, key)函数"></a>fill(arr, arr + n, key)函数</h5><p>头文件：#include<algorithm></p><h5 id="floor函数"><a href="#floor函数" class="headerlink" title="floor函数"></a>floor函数</h5><p>floor(x)返回的是小于或等于x的最大整数。<br>如：     floor(10.5) == 10    floor(-10.5) == -11</p><h5 id="ceil函数"><a href="#ceil函数" class="headerlink" title="ceil函数"></a>ceil函数</h5><p>ceil(x)返回的是大于或等于x的最小整数。</p><p>如：     ceil(10.5) == 11    ceil(-10.5) ==-10</p><h5 id="unique-函数"><a href="#unique-函数" class="headerlink" title="unique()函数"></a>unique()函数</h5><p>去重函数，STL中unique的函数 unique的功能是去除相邻的重复元素(只保留一个),还有一个容易忽视的特性是它并不真正把重复的元素删除。它是c++中的函数，所以头文件要加#include<iostream.h>，具体用法如下：</p><p>​    int num[100];</p><p>   unique(num,mun+n)返回的是num去重后的尾地址，之所以说比不真正把重复的元素删除，其实是，该函数把重复的元素一到后面去了，然后依然保存到了原数组中，然后返回去重后最后一个元素的地址，因为unique去除的是相邻的重复元素，所以一般用之前都会要排一下序。</p><h5 id="substr-函数"><a href="#substr-函数" class="headerlink" title="substr()函数"></a>substr()函数</h5><p>substr(字符串,截取开始位置,截取长度) //返回截取的字</p><p>substr(‘Hello World’,0,1) //返回结果为 ‘H’  *从字符串第一个字符开始截取长度为1的字符串</p><p>string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = “56789”</p><p>string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = “567”</p><h5 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element()"></a>nth_element()</h5><p>通过调用nth_element(start, start+n, end) 方法可以使第n大元素处于第n位置，并且比这个元素小的元素都排在这个元素之前，比这个元素大的元素都排在这个元素之后，但不能保证他们是有序的。</p><p>可以用来求解中位数：</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> mid = n%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> ? n/<span class="hljs-number">2</span> : n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);  nth_element(a,a+mid,a+n);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,a[mid]);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同余定理</title>
    <link href="/2018/01/25/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    <url>/2018/01/25/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>a≡ b(mod d)a和b是模d同余的。</p><p>一.</p><p>有定理：<strong>如果a≡x(mod d),b≡m(mod d),则a*b≡x*m (mod d )</strong>。</p><p>下面来说说该定理的应用，我们知道一个数的各个位数之和如果能被3整除那么这个数也能被3整除，如12，因为1+2=3能被3整除，所以12也能被3整除。如果我们利用定律6，就可以找出任何一个数能被另一个数整除的表达式来。<br>如我们用11来试试，11可以表示为10+1，所以有同余式：</p><p>10≡-1 （mod 11）<br>把上式两边都乘以各自，即：</p><script type="math/tex; mode=display">10*10≡（-1）（-1）=1 (mod 11)</script><script type="math/tex; mode=display">10*10*10≡（-1）（-1）（-1）=-1 （mod 11）</script><script type="math/tex; mode=display">10*10*10*10≡1 （mod 11）</script><p>我们可以发现，任何一个（在十进制系统中表示的）整数，如果它的数码交替到变号之和能被11整除，这个数就能被11整除，如1353这个数它的数码交替变号之和为：1+（-3）+5+(-3)=0,因为0能被11整除，所以1353也能被11整除。<script type="math/tex">3≡3(mod11);5*10≡5*(-1)=5(mod11);</script></p><p><script type="math/tex">3*10*10≡3*1(mod11);1*10*10*10≡1*(-1)(mod11)</script>。</p><p>其他的数的找法也一样，都是两边都乘以各自的数，然后找出右边的数的循环数列即可。</p><p>二.</p><p><strong>对于同一个除数，如果两个整数同余，那么他们的差就一定能被这个数整除。</strong></p><p>==============================================</p><p><strong>举个栗子：</strong></p><p>现在给你一个自然数n，它的位数小于等于一百万，现在你要做的就是求出这个数除10003之后的余数。</p><p><strong>思路：</strong></p><p>同余定理：(a+b)%c=((a%c)+(b%c))%c </p><p>m%n举例： </p><p>123 % n = (((1%n<em>10%n+2%n)%n</em>10%n)%n+3%n)%n</p><p><strong>关键：</strong></p><pre><code class="hljs c++">gets(a);len=<span class="hljs-built_in">strlen</span>(a);<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)num=（num*<span class="hljs-number">10</span>+(<span class="hljs-keyword">int</span>)a[i]-<span class="hljs-string">'0'</span>)%<span class="hljs-number">10003</span>;</code></pre><p>============================================</p><p><strong>自己写的被7整除的栗子：</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,i,len,num,sum,j;    <span class="hljs-keyword">char</span> a[<span class="hljs-number">10000</span>];    gets(a);    len=<span class="hljs-built_in">strlen</span>(a);    sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        num=a[i]-<span class="hljs-string">'0'</span>;        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;len<span class="hljs-number">-1</span>-i;j++)            num=(num*<span class="hljs-number">3</span>)%<span class="hljs-number">7</span>;        sum=(sum+num)%<span class="hljs-number">7</span>;    &#125;    <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"yes\n"</span>);&#125;</code></pre><p>（利用3≡10%7）</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三点顺序---有向面积</title>
    <link href="/2018/01/25/%E4%B8%89%E7%82%B9%E9%A1%BA%E5%BA%8F-%E6%9C%89%E5%90%91%E9%9D%A2%E7%A7%AF/"/>
    <url>/2018/01/25/%E4%B8%89%E7%82%B9%E9%A1%BA%E5%BA%8F-%E6%9C%89%E5%90%91%E9%9D%A2%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<p>现在给你不共线的三个点A,B,C的坐标，它们一定能组成一个三角形，现在让你判断A，B，C是顺时针给出的还是逆时针给出的？</p><p>一种：</p><p>利用矢量叉积判断是逆时针还是顺时针。</p><p>​    设A(x1,y1),B(x2,y2),C(x3,y3),则三角形两边的矢量分别是：</p><p>​    AB=(x2-x1,y2-y1), AC=(x3-x1,y3-y1)</p><a id="more"></a><p>​    则AB和AC的叉积为：(2*2的行列式)</p><p>​    x2-x1, y2-y1</p><p>​    x3-x1, y3-y1</p><p>​    值为：(x2-x1)<em>(y3-y1) - (y2-y1)</em>(x3-x1)</p><p>​    利用右手法则进行判断：</p><p>​    如果AB*AC&gt;0,则三角形ABC是逆时针的</p><p>​    如果AB*AC&lt;0,则三角形ABC是顺时针的</p><p>​    如果……  =0，则说明三点共线</p><p>另一种：</p><p>解析：</p><p>​    有向面积可以是正的，可以是负的，这取决于围成封闭图形的向量。</p><p>　　如果三角形ABC三个顶点呈 逆时针 排列则有向面积为 正，顺时针 排列则为 负，三点共线时 ，有向面积为0；</p><p>​    设A(x1,y1) B(x2,y2) C(x3,y3) 三角形ABC有向面积为s；则s的2倍 2<em>s=(x1</em>y2+x3<em>y1+x2</em>y3-x3<em>y2-x1</em>y3-x2*y1；</p><p>​    如果难记可以记它的行列式形式:</p><p>​            x1  y1  1</p><p>2*s  =  x2  y2  1</p><p>​            x3  y3  1</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>康托展开及逆康托展开</title>
    <link href="/2018/01/25/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E5%8F%8A%E9%80%86%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    <url>/2018/01/25/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E5%8F%8A%E9%80%86%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
    
    <content type="html"><![CDATA[<h5 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a><strong>康托展开</strong></h5><p>康托展开表示的是当前排列在n个不同元素的全排列中的名次。比如213在这3个数所有排列中排第3。</p><p>那么，对于n个数的排列，康托展开为：<img src="http://img.blog.csdn.net/20131010165801375" srcset="/img/loading.gif" alt="img"></p><p>其中<img src="http://img.blog.csdn.net/20131010165850765" srcset="/img/loading.gif" alt="img">表示第i个元素在未出现的元素中排列第几。举个简单的例子：</p><p>对于排列4213来说，4在4213中排第3，<strong>注意从0开始</strong>，2在213中排第1，1在13中排第0，3在3中排第0，即：</p><p><img src="http://img.blog.csdn.net/20131010170547375" srcset="/img/loading.gif" alt="img">，<strong>得到的ans是比原数小的数，要得到第几个数应该加一。</strong></p><a id="more"></a><p>代码实现：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fac</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> x*fac(x<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Cantor</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str)</span></span><span class="hljs-function"></span>&#123;      <span class="hljs-keyword">int</span> n,i,j,s;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    n=<span class="hljs-built_in">strlen</span>(str);    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        s=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;n;j++)        <span class="hljs-keyword">if</span>(str[j]&lt;str[i])        s++;        ans=ans+s*fac(n-i<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-keyword">return</span> ans+<span class="hljs-number">1</span>;           <span class="hljs-comment">//返回该字符串是全排列中第几大，从1开始</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> ans;    <span class="hljs-keyword">char</span> a[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;    gets(a);    ans=Cantor(a);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="通过康托逆展开生成全排列"><a href="#通过康托逆展开生成全排列" class="headerlink" title="通过康托逆展开生成全排列"></a><strong>通过康托逆展开生成全排列</strong></h5><p>如果已知 s = [“A”, “B”, “C”, “D”]，X(s1) = 20，能否推出 s1 = [“D”, “B”, “A”, “C”] 呢？</p><p><strong>首先要减一。</strong><br>　　因为已知 X(s1) = a4<em>3! + a3</em>2! + a2<em>1! + a1</em>0! = 20，所以问题变成由 20 能否唯一地映射出一组 a4、a3、a2、a1？如果不考虑 ai 的取值范围，有<br>3<em>3! + 1</em>2! + 0<em>1! + 0</em>0! = 20<br>2<em>3! + 4</em>2! + 0<em>1! + 0</em>0! = 20<br>1<em>3! + 7</em>2! + 0<em>1! + 0</em>0! = 20<br>0<em>3! + 10</em>2! + 0<em>1! + 0</em>0! = 20<br>0<em>3! + 0</em>2! + 20<em>1! + 0</em>0! = 20<br>等等。但是满足 0 &lt;= ai &lt;= n-1 的只有第一组。可以使用辗转相除的方法得到 ai，如下图所示：<br><img src="http://pic002.cnblogs.com/images/2011/25284/2011042422221712.png" srcset="/img/loading.gif" alt="img"></p><p>知道了a4、a3、a2、a1的值，就可以知道s1[0] 是子数组[“A”, “B”, “C”, “D”]中第3大的元素 “D”，s1[1] 是子数组 [“A”, “B”, “C”] 中第1大的元素”B”，s1[2] 是子数组 [“A”, “C”] 中第0大的元素”A”，s[3] 是子数组 [“C”] 中第0大的元素”C”，所以s1 = [“D”, “B”, “A”, “C”]。</p><p>代码实现：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fac</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> x*fac(x<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reCantor</span><span class="hljs-params">(<span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>],<span class="hljs-keyword">int</span> temp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-built_in">strlen</span>(str);    <span class="hljs-keyword">int</span> x,i,j;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)    &#123;        x=temp/fac(n<span class="hljs-number">-1</span>-i);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,str[x]);        <span class="hljs-keyword">for</span>(j=x;j&lt;n-i;j++)            str[j]=str[j+<span class="hljs-number">1</span>];        temp=temp%fac(n<span class="hljs-number">-1</span>-i);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,str[<span class="hljs-number">0</span>]);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">char</span> a[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;    gets(a);    <span class="hljs-comment">//如果有需要的话，先把数组a从小到大排列好 </span>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;temp);    temp--;    reCantor(a,temp);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>辗转相除法（求最大公约数、扩展欧几里得算法及应用）</title>
    <link href="/2018/01/25/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%EF%BC%88%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E3%80%81%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8%EF%BC%89/"/>
    <url>/2018/01/25/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%EF%BC%88%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E3%80%81%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h5 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a><strong>求最大公约数</strong></h5><p>原理：gcd(a,b)=gcd(b,a mod b)</p><p>辗转相除法是利用以下性质来确定两个正整数 a 和 b 的最大公因子的：</p><p>⒈ 若 r 是 a ÷ b 的余数，且r不为0， 则</p><p>gcd(a,b) = gcd(b,r)</p><p>⒉ a 和其倍数之最大公因子为 a。</p><p>另一种写法是：</p><p>⒈ 令r为a/b所得余数（0≤r&lt;b）</p><p>若 r= 0，算法结束；b 即为答案。</p><p>⒉ 互换：置 a←b，b←r，并返回第一步。</p><p>欧几里德算法的C语言实现：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span><span class="hljs-function"></span>&#123;     <span class="hljs-keyword">if</span>(a&lt;b)&#123;<span class="hljs-keyword">int</span> temp;temp=a;a=b;b=temp;&#125;     <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">while</span>(a%b)&#123;<span class="hljs-keyword">int</span> r=a%b;a=b;b=r;&#125;     <span class="hljs-keyword">return</span> b; &#125;</code></pre><p>递归写法：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(a&lt;b)&#123;<span class="hljs-keyword">int</span> temp;temp=a;a=b;b=temp;&#125;     <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> a;    <span class="hljs-keyword">return</span> gcd(b,a%b);&#125;</code></pre><p>最小公倍数 = a*b/最大公约数  注意超过范围32位</p><p>用a*(b/最大公约数）就不会超过32位了 而且有时需用到long long</p><h5 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a><strong>扩展欧几里得算法</strong></h5><p>求ax+by=gcd(a,b)（这里a和b都是正整数所以解释了后面带入的为什么是m,n）</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">extgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> d=a;    <span class="hljs-keyword">if</span>(b!=<span class="hljs-number">0</span>)&#123;        d=extgcd(b,a%b,y,x);        y=y-(a/b)*x;    &#125;    <span class="hljs-keyword">else</span>&#123;        x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> d;&#125; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> x,y;    extgcd(<span class="hljs-number">4</span>,<span class="hljs-number">11</span>,x,y);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>,x,y);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="扩展欧几里得算法的应用"><a href="#扩展欧几里得算法的应用" class="headerlink" title="扩展欧几里得算法的应用"></a><strong>扩展欧几里得算法的应用</strong></h5><p>（1）求解不定方程</p><p>用扩展欧几里得算法解不定方程ax+by=c;</p><p>这个应该比较好理解了，两个可以同乘以k.</p><p>（2）乘法逆元</p><p>给出2个数M和N(M &lt; N)，且M与N互质，找出一个数K满足0 &lt; K &lt; N且K * M % N = 1，如果有多个满足条件的，输出最小的。</p><p>思路：K <em> M % N = 1等价于 K</em>M=N<em>X+1  即 K</em>M+N*(-X)=1 </p><p>根据扩展欧几里德算法，求出K和（-X）；</p><p>而K是应为正整数，即需要若K为负整数，则需要将之化正，即与负数取模同理，将K加上N，直至K&gt;0为止，所得的数即为最小的乘法逆元；</p><p>若K为正整数，则直接输出即可。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">extgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> &amp;x,<span class="hljs-keyword">int</span> &amp;y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> d=a;    <span class="hljs-keyword">if</span>(b!=<span class="hljs-number">0</span>)&#123;        d=extgcd(b,a%b,y,x);        y=y-(a/b)*x;    &#125;    <span class="hljs-keyword">else</span>&#123;        x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> m,n,x,y;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;m,&amp;n);    extgcd(m,n,x,y);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,(x%n+n)%n);     <span class="hljs-comment">//要使K最小，而且考虑K为负数的情况 </span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>例如：4关于1模7的乘法逆元为多少？</p><p>4X≡1 mod 7</p><p>这个方程等价于求一个X和K，满足4X=7K+1,其中X和K都是整数。</p><p>若ax≡1 mod f, 则称a关于模f的乘法逆元为x。也可表示为ax≡1(mod f)。</p><p>为什么要有乘法逆元呢？<br>当我们要求（a/b） mod p的值，且a很大，无法直接求得a/b的值时，我们就要用到乘法逆元。<br>我们可以通过求b关于p的乘法逆元k，将a乘上k再模p，即(a*k) mod p。其结果与(a/b) mod p等价。</p><p>用乘法逆元求组合数：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MOD 1000000007</span><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">extgcd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &amp;x,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &amp;y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d=a;    <span class="hljs-keyword">if</span>(b!=<span class="hljs-number">0</span>)&#123;        d=extgcd(b,a%b,y,x);        y=y-(a/b)*x;    &#125;    <span class="hljs-keyword">else</span>&#123;        x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">hx</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x,y;    extgcd(a,b,x,y);    <span class="hljs-keyword">return</span> (x%b+b)%b;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">comb</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fz=<span class="hljs-number">1</span>,fm=<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">for</span>(i=n;i&gt;=m+<span class="hljs-number">1</span>;i--)    fz=(fz*i)%MOD;    <span class="hljs-keyword">for</span>(i=n-m;i&gt;=<span class="hljs-number">2</span>;i--)    fm=(fm*i)%MOD;    <span class="hljs-keyword">return</span> (fz*hx(fm,MOD))%MOD;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m,n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;m,&amp;n);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,comb(m,n));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>求解二元一次方程：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">extgcd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &amp;d,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &amp;x,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &amp;y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(!b)&#123;d=a;x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;&#125;    <span class="hljs-keyword">else</span>&#123;extgcd(b,a%b,d,y,x);y-=x*(a/b);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x,y,m,n,l,d,a,b,c;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;m,&amp;n,&amp;l);    a=m-n;b=l;c=y-x;    extgcd(a,b,d,x,y);    <span class="hljs-keyword">if</span>(c%d)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Impossible\n"</span>);    <span class="hljs-keyword">else</span>    &#123;        x=x*(c/d);<span class="hljs-comment">//c可以整除d</span>        b=b/d;        <span class="hljs-keyword">if</span>(b&lt;<span class="hljs-number">0</span>)b=-b;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,(x%b+b)%b);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h5 id="求模线性方程组"><a href="#求模线性方程组" class="headerlink" title="求模线性方程组"></a><strong>求模线性方程组</strong></h5><p>以POJ 2891为例：</p><p>题意：给你k对a和r是否存在一个正整数x使每队a和r都满足：x mod a=r，求最小正解x或无解。</p><p>思路：</p><p>若模数两两互质，我们可以用中国剩余定理来解。<br>这里我们先考虑两个方程：</p><center>x≡r1(mod a1)</center><center>x≡r2(mod a2)</center><p>我们可以写成:</p><center>x+y1a1=r1</center><center>x−y2a2=r2</center><p>相减得：</p><center>y1a1+y2a2=r1−r2</center><p>这就可以用扩展欧几里得解方程求出解：</p><p>设a, b, c为任意整数。若方程ax+by=c的一组整数解为(x0,y0)，则它的任意整数解都可以写成(x0+kb’,y0-ka’)，其中a’=a/gcd(a,b)，b’=b/gcd(a,b)，k取任意整数。</p><p>设a, b, c为任意整数，g=gcd(a,b)，方程ax+by=g的一组解是(x0,y0)，则当c是g的倍数时ax+by=c的一组解是(x0c/g,y0c/g)；当c不是g的倍数时无整数解。</p><p>若gcd(a,b)/|m那么方程就无解，直接输出-1。<br>否则我们可以解出上式的y1。回带得到一个特解x0=r1−y1a1。<br>通解可以写成x=x0+k∗lcm(a1,a2)也就是x≡x0(mod lcm(a1,a2))。<br>这样我们就将两个方程合并为了一个。重复进行以上操作，我们最终能将n个方程全部合并，再用扩展欧几德得解出来就好了。</p><pre><code class="hljs c++"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">100010</span>],r[<span class="hljs-number">100010</span>];<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">extgcd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &amp;x,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> &amp;y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d=a;    <span class="hljs-keyword">if</span>(b!=<span class="hljs-number">0</span>)&#123;        d=extgcd(b,a%b,y,x);        y=y-(a/b)*x;    &#125;    <span class="hljs-keyword">else</span>&#123;        x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld%lld"</span>,&amp;a[i],&amp;r[i]);        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> rr=r[<span class="hljs-number">0</span>];        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> aa=a[<span class="hljs-number">0</span>];        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x,y,d;        <span class="hljs-keyword">int</span> sign=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n&amp;&amp;sign==<span class="hljs-number">0</span>;i++)        &#123;            d=extgcd(aa,a[i],x,y);            <span class="hljs-comment">//printf("%lld\n",x);</span>            <span class="hljs-keyword">if</span>((rr-r[i])%d!=<span class="hljs-number">0</span>)sign++;            x=(rr-r[i])/d*x%a[i];<span class="hljs-comment">//注意要模a[i]</span>            <span class="hljs-comment">//printf("%lld\n",x);</span>            rr=rr-x*aa;            aa=aa/d*a[i];<span class="hljs-comment">//不能写成aa*a[i]/d会溢出</span>            rr=rr%aa;<span class="hljs-comment">//这个rr可能很大，所以要模掉，模掉也没有影响</span>        &#125;        <span class="hljs-keyword">if</span>(sign)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"-1\n"</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,(rr%aa+aa)%aa);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些细小的点</title>
    <link href="/2018/01/25/%E4%B8%80%E4%BA%9B%E7%BB%86%E5%B0%8F%E7%9A%84%E7%82%B9/"/>
    <url>/2018/01/25/%E4%B8%80%E4%BA%9B%E7%BB%86%E5%B0%8F%E7%9A%84%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><strong>0.</strong>读到文件的结尾，程序自动结束<br>while( ( scanf( “ %d ” ,&amp;a) ) != -1 )<br>while( ( scanf( “ %d ” ,&amp;a) ) != EOF)<br>while( ( scanf( “ %d ” ,&amp;a) ) == 1 )<br>while( ~( scanf( “ %d ” ,&amp;a) ) )<br>读到一个 0 时，程序结束<br>while( scanf( “ %d ” ,&amp;a) ,a)<br>读到多个0时，程序结束<br>while( scanf( “ %d%d%d ”,&amp;a,&amp;b,&amp;c),a+b+c )//a,b,c非负<br>while( scanf( “ %d%d%d ”,&amp;a,&amp;b,&amp;c),abc)</p><p><strong>1.</strong>注意函数sqrt( )的参数只能是float，double,long double型的。</p><p><strong>2.</strong>EOF是int类型的。</p><p><strong>3.</strong>纯字符串用puts()输出。数据大时最好用scanf()、printf()减少时间。先用scanf()，再用gets()会读入回车。所以在中间加一个getchar();scanf(“%c%c”,&amp;c1,&amp;c2)会读入空格；建议用%s读取字符串，取第一个字符。</p><p><strong>4.</strong>数组定义int a[10]={0};可以对其全部元素赋值为0；数组太大不要这样，防止CE，全局变量，静态变量自动初始化为0。</p><p><strong>5.</strong>圆周率=acos(-1.0)；自然对数=exp(1.0)。</p><p><strong>6.</strong>如果要乘或除2^n,用位移运算速度快。a&gt;&gt;n;a&lt;&lt;n。</p><p><strong>7.</strong>将乘法转换成加法减少时间：log(a<em>b)=log(a)+log(b)；将乘法转换成除法防止溢出：a/(b</em>c)=a/b/c。</p><p><strong>8.</strong>有的题数据范围小但是计算量大可以用打表法，先把结果算出来保存在数组里，要用时直接取出来。</p><p><strong>9.</strong>浮点数比较时最好控制精度</p><p>#define eps 1e-6<br>fabs(a-b)&lt;eps。</p><p><strong>10.</strong>INF=0x3f3f3f3f</p><p>INF=0x7f7f7f7f</p><p><strong>11.</strong>各种数据类型的最大值最小值</p><p>int类型：INT_MAX，INT_MIN</p><p>double类型：DBL_MAX，DBL_MIN</p><p>long long类型：</p><pre><code class="hljs c++">__LONG_LONG_MAX__</code></pre><p>LLONG_MIN、LLONG_MAX和ULLONG_MIN，它们分别代表了平台上最小的long long值、最大的long long值，以及最大的unsigned long long值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
