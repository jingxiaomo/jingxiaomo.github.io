<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="kumira">
  <meta name="keywords" content="">
  <title>匹配问题 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Komorebi</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/b.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2018-02-06 16:16">
      February 6, 2018 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      87
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><p>参考博客：<a href="http://www.renfei.org/blog/bipartite-matching.html" target="_blank" rel="noopener">http://www.renfei.org/blog/bipartite-matching.html</a></p>
<p><a href="http://blog.csdn.net/sixdaycoder/article/details/47680831" target="_blank" rel="noopener">http://blog.csdn.net/sixdaycoder/article/details/47680831</a></p>
<p><a href="https://www.cnblogs.com/logosG/p/logos.html" target="_blank" rel="noopener">https://www.cnblogs.com/logosG/p/logos.html</a></p>
<p><strong>二分图</strong>：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：<u>把一个图的顶点划分为两个不相交集 U 和V ，使得每一条边都分别连接U、V中的顶点</u>。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。</p>
<p><strong>匹配</strong>：在图论中，一个「匹配」（matching）是一个边的集合，其中<u>任意两条边都没有公共顶点</u>。例如，图 3、图 4 中红色的边就是图 2 的匹配。</p>
<p><img src="http://img.renfei.org/2013/08/1.png" srcset="/img/loading.gif" alt="Bipartite Graph(1)">  <img src="http://img.renfei.org/2013/08/2.png" srcset="/img/loading.gif" alt="Bipartite Graph(2)">  <img src="http://img.renfei.org/2013/08/3.png" srcset="/img/loading.gif" alt="Matching">  <img src="http://img.renfei.org/2013/08/4.png" srcset="/img/loading.gif" alt="Maximum Matching"></p>
<p>我们定义<strong>匹配点</strong>、<strong>匹配边</strong>、<strong>未匹配点</strong>、<strong>非匹配边</strong>，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。</p>
<p><strong>最大匹配</strong>：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。</p>
<p><strong>完美匹配</strong>：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。</p>
<h4 id="二分图的最大匹配（匈牙利算法）"><a href="#二分图的最大匹配（匈牙利算法）" class="headerlink" title="二分图的最大匹配（匈牙利算法）"></a><strong>二分图的最大匹配（匈牙利算法）</strong></h4><p><img src="http://img.renfei.org/2013/08/5.png" srcset="/img/loading.gif" alt="5"></p>
<p><strong>交替路</strong>：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p>
<p><strong>增广路</strong>： 从一个未匹配点出发，依次遍历未匹配边、匹配边、未匹配边，这样交替下去，如果最后一个点是未匹配点，这条路径称为增广路。换句话说，起点和终点都为未匹配点的交错路为增广路（agumenting path）（特别提醒，这里的增广路和网络流中的增广路的意义不同）。</p>
<p>例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：</p>
<p><img src="http://img.renfei.org/2013/08/6.png" srcset="/img/loading.gif" alt="6"></p>
<p>观察图6我们可发现增广路的一些特点。</p>
<ol>
<li>增广路一定有奇数条边。</li>
<li>增广路中未匹配边一定比匹配边多一条（因为是从未匹配点出发走交错路到未匹配点结束）</li>
</ol>
<p>这里其实就表明了研究增广路的意义。<br>如果找到了一条增广路，那么将未匹配点与匹配边的<strong>身份</strong>调换,那么匹配的边数就多了一条，这样直到找不到增广路为止，那么整个图的匹配的边数一定最大，也就是找到了二分图的最大匹配。</p>
<p>这里的<strong>身份调换</strong>是指 ：<br>原来匹配的边为edge(1,6),edge(4,8)，匹配边数为2。找到一条增广路（这里不一定从9开始找，任何一个未匹配点都可以）后，现在匹配的边为edge(2,6),edge(1,8),edge(4,9),匹配边数为3。</p>
<p>匈牙利算法正是利用了增广路的这个性质，从X集合中找到一个未匹配点，寻找增广路，找到了匹配数+1，如果没有找到，那么从X中找到下一个未匹配的点，再次寻找增广路……重复上述过程，直到X集合中的所有节点都被“增广”完毕，无论如何都找不到增广路，那么整个图的匹配数就最大了。</p>
<p>我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。</p>
<p><strong>匈牙利树</strong>一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树：</p>
<p><img src="http://img.renfei.org/2013/08/7.png" srcset="/img/loading.gif" alt="7">   <img src="http://img.renfei.org/2013/08/8.png" srcset="/img/loading.gif" alt="8">    <img src="http://img.renfei.org/2013/08/9.png" srcset="/img/loading.gif" alt="9"></p>
<p>这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。</p>
<p>易懂版本参考博客：<a href="http://blog.csdn.net/dark_scope/article/details/8880547" target="_blank" rel="noopener">http://blog.csdn.net/dark_scope/article/details/8880547</a></p>
<p>代码（增广路注释）：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">110</span>];
<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">110</span>];
<span class="hljs-keyword">int</span> link[<span class="hljs-number">110</span>];<span class="hljs-comment">//右列中与之匹配的左边的</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)
    &#123;
        <span class="hljs-keyword">int</span> temp=v[id][i];
        <span class="hljs-keyword">if</span>(!vis[temp])<span class="hljs-comment">//不在交替路中</span>
        &#123;
            vis[temp]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记在交替路中</span>
            <span class="hljs-keyword">if</span>(link[temp]==<span class="hljs-number">-1</span>||judge(link[temp]))<span class="hljs-comment">//如果是未盖点，说明交替路是增广路，则交换路径，并返回成功</span>
            &#123;
                link[temp]=id;
                <span class="hljs-comment">//link[id]=temp;//如果左边一列与右边一列编号不同就带上这句</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//从id出发没有增广路</span>
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxmatch</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">memset</span>(link,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(link));
    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
    &#123;
        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));
        <span class="hljs-keyword">if</span>(judge(i))
            num++;
    &#125;
    <span class="hljs-keyword">return</span> num;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> m;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);
    m=m-n;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        v[i].<span class="hljs-built_in">clear</span>();
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y)!=EOF)
    &#123;
        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">-1</span>&amp;&amp;y==<span class="hljs-number">-1</span>)<span class="hljs-keyword">break</span>;
        v[x].push_back(y);
        <span class="hljs-comment">//v[y].push_back(x);</span>
    &#125;
    <span class="hljs-keyword">int</span> ans=maxmatch();
    <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"No Solution!\n"</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>代码（易懂注释）：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;v[<span class="hljs-number">110</span>];
<span class="hljs-keyword">bool</span> vis[<span class="hljs-number">110</span>];
<span class="hljs-keyword">int</span> link[<span class="hljs-number">110</span>];<span class="hljs-comment">//右列中与之匹配的左边的</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v[id].<span class="hljs-built_in">size</span>();i++)
    &#123;
        <span class="hljs-keyword">int</span> temp=v[id][i];
        <span class="hljs-keyword">if</span>(!vis[temp])<span class="hljs-comment">//如果可以匹配并且还没有标记过(这里标记的意思是这次查找曾试图改变过这个人的归属问题，但是没有成功，所以就不用瞎费工夫了）</span>
        &#123;
            vis[temp]=<span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span>(link[temp]==<span class="hljs-number">-1</span>||judge(link[temp]))<span class="hljs-comment">//没人匹配或者与之匹配的人可以腾出个位置来，这里使用递归</span>
            &#123;
                link[temp]=id;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxmatch</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">memset</span>(link,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(link));
    <span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
    &#123;
        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));
        <span class="hljs-keyword">if</span>(judge(i))
            num++;
    &#125;
    <span class="hljs-keyword">return</span> num;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> m;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);
    m=m-n;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        v[i].<span class="hljs-built_in">clear</span>();
    <span class="hljs-keyword">int</span> x,y;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y)!=EOF)
    &#123;
        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">-1</span>&amp;&amp;y==<span class="hljs-number">-1</span>)<span class="hljs-keyword">break</span>;
        v[x].push_back(y);
        <span class="hljs-comment">//v[y].push_back(x);</span>
    &#125;
    <span class="hljs-keyword">int</span> ans=maxmatch();
    <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"No Solution!\n"</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>匈牙利算法的要点如下</p>
<ol>
<li>从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。<ol>
<li>如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。</li>
<li>如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。</li>
</ol>
</li>
<li>由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 <code>prev</code> 数组。</li>
</ol>
<p>补充定义和定理：</p>
<p><strong>最大匹配数</strong>：最大匹配的匹配边的数目</p>
<p><strong>最小顶点覆盖</strong>：假如选了一个点就相当于覆盖了以它为端点的所有边。最小顶点覆盖就是选择最少的点来覆盖所有的边。很显然，最大匹配中的结点满足该性质，也就是说</p>
<center>最小顶点覆盖数=最大匹配数</center>

<p><strong>最大独立集</strong> ： 二分图中最大的一个点集，该点集内的点互不相连（没有边相连）。回想一下图4 : <img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20150815155559261.png" srcset="/img/loading.gif" alt="这里写图片描述">显然这里给出了图的一个最大匹配，将最大匹配中的点从原来的节点集合V中删除，那么剩下的点不会有任何边相连，也就是说</p>
<center>最大独立集数目=|V|−最大匹配数</center>

<p><strong>最小路径覆盖数</strong>：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。</p>
<center>最小路径覆盖=最大独立集=|V|−最大匹配</center>

<p><strong>无向图的最大团</strong>:  从V个顶点选出k个顶点，使得这k个顶点构成一个完全图，即该子图任意两个顶点都有直接的边。</p>
<center>最大团 = 补图的最大独立集</center>

<h4 id="二分图最大权匹配（KM算法）"><a href="#二分图最大权匹配（KM算法）" class="headerlink" title="二分图最大权匹配（KM算法）"></a><strong>二分图最大权匹配（KM算法）</strong></h4><p>参考博客：<a href="http://blog.csdn.net/zxn0803/article/details/49999267" target="_blank" rel="noopener">http://blog.csdn.net/zxn0803/article/details/49999267</a></p>
<p><a href="https://www.cnblogs.com/wenruo/p/5264235.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenruo/p/5264235.html</a></p>
<p>相等子图是原图的一个生成子图（生成子图即包含原图的所有结点，但是不包含所有的边）,并且该生成子图中只包含满足lx(x)+ly(y)=weight(x,y)的边,这样的边我们称之为可行边。</p>
<p>步骤如下：<br>首先用邻接矩阵存储二分图，注意：<strong>如果只想求最大权值匹配而不要求是完备匹配的话，请把各个不相连的边的权值设置为0</strong>。<br>之后进行下述步骤：<br>1.运用贪心算法初始化标杆。<br>2.运用匈牙利算法找到完备匹配。<br>3.如果找不到，则通过修改标杆，增加一些边。<br>4.重复2，3的步骤，找到完备匹配时可结束。<br>标杆分为X标杆和Y标杆，一般我们把比较少的点放在X标杆一侧。<br>这样进行算法：<br>首先要初始化两个标杆分别为X标杆和Y标杆，X标杆初始化为与之相连的最大边权，Y标杆初始化为0，且直接加入拥有最大边权的边。如果发现此时的匹配就是完备匹配，那么直接退出，否则进行标杆的更改。从第一个节点开始扫描，如果有合法的增广路，那么将其反选，扩充路径，如果该节点没有合法的增广路，那么则将增广路上的所有的X标杆上的点加入点集S,将Y标杆上的所有点加入点集T，从S和不在T集合中的点里面，计算d=min{L(x)+L(y)-w(x,y)};计算后，将在S点集内的x的顶标减d，在T的y的顶标加d。并将目前没有加入二分图的权值和等于顶标和的边作为未匹配边加入到二分图中，然后再在该节点寻找增广路，如果还是没有，则再次通过更改标杆来增加边，直到有增广路出现为止。之后重复寻找增广路的步骤以及更改标杆的步骤，如果出现了完备匹配，那么直接退出。<br>我认为：求d的过程是把xy的顶标和及其权值相差最小的边加入到二分图中，而修改顶标的过程是使得其顶标之和等于新增入的边权，并使得之前选择的那些边仍然存在（即其顶标和仍等于权值和）。<br>看得有点绕？<br>我们来看一下强行手工模拟：<br>有邻接矩阵如下：<br>x1 x2 x3 x4 x5<br>y1 7 3 14 19 23<br>y2  <em>8</em>  <em>10</em>  <em>15</em> 18 20<br>y3 6 8 12 16 19<br>y4 4 9 13  <em>20</em>  <em>25</em><br>y5 2 7 12 10 15<br>非常完美的一个邻接矩阵，其中斜体为边权最大值。下面我们按照上面的晕乎乎的步骤来进行模拟吧。 </p>
<p>初始化标杆使X标杆的值为斜体字的值。<br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184147332.png" srcset="/img/loading.gif" alt="KM算法1"><br>连接每条边并且使得x1和y3匹配，然后遍历x2，发现x2找不到合法增广路。<br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184201273.png" srcset="/img/loading.gif" alt="KM算法2"><br>把不合法路径上的x点都归为点集S,y点都归为T,将不在T中的y点和在S中的点尝试进行加边。<br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184222429.png" srcset="/img/loading.gif" alt="KM算法3"><br>找到两条边，更新顶标之后，成功形成增广路，运用匈牙利算法反选。<br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184247664.png" srcset="/img/loading.gif" alt="KM算法4"><br>给x3找一个合法的增广路，一下就找到了，直接反选，结束。 </p>
<p>下面不对，应该只有一条不合法路径，S={x2,x3,x4},T={y2,y4}，所以x1和y1不变。</p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184259230.png" srcset="/img/loading.gif" alt="KM算法5"></p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184313723.png" srcset="/img/loading.gif" alt="KM算法6"><br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184404897.png" srcset="/img/loading.gif" alt="KM算法7"><br><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184421687.png" srcset="/img/loading.gif" alt="KM算法8"><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20151124184457642.png" srcset="/img/loading.gif" alt="KM算法9"></p>
<p>一个优化是对Y顶点引入松弛函数slack，slack[j]保存跟当前节点j相连的节点i的lx[i]+ly[j]−weight(i,j)的最小值，于是求delta时只需O(n)枚举<strong>不在交错树</strong>中的Y顶点的最小slack值即可。</p>
<p>松弛值可以在匈牙利算法检查相等子树边失败时进行更新，同时在修改标号后也要更新，具体参考代码实现。</p>
<p>如果我们要求边权值最小的匹配呢？？？</p>
<p>我们可以把边权值取负值，得出结果后再取相反数就可以了。</p>
<p>以HDU 2255为例</p>
<pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> nx,ny;
<span class="hljs-keyword">int</span> w[<span class="hljs-number">310</span>][<span class="hljs-number">310</span>];
<span class="hljs-keyword">int</span> lx[<span class="hljs-number">310</span>],ly[<span class="hljs-number">310</span>];
<span class="hljs-keyword">int</span> link[<span class="hljs-number">310</span>];<span class="hljs-comment">//右边对应的左边的编号</span>
<span class="hljs-keyword">bool</span> visx[<span class="hljs-number">310</span>],visy[<span class="hljs-number">310</span>];
<span class="hljs-keyword">int</span> slack[<span class="hljs-number">310</span>];<span class="hljs-comment">//跟当前节点j相连的节点i的lx[i]+ly[j]−weight(i,j)的最小值</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span><span class="hljs-comment">//寻找增广路</span></span>
<span class="hljs-function"></span>&#123;
    visx[id]=<span class="hljs-literal">true</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ny;i++)
    &#123;
        <span class="hljs-keyword">if</span>(visy[i])<span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">int</span> temp=lx[id]+ly[i]-w[id][i];
        <span class="hljs-keyword">if</span>(temp==<span class="hljs-number">0</span>)<span class="hljs-comment">//“lx[t]+ly[i]==w[t][i]”决定了这是在相等子图中找增广路的前提</span>
        &#123;
            visy[i]=<span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span>(link[i]==<span class="hljs-number">-1</span>||dfs(link[i]))
            &#123;
                link[i]=id;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">else</span> slack[i]=<span class="hljs-built_in">min</span>(slack[i],temp);<span class="hljs-comment">//(x,y)不在相等子图中且y不在交错树中</span>
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KM</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">memset</span>(link,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(link));
    <span class="hljs-built_in">memset</span>(ly,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(ly));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nx;i++)
    &#123;
        lx[i]=-INF;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ny;j++)
            lx[i]=<span class="hljs-built_in">max</span>(lx[i],w[i][j]);
    &#125;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nx;i++)
    &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ny;j++)slack[j]=INF;<span class="hljs-comment">//每次换新的x结点都要初始化slack</span>
        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//如果没有找到一条合法增广路，就一直加边</span>
        &#123;
            <span class="hljs-built_in">memset</span>(visx,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(visx));
            <span class="hljs-built_in">memset</span>(visy,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(visy));
            <span class="hljs-keyword">if</span>(dfs(i))<span class="hljs-keyword">break</span>;<span class="hljs-comment">//找到增广路，退出</span>
            <span class="hljs-keyword">int</span> d=INF;<span class="hljs-comment">//否则，应该加入新的边，计算d的值</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ny;j++)
                <span class="hljs-keyword">if</span>(!visy[j])d=<span class="hljs-built_in">min</span>(d,slack[j]);
            <span class="hljs-comment">//if(d==INF)return -1;//找不到可以加入的边，即没有完美匹配</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;nx;j++)
                <span class="hljs-keyword">if</span>(visx[j])lx[j]-=d;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ny;j++)
            &#123;
                <span class="hljs-keyword">if</span>(visy[j])ly[j]+=d;
                <span class="hljs-keyword">else</span> slack[j]-=d;
                <span class="hljs-comment">//修改顶标后，要把所有的slack值都减去delta</span>
                <span class="hljs-comment">//这是因为lx[i] 减小了delta</span>
                <span class="hljs-comment">//slack[j] = min(lx[i] + ly[j] -w[i][j]) --j不属于交错树--也需要减少delta</span>
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ny;i++)
    &#123;
        <span class="hljs-keyword">if</span>(link[i]!=<span class="hljs-number">-1</span>)
            sum+=w[link[i]][i];
    &#125;
    <span class="hljs-keyword">return</span> sum;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)
    &#123;
        nx=ny=n;
        <span class="hljs-comment">//memset(w,0,sizeof(w));</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nx;i++)
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;ny;j++)
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;w[i][j]);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,KM());
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<h4 id="二分图多重匹配"><a href="#二分图多重匹配" class="headerlink" title="二分图多重匹配"></a><strong>二分图多重匹配</strong></h4><p>二分图多重最大匹配：</p>
<p>在原图上建立源点S和汇点T，S向每个X方点连一条容量为该X方点L值的边，每个Y方点向T连一条容量为该Y方点L值的边，原来二分图中各边在新的网络中仍存在，容量为1（若该边可以使用多次则容量大于1），求该网络的最大流，就是该二分图多重最大匹配的值。</p>
<p>二分图多重最优匹配：<br>在原图上建立源点S和汇点T，S向每个X方点连一条容量为该X方点L值、费用为0的边，每个Y方点向T连一条容量为该Y方点L值、费用为0的边，原来二分图中各边在新的网络中仍存在，容量为1（若该边可以使用多次则容量大于1），费用为该边的权值。求该网络的最大费用最大流，就是该二分图多重最优匹配的值。</p>
<p>以hihocoder1393为例：<a href="https://hihocoder.com/problemset/problem/1393" target="_blank" rel="noopener">https://hihocoder.com/problemset/problem/1393</a></p>
<p>题意：</p>
<p>班级一共有N名学生，编号依次为1..N。运动会一共有M项不同的比赛，编号为1..M。第i项比赛每个班需要派出m[i]名选手参加。</p>
<p>编号为i的学生表示最多同时参加a[i]项比赛，并且给出他所擅长的b[i]项比赛的编号。</p>
<p>要求将每个学生都安排到他所擅长的比赛项目，以增加夺冠的可能性。同时又要考虑满足每项比赛对人数的要求，当然给一个学生安排的比赛项目也不能超过他愿意参加的比赛项目数量。</p>
<p>问能否有一个合适的安排，同时满足这些条件。</p>
<p>思路：</p>
<p>将学生看作A部，比赛项目看作B部，比如编号为i的学生擅长编号为j的项目，那么就连接A[i]-B[j]。</p>
<p>因为A[i]最多只能和a[i]的点相连。所以我们需要一个方法来限制这个量在0~a[i]之间变动，有点像网络流里面的流量，只能在0和容量之间变动。</p>
<p>首先虚拟一个源点s和汇点t，在s和A[i]之间连接一条容量为a[i]的边，将原来A[i]-B[j]直接的边都改造为从A[i]到B[j]的容量为1的边，由于比赛项目B[j]最多只需要m[j]名选手参加，所以我们不妨限制B[j]-t的容量为m[j]。</p>
<p><img src="http://media.hihocoder.com/problem_images/20160924/14747068019148.jpg" srcset="/img/loading.gif" alt="6.jpg"></p>
<p>s-A[i]：这一类边的流量表示了A[i]参加的项目数量。</p>
<p>A[i]-B[j]：这一类边的流量表示了A[i]是否参加项目B[j]，若参加则流量为1，否则流量为0。</p>
<p>B[j]-t：这一类边的流量表示了参加比赛项目B[j]的选手数量。</p>
<p>由于流网络会自动调整去满足最大流量，所以它会自动调整每个A[i]-B[j]的流量来使得B[j]-t尽可能大。</p>
<p>若每个项目都能够满足人数的话，网络流会自己调整为所有B[j]-t都满流的情况。</p>
<p>只需要最后判断一下每一条B[j]-t的边是否满流，就可以知道能否满足需求。同时还可以根据A[i]-B[j]的情况，计算出每个选手所参加的比赛项目。</p>
<p>代码：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-keyword">int</span> n,m;
<span class="hljs-keyword">int</span> s,e;<span class="hljs-comment">//源点、汇点</span>
<span class="hljs-keyword">int</span> top;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span>
<span class="hljs-class">&#123;</span>
    <span class="hljs-keyword">int</span> to;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cap;
    <span class="hljs-keyword">int</span> next;
&#125;eg[<span class="hljs-number">100010</span>];<span class="hljs-comment">//邻接表要开边数的两倍</span>
<span class="hljs-keyword">int</span> head[<span class="hljs-number">210</span>];
<span class="hljs-keyword">int</span> cur[<span class="hljs-number">210</span>];
<span class="hljs-keyword">int</span> dis[<span class="hljs-number">210</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> z)</span></span>
<span class="hljs-function"></span>&#123;
    eg[top].cap=z;
    eg[top].to=y;
    eg[top].next=head[x];
    head[x]=top++;
&#125;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;
    dis[s]=<span class="hljs-number">0</span>;
    q.push(s);
    <span class="hljs-keyword">while</span>(!q.empty())
    &#123;
        <span class="hljs-keyword">int</span> id=q.front();
        q.pop();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)
        &#123;
            <span class="hljs-keyword">int</span> temp=eg[i].to;
            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)
            &#123;
                dis[temp]=dis[id]+<span class="hljs-number">1</span>;
                q.push(temp);
                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cp)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res=<span class="hljs-number">0</span>,f;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)
    &#123;
        <span class="hljs-keyword">int</span> temp=eg[i].to;
        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)
        &#123;
            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));
            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)
            &#123;
                eg[i].cap-=f;
                eg[i^<span class="hljs-number">1</span>].cap+=f;
                res+=f;
                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;
    <span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(bfs())
    &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+m+<span class="hljs-number">1</span>;i++)
            cur[i]=head[i];
        ans+=dfs(s,INF);
    &#125;
    <span class="hljs-keyword">return</span> ans;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> t;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;t);
    <span class="hljs-keyword">while</span>(t--)
    &#123;
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x;
        <span class="hljs-keyword">int</span> y;
        <span class="hljs-keyword">int</span> z;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);<span class="hljs-comment">//学生/比赛</span>
        top=<span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));
        s=<span class="hljs-number">0</span>;e=n+m+<span class="hljs-number">1</span>;
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)
        &#123;
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;x);
            sum+=x;
            add(n+i,e,x);
            add(e,n+i,<span class="hljs-number">0</span>);
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        &#123;
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>,&amp;x);
            add(s,i,x);
            add(i,s,<span class="hljs-number">0</span>);
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;y);
            <span class="hljs-keyword">while</span>(y--)
            &#123;
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;z);
                z+=n;
                add(i,z,<span class="hljs-number">1</span>);
                add(z,i,<span class="hljs-number">0</span>);
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(dinic()==sum)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Yes\n"</span>);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No\n"</span>);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<h4 id="最小路径覆盖的网络流做法"><a href="#最小路径覆盖的网络流做法" class="headerlink" title="最小路径覆盖的网络流做法"></a><strong>最小路径覆盖的网络流做法</strong></h4><p>hihocoder1394：<a href="http://hihocoder.com/problemset/problem/1394" target="_blank" rel="noopener">http://hihocoder.com/problemset/problem/1394</a></p>
<p>代码：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> INF=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">int</span> s,e;<span class="hljs-comment">//源点、汇点</span>
<span class="hljs-keyword">int</span> top;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span>
<span class="hljs-class">&#123;</span>
    <span class="hljs-keyword">int</span> to;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cap;
    <span class="hljs-keyword">int</span> next;
&#125;eg[<span class="hljs-number">100010</span>];<span class="hljs-comment">//邻接表要开边数的两倍</span>
<span class="hljs-keyword">int</span> head[<span class="hljs-number">1010</span>];
<span class="hljs-keyword">int</span> cur[<span class="hljs-number">1010</span>];
<span class="hljs-keyword">int</span> dis[<span class="hljs-number">1010</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> z)</span></span>
<span class="hljs-function"></span>&#123;
    eg[top].cap=z;
    eg[top].to=y;
    eg[top].next=head[x];
    head[x]=top++;
&#125;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(dis));
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;
    dis[s]=<span class="hljs-number">0</span>;
    q.push(s);
    <span class="hljs-keyword">while</span>(!q.empty())
    &#123;
        <span class="hljs-keyword">int</span> id=q.front();
        q.pop();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)
        &#123;
            <span class="hljs-keyword">int</span> temp=eg[i].to;
            <span class="hljs-keyword">if</span>(dis[temp]==<span class="hljs-number">-1</span>&amp;&amp;eg[i].cap&gt;<span class="hljs-number">0</span>)
            &#123;
                dis[temp]=dis[id]+<span class="hljs-number">1</span>;
                q.push(temp);
                <span class="hljs-keyword">if</span>(temp==e)<span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> dis[e]!=<span class="hljs-number">-1</span>;
&#125;
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cp)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span>(id==e||cp==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> cp;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res=<span class="hljs-number">0</span>,f;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[id];i!=<span class="hljs-number">-1</span>;i=eg[i].next)
    &#123;
        <span class="hljs-keyword">int</span> temp=eg[i].to;
        <span class="hljs-keyword">if</span>(dis[temp]==dis[id]+<span class="hljs-number">1</span>)
        &#123;
            f=dfs(temp,<span class="hljs-built_in">min</span>(cp-res,eg[i].cap));
            <span class="hljs-keyword">if</span>(f&gt;<span class="hljs-number">0</span>)
            &#123;
                eg[i].cap-=f;
                eg[i^<span class="hljs-number">1</span>].cap+=f;
                res+=f;
                <span class="hljs-keyword">if</span>(res==cp)<span class="hljs-keyword">return</span> cp;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">0</span>)dis[id]=<span class="hljs-number">-1</span>;
    <span class="hljs-keyword">return</span> res;
&#125;
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(bfs())
    &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;i++)
            cur[i]=head[i];
        ans+=dfs(s,INF);
    &#125;
    <span class="hljs-keyword">return</span> ans;
&#125;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> m,x,y;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);
    top=<span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));
    s=<span class="hljs-number">0</span>;e=<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        add(s,i,<span class="hljs-number">1</span>),add(i,s,<span class="hljs-number">0</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n;i++)
        add(i,e,<span class="hljs-number">1</span>),add(e,i,<span class="hljs-number">0</span>);
    <span class="hljs-keyword">while</span>(m--)
    &#123;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;x,&amp;y);
        add(x,n+y,<span class="hljs-number">1</span>),add(n+y,x,<span class="hljs-number">0</span>);
    &#125;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,n-dinic());
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<h4 id="二分图常用建图方法"><a href="#二分图常用建图方法" class="headerlink" title="二分图常用建图方法"></a>二分图常用建图方法</h4><h5 id="行列匹配法"><a href="#行列匹配法" class="headerlink" title="行列匹配法"></a>行列匹配法</h5><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802104803640.png" srcset="/img/loading.gif" alt="img"></p>
<p>上图是一个 3 * 3 的矩阵，方格内的 1 表示这个地方有敌人，0 表示没有敌人,现在我们有很多箭，每根箭可以杀死一行或者一列的敌人，问我们要杀死所有的敌人至要用到几根箭？<br>我们要杀死某个敌人，只要让他所在的行列有箭经过就行。也就是所有的位置都被箭覆盖就行，就是顶点的最小覆盖，既然是顶点的最小覆盖，而且我们要杀的是敌人，那么我们的点就应该是敌人的位子，即(行列)对于上面那个图我么可以建立下面这个模型：</p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802105126921.png" srcset="/img/loading.gif" alt="img"></p>
<p>一个二分图的最小顶点覆盖就是要找到最少的边把所有的顶点覆盖，二分图的最小顶点覆盖是等于二分图的最大匹配。所以我们只需要对上面的那个二分图就最大匹配就行。</p>
<h5 id="黑白染色法"><a href="#黑白染色法" class="headerlink" title="黑白染色法"></a>黑白染色法</h5><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802105325500.png" srcset="/img/loading.gif" alt="img"></p>
<p>又是一个图，要求是把方格里的所有的 1 改为零，一次最多只能修改相邻的两个，问最少需要修改几次? </p>
<p>既然是每次只能拿相邻的两个，正好我们匹配的时候也是找两个进行匹配，这是否就是这个题和最大二分图匹配相联系的地方呢？但是每个点能和他四周的四个点匹配,那么我们怎么把所有的点分成两个部分呢？就是要把第i个点放到第一部分，第i个点周围的四个点放到第二部分，再把这四个点周围的点放到第一部分。有了这样的思想，我们只需对原图做这样的改动：黑白染色使四周和中间的颜色不同。</p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802105807265.png" srcset="/img/loading.gif" alt="img"></p>
<p>图中黑白的意思是就是把点分类，图里的 1,2,3,4,5,6 表示的就是上面那个 0，1 图的1 的个数，然后建图，把相邻的点相连，比如说1和2，2和3。</p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802105906030.png" srcset="/img/loading.gif" alt="img"></p>
<p>然后要把所有一改为零，也就是要对每个点都操作，每个点都要有，那不就是最小顶点覆盖吗？这个问题解决了。</p>
<h5 id="反建法"><a href="#反建法" class="headerlink" title="反建法"></a>反建法</h5><p>问题背景:一个极度封建的老师要带同学们出去玩,但是他怕在途中同学之间发生恋情老师研究了一下发现,满足下面几种条件的两个同学之间发生恋情的可能性很小<br>1）身高差 &gt; 40<br>2）性别相同<br>3）爱好不同的音乐<br>4）爱好同类型的运动<br>显然如果我们用满足上面条件的同学之间建边那么最后建立起来的就不是二分图了。稍微观察一下,男生之间我们是随便带的,女生也是,因为他们彼此性别相同。因此我们就可以把男女分为两部分,那么男女之间如何建边?如果我们把男女满足不发生恋情的连起来,那么求出来的最大匹配没有代表性,不能得到我们想要的结果。因此我们用反建法,把男女中可能发生恋情的建立边。也就是说把身高差&lt;=40 或 爱好相同音乐或爱好不同类型运动的男女同学之间用边连起来。然后求一个最大独立集,最大独立集的原则不就是找到一个点集,使得集合内的点互不相连且点尽量多吗?我们把可能发生恋情的男女相连,那么最大独立集不就是我们要找的不可能发生恋情的人的集合吗? 那么, 这个问题解决了!</p>
<h5 id="拆点法"><a href="#拆点法" class="headerlink" title="拆点法"></a>拆点法</h5><p>拆点法是用于解决最小路径覆盖问题的,给出一个图</p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110208488.png" srcset="/img/loading.gif" alt="img"></p>
<p>要找到几条路径,可以把所有的点经过,并且路径之间不可以交叉。我们的做法是把点拆成两部分(点 1 拆为 x1,y1. 点 2 拆为 x2,y2……)</p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110300686.png" srcset="/img/loading.gif" alt="img"></p>
<p>如果我们对这个图求二分图的最大匹配,你会发现每个匹配对应着一个路径覆盖,因此,此二分图的最大匹配即:原图中的最小路径覆盖上的边的个数(路径是由 0 条,1 条或多条边组成的)。那么原图的最小路径覆盖数 = 原图顶点数 – 最小路径上的边数 也就是 原图的最小路径覆盖数 = 原图顶点数 – 二分图最大匹配数。</p>
<h5 id="一行变多行-一列变多列"><a href="#一行变多行-一列变多列" class="headerlink" title="一行变多行,一列变多列"></a>一行变多行,一列变多列</h5><p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110411526.png" srcset="/img/loading.gif" alt="img"></p>
<p>上面是一个 4*4 的方格,方格内的###表示墙,我们要在表格内没有墙的地方建立碉堡,而且要保证任何两个碉堡之间互相不能攻击,问最多能建多少个碉堡?是否感觉像第一个题呢?如果我们向第一个题那样建图,那么最后求出来的最大匹配也就是行和列的匹配。而且这个匹配满足了所有匹配都是不同行不同列(匹配本身的性质就是每个点至多属于匹配中的某个边)。但是这样的建图的话,我们墙怎么处理? 有墙的地方就相当于把这一行和这一列分成了两行,两列。<br>例如</p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110605983.png" srcset="/img/loading.gif" alt="img"></p>
<p>一行变成了两行。</p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110450890.png" srcset="/img/loading.gif" alt="img"></p>
<p>然后我们按照这个编号建图即可</p>
<p><img src="https://pattle-1256208834.cos.ap-shanghai.myqcloud.com/20140802110558718.png" srcset="/img/loading.gif" alt="img"></p>
<p>对这个图求二分图最大匹配即可。这个问题也解决了!</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2018/02/08/%E7%BD%91%E7%BB%9C%E6%B5%81/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">网络流</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2018/02/05/POJ-1696-%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F/">
                        <span class="hidden-mobile">POJ 1696 极角排序</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "匹配问题&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.staticfile.org/mathjax/3.0.5/es5/tex-svg.js" ></script>

  













  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?a5dc56eafecca743bd237bbc54f64e67";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
